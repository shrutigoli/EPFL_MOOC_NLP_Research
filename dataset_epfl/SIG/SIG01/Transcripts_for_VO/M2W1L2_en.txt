1
00:00:22,934 --> 00:00:24,205
Welcome to this course

2
00:00:24,405 --> 00:00:26,985
which will focus on relational databases

3
00:00:27,185 --> 00:00:31,563
which are the most widely
used form of database

4
00:00:31,763 --> 00:00:34,797
and which we find in absolutely
all the domains of daily life.

5
00:00:34,997 --> 00:00:37,358
The objectives of this lesson

6
00:00:37,558 --> 00:00:40,256
consist in discovering the databases

7
00:00:40,456 --> 00:00:42,443
in particular relational databases

8
00:00:42,643 --> 00:00:44,937
and how the spatial dimension

9
00:00:45,137 --> 00:00:46,466
is integrated into these databases.

10
00:00:46,666 --> 00:00:48,550
At the end of this lesson

11
00:00:48,750 --> 00:00:51,491
you should be able to describe

12
00:00:51,691 --> 00:00:55,307
the concepts that form
the relational databases

13
00:00:55,507 --> 00:00:58,270
as well as the various
types of objects they contain.

14
00:00:59,782 --> 00:01:00,687
In the previous lesson

15
00:01:00,887 --> 00:01:03,773
we saw several forms of data storage

16
00:01:03,973 --> 00:01:05,073
as simple files

17
00:01:05,273 --> 00:01:06,692
or semi-structured files.

18
00:01:06,892 --> 00:01:09,969
Today, we will review the

19
00:01:10,169 --> 00:01:12,613
data storage possibilities

20
00:01:12,813 --> 00:01:14,488
namely the databases

21
00:01:14,688 --> 00:01:17,410
which allow a more structured storage

22
00:01:17,610 --> 00:01:20,470
and most of the time a centralized storage

23
00:01:20,670 --> 00:01:22,305
in a client-server architecture.

24
00:01:22,505 --> 00:01:23,567
In this lesson,

25
00:01:23,767 --> 00:01:27,045
we will address the question
of defining a database

26
00:01:27,245 --> 00:01:30,121
the reliability notions
of these databases.

27
00:01:30,321 --> 00:01:34,034
We will give a brief historical overview

28
00:01:34,252 --> 00:01:37,177
of the evolution of the different
types of database.

29
00:01:37,377 --> 00:01:40,938
We will focus on the relational model

30
00:01:41,138 --> 00:01:42,686
which we will see in detail.

31
00:01:42,886 --> 00:01:45,978
We will then discuss how

32
00:01:46,178 --> 00:01:48,655
the spatial component is managed

33
00:01:48,855 --> 00:01:50,360
in these databases.

34
00:01:50,560 --> 00:01:53,207
And finally, a first brief overview

35
00:01:53,407 --> 00:01:55,297
of DBMS softwares,

36
00:01:55,497 --> 00:01:58,029
Database Management System softwares,

37
00:01:58,229 --> 00:02:01,366
that we will also see on several occasions

38
00:02:01,566 --> 00:02:02,519
in the following lessons.

39
00:02:08,715 --> 00:02:10,707
A database can be defined

40
00:02:10,907 --> 00:02:12,450
as a collection of persistent data

41
00:02:12,650 --> 00:02:14,707
possibly centralized

42
00:02:14,907 --> 00:02:16,933
used by several applications

43
00:02:17,133 --> 00:02:19,087
and by several groups of users

44
00:02:19,287 --> 00:02:20,993
which can optionally work in parallel.

45
00:02:21,193 --> 00:02:24,299
We can see that with
this very general definition

46
00:02:24,499 --> 00:02:27,453
the data hosting files

47
00:02:27,653 --> 00:02:29,284
that we saw in the previous lesson

48
00:02:29,484 --> 00:02:31,757
can also be considered as databases

49
00:02:31,957 --> 00:02:34,892
as they offer a certain persistence

50
00:02:35,092 --> 00:02:36,622
to the information storage.

51
00:02:36,822 --> 00:02:39,047
Database management systems

52
00:02:39,247 --> 00:02:40,648
are softwares

53
00:02:40,848 --> 00:02:44,284
which allow us to create,
structure, document

54
00:02:44,484 --> 00:02:45,652
and consult the databases.

55
00:02:45,852 --> 00:02:49,038
It is actually the interface between

56
00:02:49,238 --> 00:02:51,026
the database and the users

57
00:02:51,226 --> 00:02:53,299
or the applications that use databases.

58
00:02:53,499 --> 00:02:55,727
As shown in this image

59
00:02:55,927 --> 00:02:58,182
there is a very large number of them

60
00:02:58,382 --> 00:03:00,569
both in the commercial field

61
00:03:00,769 --> 00:03:02,307
as in the open-source software field.

62
00:03:03,565 --> 00:03:05,000
The changes in a database

63
00:03:05,200 --> 00:03:06,895
are the result of transactions.

64
00:03:07,095 --> 00:03:10,035
Les transactions being
a sequence of operations

65
00:03:10,235 --> 00:03:13,104
which make the database go
from an initial state

66
00:03:13,304 --> 00:03:14,493
to a final state.

67
00:03:14,693 --> 00:03:17,265
For a database

68
00:03:17,465 --> 00:03:19,990
to go from an integral
and coherent initial state

69
00:03:20,190 --> 00:03:22,547
to an integral and coherent final state,

70
00:03:22,747 --> 00:03:26,705
the transactions must meet
a number of criteria

71
00:03:26,905 --> 00:03:32,451
which are the atomicity, the coherence,
the isolation and the durability,

72
00:03:32,651 --> 00:03:36,509
criteria that are often called "ACID"

73
00:03:36,709 --> 00:03:39,388
and that we will see
a little more in detail now.

74
00:03:41,633 --> 00:03:43,996
The principle of atomicity
stipulates that the transaction

75
00:03:44,196 --> 00:03:45,803
is done completely or not at all.

76
00:03:46,003 --> 00:03:49,598
In the case here of a transaction
which comprises two operations,

77
00:03:49,798 --> 00:03:52,725
the first one consisting of
deducting 10 from a set A

78
00:03:52,925 --> 00:03:55,802
and the second one of
adding 10 to a set B,

79
00:03:56,002 --> 00:03:59,270
with a validity condition
that A + B = 100

80
00:03:59,470 --> 00:04:02,218
we see that the operation
is carried out in two stages

81
00:04:02,418 --> 00:04:04,770
to get to a result

82
00:04:04,970 --> 00:04:07,442
which is then stored in the database

83
00:04:07,642 --> 00:04:09,927
by an operation called a commit

84
00:04:10,127 --> 00:04:11,868
a validation operation.

85
00:04:12,068 --> 00:04:15,795
One of these operations can sometimes fail

86
00:04:15,995 --> 00:04:18,604
and in that case the
principle of atomicity

87
00:04:18,804 --> 00:04:21,527
wants that the first operation
of the transaction

88
00:04:21,727 --> 00:04:25,327
be reversible and canceled,

89
00:04:25,527 --> 00:04:28,737
meaning that you can return to
the initial state of the database.

90
00:04:28,937 --> 00:04:32,815
Databases should verify
coherency principles.

91
00:04:33,015 --> 00:04:36,516
If we have here the example
of a transaction

92
00:04:36,716 --> 00:04:39,181
which consists of deducting 5
from a set A

93
00:04:39,381 --> 00:04:41,438
and adding 10 to a set B

94
00:04:41,638 --> 00:04:44,615
with a validity condition
A + B = 100

95
00:04:44,815 --> 00:04:45,599
as earlier,

96
00:04:45,799 --> 00:04:48,426
we see clearly that at
the end of the transaction

97
00:04:48,626 --> 00:04:52,477
the result no longer meets
the condition of validity

98
00:04:52,677 --> 00:04:56,930
so the validation has to be prevented

99
00:04:57,130 --> 00:04:59,405
and the transaction as a whole
has to be canceled.

100
00:04:59,605 --> 00:05:01,399
The principle of isolation.

101
00:05:01,599 --> 00:05:04,448
We have here the case
of two transactions

102
00:05:04,648 --> 00:05:07,926
the first consisting
of deducting 10 from a set A

103
00:05:08,126 --> 00:05:09,357
and adding 10 to a set B

104
00:05:09,557 --> 00:05:11,666
with always the same
condition of validity

105
00:05:11,866 --> 00:05:13,760
and a second transaction

106
00:05:13,960 --> 00:05:15,630
which does more or less
the same operation.

107
00:05:15,830 --> 00:05:19,188
We deduct 5 from set B

108
00:05:19,388 --> 00:05:20,842
and we add 5 to set A.

109
00:05:21,042 --> 00:05:23,333
The isolation principle

110
00:05:23,533 --> 00:05:28,090
requires that the execution of these
transactions one after the other

111
00:05:28,290 --> 00:05:29,368
give the same result

112
00:05:29,568 --> 00:05:32,080
only if the transactions
are executed at the same time

113
00:05:32,280 --> 00:05:33,082
that is to say in series.

114
00:05:34,045 --> 00:05:37,383
We see that if one of these operations fails

115
00:05:37,583 --> 00:05:38,963
the last one for example

116
00:05:39,163 --> 00:05:44,122
we have to ensure that
the cancellation principle

117
00:05:44,322 --> 00:05:47,064
brings us back to the database
in a valid state

118
00:05:47,264 --> 00:05:50,208
which is the case in the sequential case.

119
00:05:50,408 --> 00:05:53,137
But when operations
are carried out in series

120
00:05:53,337 --> 00:05:57,163
we see that a special procedure needs

121
00:05:57,363 --> 00:06:00,325
to be implemented at the level
of the database management system

122
00:06:00,525 --> 00:06:02,917
to ensure the execution in series

123
00:06:03,117 --> 00:06:04,087
in case of a glitch

124
00:06:04,287 --> 00:06:06,902
to restore the database
in a valid and coherent state.

125
00:06:07,102 --> 00:06:09,167
Finally, the durability principle

126
00:06:09,367 --> 00:06:12,039
stipulates that the memory
recording of the transaction

127
00:06:12,239 --> 00:06:13,788
at the time of validation

128
00:06:13,988 --> 00:06:16,636
can not be prevented

129
00:06:16,836 --> 00:06:19,233
or interrupted by an external event.

130
00:06:19,433 --> 00:06:22,081
For example, a power failure

131
00:06:22,281 --> 00:06:24,749
an earthquake or whatever.

132
00:06:24,949 --> 00:06:27,509
This means technically

133
00:06:27,709 --> 00:06:30,726
that it is necessary to avoid
going through a buffer memory

134
00:06:30,926 --> 00:06:33,333
which could be erased in case
of a power failure

135
00:06:33,533 --> 00:06:35,323
before the actual validation.

136
00:06:37,826 --> 00:06:39,428
In summary, the ACID principles

137
00:06:39,628 --> 00:06:41,365
stipulate for the atomicity

138
00:06:41,565 --> 00:06:45,426
that a transaction must
be completely performed or not at all,

139
00:06:45,626 --> 00:06:47,713
for the coherence

140
00:06:47,913 --> 00:06:50,026
that we will verify
at the level of the database,

141
00:06:50,226 --> 00:06:52,515
the conditions of validity,

142
00:06:52,715 --> 00:06:54,412
the isolation principle,

143
00:06:54,612 --> 00:06:56,928
that an execution in series

144
00:06:57,128 --> 00:06:59,768
gives the same result
as a sequential execution

145
00:06:59,968 --> 00:07:02,308
of the different operations
of a transaction,

146
00:07:02,508 --> 00:07:04,795
Aad finally, the principle of durability

147
00:07:04,995 --> 00:07:07,844
stipulates that external incidents,

148
00:07:08,044 --> 00:07:09,349
power failure or other,

149
00:07:09,549 --> 00:07:13,631
should not affect how information
is stored and validated

150
00:07:13,831 --> 00:07:15,002
in the database.

151
00:07:24,484 --> 00:07:27,372
We now move on to the historical
typology of databases.

152
00:07:28,447 --> 00:07:30,302
From the 50's and 60's

153
00:07:30,502 --> 00:07:33,106
storage in the form of
files has developed,

154
00:07:33,306 --> 00:07:36,897
we saw some examples
in the previous lesson,

155
00:07:37,097 --> 00:07:40,761
then, from the 60's-70's

156
00:07:40,961 --> 00:07:42,194
first there was the development of

157
00:07:42,394 --> 00:07:43,419
hierarchical databases.

158
00:07:43,619 --> 00:07:45,831
Recordings are associated by relations

159
00:07:46,031 --> 00:07:47,596
according to a descending tree.

160
00:07:47,796 --> 00:07:50,347
Each element has one and
only one parent.

161
00:07:50,547 --> 00:07:52,741
In the fields of application,

162
00:07:52,941 --> 00:07:55,391
organizational structures, file systems,

163
00:07:55,591 --> 00:07:58,054
taxonomic systems, etc.

164
00:07:58,254 --> 00:08:01,022
Subsequently the network databases

165
00:08:01,222 --> 00:08:03,771
which are a variant of
the hierarchical databases

166
00:08:03,971 --> 00:08:07,936
with just a multiplicity of
possible parents

167
00:08:08,136 --> 00:08:10,293
which tree structure
is no longer strictly descending.

168
00:08:10,493 --> 00:08:12,717
There can be cyclical structures.

169
00:08:12,917 --> 00:08:15,047
From the 70's-80's

170
00:08:15,247 --> 00:08:16,712
relational databases

171
00:08:16,912 --> 00:08:20,663
which propose
on the principle of recordings

172
00:08:20,863 --> 00:08:22,928
hosted in two-dimensional tables.

173
00:08:23,128 --> 00:08:25,284
A relationship being a slab,

174
00:08:25,484 --> 00:08:28,070
an attribute in a column or field

175
00:08:28,270 --> 00:08:29,033
and the object in the lines.

176
00:08:29,233 --> 00:08:31,339
From the 90's

177
00:08:31,539 --> 00:08:32,553
the object databases

178
00:08:32,753 --> 00:08:34,157
and semi-structured databases

179
00:08:34,357 --> 00:08:37,208
in which the data are stored

180
00:08:37,408 --> 00:08:38,955
in the form of objects which can have

181
00:08:39,155 --> 00:08:41,865
specific and variable structures

182
00:08:42,065 --> 00:08:44,692
and of different types.

183
00:08:44,892 --> 00:08:46,604
We will speak more precisely
in this lesson

184
00:08:46,804 --> 00:08:48,083
of relational databases

185
00:08:48,283 --> 00:08:50,844
and the object databases theme

186
00:08:51,044 --> 00:08:54,048
will be addressed more specifically

187
00:08:54,248 --> 00:08:55,447
in a later lesson.

188
00:09:05,837 --> 00:09:08,119
The relational model was developed

189
00:09:08,319 --> 00:09:12,225
mainly to meet ACID principles

190
00:09:12,425 --> 00:09:15,374
in the transactions that allow
to modify a database

191
00:09:15,574 --> 00:09:19,326
to ensure that there is good
coherence of information,

192
00:09:19,526 --> 00:09:22,033
to avoid redundancy of information.

193
00:09:22,233 --> 00:09:26,146
It is a model that is based
on solid theoretical foundations

194
00:09:26,346 --> 00:09:29,228
since this is based on the set theory

195
00:09:29,428 --> 00:09:31,480
from which relational algebra is derived.

196
00:09:31,680 --> 00:09:35,284
It is a model that was widely used

197
00:09:35,484 --> 00:09:37,771
by all the major players
in the field of databases.

198
00:09:37,971 --> 00:09:41,867
Today, we can say that about
80 to 90% of the databases

199
00:09:42,067 --> 00:09:44,478
are built on the relational model.

200
00:09:44,678 --> 00:09:50,306
It is something that changes
a little bit with the Big Data

201
00:09:50,506 --> 00:09:52,384
which uses other types of models.

202
00:09:52,584 --> 00:09:56,283
But the relational model remains
largely the most important.

203
00:09:56,483 --> 00:09:58,729
It is a model that was developed

204
00:09:58,929 --> 00:10:00,386
in the 70's

205
00:10:00,586 --> 00:10:03,879
at IBM by an engineer named Ted Codd.

206
00:10:04,079 --> 00:10:05,932
In the relational model

207
00:10:06,132 --> 00:10:08,238
the data are organized
in the form of tables

208
00:10:08,438 --> 00:10:09,941
also called "relation".

209
00:10:10,141 --> 00:10:12,103
A relation is made up of columns

210
00:10:12,303 --> 00:10:12,852
or attributes

211
00:10:13,052 --> 00:10:15,263
characterized by a name and a domain,

212
00:10:15,463 --> 00:10:18,224
a domain being a set of values,

213
00:10:18,424 --> 00:10:21,244
for example the domain of integer values,

214
00:10:21,444 --> 00:10:22,762
the boolean domains,

215
00:10:22,962 --> 00:10:27,623
the sport discipline domaine, etc.

216
00:10:27,823 --> 00:10:30,833
In a table, each line
corresponds to a recording

217
00:10:31,033 --> 00:10:32,215
also called "tuple".

218
00:10:32,415 --> 00:10:36,173
For a tuple it can happen
that an attribute

219
00:10:36,373 --> 00:10:37,411
is not valued,

220
00:10:37,611 --> 00:10:38,457
so it has no value

221
00:10:38,692 --> 00:10:44,015
and in this case, we indicate this fact
by the value NULL.

222
00:10:44,215 --> 00:10:47,856
A set cannot contain the
same object twice

223
00:10:48,056 --> 00:10:50,822
and it is for this reason
that in the relational model

224
00:10:51,022 --> 00:10:52,318
we must absolutely ensure

225
00:10:52,518 --> 00:10:54,266
that each object is unique.

226
00:10:54,466 --> 00:10:59,323
The best way to ensure
that this object is unique

227
00:10:59,523 --> 00:11:04,048
is to define an identifier
specifically for the needs

228
00:11:04,248 --> 00:11:07,517
such as in the case of the first
table that we see here

229
00:11:07,717 --> 00:11:11,200
where we created a student number

230
00:11:11,400 --> 00:11:13,909
which allows to
unambiguously identify

231
00:11:14,109 --> 00:11:16,754
each student.

232
00:11:18,279 --> 00:11:21,536
This identifier, sometimes
called "primary key"

233
00:11:21,736 --> 00:11:25,091
can be manufactured
for the needs of the cause

234
00:11:25,291 --> 00:11:27,282
but can also be built

235
00:11:27,482 --> 00:11:29,435
from existing attributes

236
00:11:29,635 --> 00:11:33,896
for example by associating the names
and surnames of the students.

237
00:11:34,096 --> 00:11:36,543
We clearly see that if we only use
the surname and first name

238
00:11:36,743 --> 00:11:39,711
we can be faced with homonym problems

239
00:11:39,911 --> 00:11:44,498
and have several people
who could not be distinguished

240
00:11:44,698 --> 00:11:46,471
by this identifier.

241
00:11:46,671 --> 00:11:50,687
Hence the need to extend the concept

242
00:11:50,887 --> 00:11:53,068
to include the address, the street name

243
00:11:53,268 --> 00:11:54,738
the postal number, etc.

244
00:11:56,685 --> 00:11:59,817
In fact, the identifier
could consist of the set

245
00:12:00,017 --> 00:12:02,191
of fields of the table

246
00:12:02,391 --> 00:12:06,830
with obviously a number
of disadvantages

247
00:12:07,030 --> 00:12:11,720
when it comes to indexing objects

248
00:12:11,920 --> 00:12:14,527
in order to find them faster in a search

249
00:12:14,727 --> 00:12:17,350
or be able to sort things out
or things like that.

250
00:12:17,550 --> 00:12:22,780
It is for this reason that
the use of a specific identifier

251
00:12:22,980 --> 00:12:26,734
is the most common case encountered.

252
00:12:26,934 --> 00:12:30,562
External identifiers,
also known as "foreign keys",

253
00:12:30,762 --> 00:12:34,037
describe links between
different relations,

254
00:12:34,237 --> 00:12:38,519
for example, in the case of
a course followed by students

255
00:12:38,719 --> 00:12:40,395
we have a table of students,
a table of courses,

256
00:12:40,595 --> 00:12:42,032
a table of teachers

257
00:12:42,232 --> 00:12:45,760
and we see that a course
is given by a teacher

258
00:12:45,960 --> 00:12:49,551
and that this teacher must exist
in the teacher's table

259
00:12:49,751 --> 00:12:51,714
for the database to be integral.

260
00:12:51,914 --> 00:12:54,219
In the course follow-up relation,

261
00:12:54,419 --> 00:12:57,889
which associates a student
number with a course title,

262
00:12:58,089 --> 00:13:00,913
so the list of courses
followed by the students

263
00:13:01,113 --> 00:13:03,052
or the list of students
following a course,

264
00:13:03,252 --> 00:13:07,402
we see that the student number
references a student

265
00:13:07,602 --> 00:13:08,671
of the student relation

266
00:13:08,871 --> 00:13:12,778
and "course title" references
a course in the course table.

267
00:13:14,500 --> 00:13:17,517
The reference should point
to a single object

268
00:13:17,717 --> 00:13:18,783
of course

269
00:13:18,983 --> 00:13:22,523
and it can happen that this object is NULL

270
00:13:22,723 --> 00:13:25,740
if the attribute is optional,

271
00:13:25,940 --> 00:13:28,074
for example in the case
of the classroom

272
00:13:28,274 --> 00:13:30,499
which could not have been assigned yet

273
00:13:30,699 --> 00:13:34,293
at the time of documenting the table.

274
00:13:34,493 --> 00:13:37,716
The referential integrity of the database

275
00:13:37,977 --> 00:13:39,555
is automatically verified

276
00:13:39,755 --> 00:13:41,399
by the database management system.

277
00:13:41,599 --> 00:13:44,162
For example, if a user wants to ensure

278
00:13:44,362 --> 00:13:46,958
a new course of geology in the table

279
00:13:47,158 --> 00:13:49,107
of courses followed by students

280
00:13:49,307 --> 00:13:51,539
and this course does not
exist in the course table,

281
00:13:51,739 --> 00:13:53,587
the transaction will be denied.

282
00:13:53,787 --> 00:13:57,274
Similarly, if a user wants
to change the name of a course

283
00:13:57,474 --> 00:14:00,663
and that name does not exist
in the reference table,

284
00:14:00,863 --> 00:14:02,395
the transaction will also be denied.

285
00:14:04,725 --> 00:14:07,531
Similarly, if a user wants
to delete a course

286
00:14:07,731 --> 00:14:10,259
which is referenced
by other relations,

287
00:14:10,459 --> 00:14:12,008
the operation can be refused.

288
00:14:12,208 --> 00:14:16,068
We can delete references in other relations

289
00:14:16,268 --> 00:14:20,673
or alternatively cancel those references.

290
00:14:22,638 --> 00:14:26,372
Similarly, if a user wants
to change the name of a course

291
00:14:26,572 --> 00:14:28,716
in a table and that name
is referenced elsewhere

292
00:14:28,916 --> 00:14:30,406
we can refuse the operation

293
00:14:30,606 --> 00:14:32,956
or update the other table as well.

294
00:14:36,224 --> 00:14:38,089
The relational model
does not lend itself

295
00:14:38,289 --> 00:14:40,963
to a multivalued attribute record,

296
00:14:41,163 --> 00:14:44,757
so that have several values or
complex attributes,

297
00:14:44,957 --> 00:14:46,719
so composed of several elements.

298
00:14:46,919 --> 00:14:51,309
It is therefore necessary
to model them differently.

299
00:14:51,509 --> 00:14:55,736
In the case of a complex
monovaluated attribute,

300
00:14:55,936 --> 00:14:58,440
such as an address

301
00:14:58,640 --> 00:15:00,886
which is composed of a street,
a street number,

302
00:15:01,086 --> 00:15:02,583
a postal number, a locality,

303
00:15:02,783 --> 00:15:08,729
one possibility consists in setting
one attribute, one field per component

304
00:15:08,929 --> 00:15:14,024
as shown by the table on the right

305
00:15:14,224 --> 00:15:17,438
and subsequently to build in the database

306
00:15:17,638 --> 00:15:21,008
a view, which is a virtual table

307
00:15:21,208 --> 00:15:24,260
containing the aggregation
of these different fields

308
00:15:24,460 --> 00:15:26,834
to restore the idea of ​​address.

309
00:15:27,034 --> 00:15:31,776
The other possibility consists in
creating a "global address" attribute

310
00:15:31,976 --> 00:15:34,079
which would be of a character string type

311
00:15:34,279 --> 00:15:37,019
in which the entire address,

312
00:15:37,219 --> 00:15:40,406
road, number, postal code, town, is saved.

313
00:15:40,606 --> 00:15:44,095
We see that in these relations

314
00:15:44,295 --> 00:15:48,675
the student number is an identifier
of the student relation.

315
00:15:48,875 --> 00:15:50,986
For a multivalued attribute,

316
00:15:51,186 --> 00:15:53,867
for example the case
of multiple first names,

317
00:15:54,067 --> 00:15:59,450
one possibility would be
to define several attributes

318
00:15:59,650 --> 00:16:01,472
for each first name,

319
00:16:01,672 --> 00:16:02,947
first name 1, first name 2, etc.

320
00:16:03,147 --> 00:16:06,105
This is a bad choice
because

321
00:16:06,305 --> 00:16:09,009
we do not know how many
first names we need to plan,

322
00:16:09,209 --> 00:16:13,581
if it is not a first name it can
be another type of attribute

323
00:16:13,781 --> 00:16:17,689
which could have an innumerable
succession of elements

324
00:16:17,889 --> 00:16:21,131
so we see that it does not
work very well.

325
00:16:21,331 --> 00:16:25,413
Especially since this leads
to defining many fields

326
00:16:25,613 --> 00:16:27,324
which will be filled with null values.

327
00:16:27,524 --> 00:16:29,990
This is not something
that is very optimal

328
00:16:30,190 --> 00:16:31,014
from the database point of view.

329
00:16:31,214 --> 00:16:37,235
An alternative solution is
to create an additional table

330
00:16:37,435 --> 00:16:40,163
in which first names will be hosted

331
00:16:40,363 --> 00:16:45,077
in relation to the student identifier

332
00:16:45,277 --> 00:16:47,711
to which these first names are related

333
00:16:47,911 --> 00:16:51,609
and so we see that
the "student number" field,

334
00:16:51,809 --> 00:16:53,972
which is a primary key of
the student table

335
00:16:54,172 --> 00:16:57,172
becomes a foreign key

336
00:16:57,372 --> 00:16:58,778
of the "study first name" table.

337
00:16:58,978 --> 00:17:01,974
Another possibility, a little more subtle,

338
00:17:02,174 --> 00:17:05,236
consists in integrating into
the "study first name" table

339
00:17:05,436 --> 00:17:07,444
the number of the first name

340
00:17:07,644 --> 00:17:09,829
so that we are able to restore
the order in which

341
00:17:10,029 --> 00:17:12,513
first names appear,

342
00:17:12,713 --> 00:17:14,911
first name, middle name, etc.

343
00:17:15,111 --> 00:17:19,077
In this case too, the student
number is a primary key

344
00:17:19,277 --> 00:17:20,239
for the "student" table

345
00:17:20,439 --> 00:17:23,383
and a foreign key for
the "study first name" table

346
00:17:23,583 --> 00:17:26,498
which does not have a primary key.

347
00:17:26,698 --> 00:17:28,881
So, we have reviewed

348
00:17:29,081 --> 00:17:32,788
the basic notions of the relational model

349
00:17:32,988 --> 00:17:35,323
namely the domain of values

350
00:17:35,523 --> 00:17:37,720
the attribute, the relation, the tuple

351
00:17:37,920 --> 00:17:39,843
the identifier, the external identifier.

352
00:17:40,043 --> 00:17:42,700
We still have to discuss

353
00:17:42,900 --> 00:17:46,175
the various operators
of relational algebra

354
00:17:46,457 --> 00:17:48,233
that base the operations

355
00:17:48,433 --> 00:17:51,010
which we will subsequently
be able to make on these tables,

356
00:17:51,210 --> 00:17:54,887
operations which we will
discuss in details

357
00:17:55,087 --> 00:17:57,955
in the second week of this module

358
00:17:58,155 --> 00:18:01,972
with everything that is request,
SQL language, etc.

359
00:18:03,757 --> 00:18:07,561
These operators are primarily
union operators

360
00:18:07,761 --> 00:18:10,503
so we are in a set logic.

361
00:18:10,703 --> 00:18:15,905
For the example, we take here
a series of photographs

362
00:18:16,105 --> 00:18:19,961
which were taken by
an author a certain year

363
00:18:20,161 --> 00:18:20,912
in a certain city

364
00:18:21,112 --> 00:18:23,819
and we see that the union of
the two tables

365
00:18:24,019 --> 00:18:30,806
consists in aggregating
these two tables

366
00:18:31,006 --> 00:18:32,294
into one.

367
00:18:34,784 --> 00:18:37,169
The difference between two tables

368
00:18:37,369 --> 00:18:40,379
is the subtraction of the second
o the first

369
00:18:40,579 --> 00:18:47,837
so the elimination of the redundant
objects of the first.

370
00:18:50,134 --> 00:18:53,392
This operation is not commutative,

371
00:18:53,592 --> 00:18:56,528
if done in the other direction
the result will be different.

372
00:18:57,753 --> 00:19:00,148
We then have the cross product

373
00:19:00,348 --> 00:19:05,271
which consists in associating
each element

374
00:19:05,471 --> 00:19:06,105
each tuple

375
00:19:06,305 --> 00:19:09,832
from the first table
to each tuple of the second.

376
00:19:10,032 --> 00:19:14,169
So here the colored and black / white
versions of the photos which...

377
00:19:14,369 --> 00:19:18,025
so we have 2 times 3, 6 pictures.

378
00:19:18,225 --> 00:19:22,322
And then the selection
operations on a table,

379
00:19:22,522 --> 00:19:29,509
a selection which consists in identifying,
extracting a certain number of elements.

380
00:19:29,709 --> 00:19:34,079
Projection operations which
consist in extracting

381
00:19:34,279 --> 00:19:37,695
a certain number of attributes
for the whole table.

382
00:19:37,895 --> 00:19:42,317
Which in this case leads to something
that does not make much sense

383
00:19:42,517 --> 00:19:46,133
in any case which is contrary
to the principles of the set theory

384
00:19:46,333 --> 00:19:48,704
since we have identical objects.

385
00:19:48,904 --> 00:19:51,724
So it is an operation
that would not be valid.

386
00:19:53,924 --> 00:19:55,779
And finally the joint operations

387
00:19:55,979 --> 00:19:58,555
which consist in associating two tables

388
00:19:58,755 --> 00:20:02,247
by means of a field which
would be common to them.

389
00:20:02,447 --> 00:20:05,800
Here, the table of color photographs

390
00:20:06,000 --> 00:20:09,041
with a table that would associate
cities and countries.

391
00:20:09,241 --> 00:20:12,819
The common field being the city obviously.

392
00:20:13,019 --> 00:20:19,462
These joint operations
can be assorted by a condition,

393
00:20:19,662 --> 00:20:24,442
so we could keep only the joint elements

394
00:20:24,642 --> 00:20:26,754
which have Senegal as their country

395
00:20:26,954 --> 00:20:29,418
and so only one photograph

396
00:20:29,618 --> 00:20:33,366
of the three that were included
in the starting joint.

397
00:20:44,511 --> 00:20:47,011
We now come to the specificities

398
00:20:47,211 --> 00:20:50,431
of databases that have a spatial component,

399
00:20:50,631 --> 00:20:53,826
specificities which are mainly

400
00:20:54,026 --> 00:20:55,828
three in number.

401
00:20:56,028 --> 00:20:59,488
First, the type of data

402
00:20:59,688 --> 00:21:03,409
so the fields concerning
these types of data

403
00:21:03,609 --> 00:21:09,961
we see that in the top left table,

404
00:21:10,161 --> 00:21:13,276
in a traditional database we have

405
00:21:13,476 --> 00:21:16,165
a certain number of
well-defined data types,

406
00:21:16,365 --> 00:21:18,002
varchar for the text,

407
00:21:18,202 --> 00:21:19,920
integers for digital,

408
00:21:20,120 --> 00:21:22,726
the real also for numbers and dates.

409
00:21:22,926 --> 00:21:25,195
In the spatial database

410
00:21:25,395 --> 00:21:27,199
we add new data types,

411
00:21:27,399 --> 00:21:29,999
point, line, polygon, etc.

412
00:21:30,199 --> 00:21:32,222
Finally, the basic geometries

413
00:21:32,422 --> 00:21:35,750
which are managed by geographic
information systems.

414
00:21:35,950 --> 00:21:39,120
The second important area

415
00:21:39,320 --> 00:21:41,100
is that of indexing

416
00:21:41,300 --> 00:21:43,064
the indexing of spatial objects

417
00:21:43,264 --> 00:21:46,072
to be able to subsequently
perform requests

418
00:21:46,272 --> 00:21:48,012
and quickly find objects

419
00:21:48,212 --> 00:21:50,538
and finally a number of functions

420
00:21:50,738 --> 00:21:54,035
which allow to carry out
specific operations

421
00:21:54,235 --> 00:21:55,364
on geometric objects.

422
00:21:57,303 --> 00:22:01,141
There are several forms
of data indexing.

423
00:22:01,341 --> 00:22:04,622
In the field of non-spatial databases

424
00:22:04,822 --> 00:22:08,683
we often use a structure

425
00:22:08,883 --> 00:22:09,918
called B-tree

426
00:22:10,118 --> 00:22:12,098
so a hierarchical tree

427
00:22:12,298 --> 00:22:15,847
which makes it easy to find the data.

428
00:22:16,047 --> 00:22:18,479
We have in this illustration

429
00:22:18,679 --> 00:22:20,657
the example of a tree of the order 5

430
00:22:20,857 --> 00:22:27,404
wherein a knot can have
at most 4 keys and 5 children

431
00:22:27,604 --> 00:22:30,493
each knot having at least
2 keys and 3 children.

432
00:22:32,011 --> 00:22:33,579
This hierarchical tree idea

433
00:22:33,779 --> 00:22:35,944
is found in the spatial database field

434
00:22:36,144 --> 00:22:39,752
in the R-tree form

435
00:22:39,952 --> 00:22:42,630
in which the closest objects

436
00:22:42,830 --> 00:22:46,460
are grouped and represented
at the upper scale

437
00:22:46,660 --> 00:22:48,077
by a minimal envelope

438
00:22:48,277 --> 00:22:50,961
which is the minimum bounding rectangle.

439
00:22:51,161 --> 00:22:54,564
And when we then make
a request to find the objects

440
00:22:54,764 --> 00:22:59,478
if the request does not intersect
a minimal envelope

441
00:22:59,678 --> 00:23:01,798
we can eliminate all the objects
of this envelope

442
00:23:01,998 --> 00:23:05,260
and focus on those that remain.

443
00:23:05,460 --> 00:23:07,413
In the image here,

444
00:23:07,613 --> 00:23:08,903
we see on the left

445
00:23:09,103 --> 00:23:16,802
the link between a non-spatial
hierarchical approach

446
00:23:17,002 --> 00:23:19,025
and a spatial hierarchical approach

447
00:23:19,225 --> 00:23:24,923
and then on the right an example
of spatial index structuring

448
00:23:25,123 --> 00:23:30,003
which concerns post offices in Germany.

449
00:23:30,203 --> 00:23:34,418
The Quadtree is another method
of spatial indexing

450
00:23:34,618 --> 00:23:41,029
which is quite often used
in geographical map tiling

451
00:23:41,229 --> 00:23:42,649
like Google, etc.

452
00:23:42,849 --> 00:23:45,831
It is about a tree structure

453
00:23:46,031 --> 00:23:49,441
in which each knot has exactly 4 children

454
00:23:49,641 --> 00:23:52,477
so each geographical
zone is divided into 4

455
00:23:52,677 --> 00:23:56,995
and again in 4 each time we zoom down.

456
00:23:57,195 --> 00:24:03,367
The grid index mode is similar

457
00:24:03,567 --> 00:24:07,053
in the sense that it is
also a regular tessellation

458
00:24:08,791 --> 00:24:12,996
but the subdivision of each entity

459
00:24:13,196 --> 00:24:15,066
is not necessarily done in 4

460
00:24:15,266 --> 00:24:19,644
but can be done in 9, 16, etc.

461
00:24:19,844 --> 00:24:23,925
Amongst the specifics functions
of spatial databases

462
00:24:24,125 --> 00:24:28,470
we can distinguish three main families.

463
00:24:28,670 --> 00:24:31,946
First of all, the family
of spatial measurements

464
00:24:32,146 --> 00:24:35,419
which gives indications
of surface length, distance

465
00:24:35,619 --> 00:24:38,899
about geometric objects.

466
00:24:39,099 --> 00:24:44,200
Spatial functions that create new entities,

467
00:24:44,400 --> 00:24:48,508
for example we can imagine
the creation of a buffer zone

468
00:24:48,708 --> 00:24:50,099
around a geometric object.

469
00:24:50,299 --> 00:24:54,198
The intersection of two objects
that creates a new object,

470
00:24:54,398 --> 00:24:56,174
the union of two objects, etc.

471
00:24:57,997 --> 00:24:59,772
And topological operators

472
00:24:59,972 --> 00:25:04,662
which test the veracity
of the neighborhood relations.

473
00:25:04,862 --> 00:25:08,558
Are two geometries overlaping?

474
00:25:08,795 --> 00:25:09,612
Do they touch each other?

475
00:25:09,812 --> 00:25:11,896
Are they contained in one another?

476
00:25:12,096 --> 00:25:13,121
Or vice versa, etc.

477
00:25:14,528 --> 00:25:16,695
All these different types of functions

478
00:25:16,895 --> 00:25:19,865
are more and more often implemented

479
00:25:20,065 --> 00:25:22,968
in spatial database management systems.

480
00:25:33,784 --> 00:25:35,152
As I said at the beginning of this course

481
00:25:35,352 --> 00:25:38,844
there is a very large number
of database management systems

482
00:25:39,044 --> 00:25:41,789
devoted to the relational model

483
00:25:43,170 --> 00:25:46,536
not only is there a very
large number of databases

484
00:25:46,736 --> 00:25:49,852
but these databases are accessible

485
00:25:50,052 --> 00:25:53,040
through a series of clients

486
00:25:53,240 --> 00:25:56,786
which are either commercial softwares

487
00:25:56,986 --> 00:25:58,795
or open-source softwares.

488
00:25:58,995 --> 00:26:02,997
All of these clients provide
a user interface

489
00:26:03,197 --> 00:26:06,992
and allow to contact these databases

490
00:26:07,192 --> 00:26:08,320
and to manipulate them.

491
00:26:08,520 --> 00:26:11,574
Amongst the features that we want to find

492
00:26:11,774 --> 00:26:13,351
in database management systems,

493
00:26:13,551 --> 00:26:15,480
there are actually three types,

494
00:26:15,680 --> 00:26:19,809
first, those that allow to manage
the structure of the data

495
00:26:20,009 --> 00:26:22,399
so to create new fields,
new attributes

496
00:26:22,599 --> 00:26:23,912
with their area of ​​value

497
00:26:24,112 --> 00:26:28,750
and create new indexes, primary keys,
external keys, etc.,

498
00:26:28,950 --> 00:26:33,692
to view data saved in the database,

499
00:26:33,892 --> 00:26:36,180
to consult the value tables,

500
00:26:36,380 --> 00:26:39,359
possibly to be able
to import data from the outside

501
00:26:39,559 --> 00:26:41,855
to populate these different tables

502
00:26:42,055 --> 00:26:44,322
and finally all the features

503
00:26:44,522 --> 00:26:48,268
which are related to the construction
and execution of queries

504
00:26:48,468 --> 00:26:51,359
to search for objects in a database

505
00:26:51,559 --> 00:26:54,804
on the basis of a certain number of criteria.

506
00:26:55,004 --> 00:26:57,326
This is something we will
see more in details

507
00:26:57,526 --> 00:27:04,107
particularly in the lessons
of the second week of this module.

508
00:27:04,307 --> 00:27:07,758
For now, we will take a small example

509
00:27:07,958 --> 00:27:12,058
which is that of the Seychelles districts

510
00:27:12,258 --> 00:27:17,059
that can be exported
in a database format,

511
00:27:17,259 --> 00:27:19,086
in this case a SpatiaLite database.

512
00:27:20,845 --> 00:27:24,864
So we will call this file "mahe.sqlite"

513
00:27:25,064 --> 00:27:26,967
and save it.

514
00:27:29,181 --> 00:27:31,803
It is possible to specify some parameters

515
00:27:32,003 --> 00:27:35,997
the saved layer will be added...

516
00:27:36,197 --> 00:27:39,620
ah, it asks to specify
the projection system used,

517
00:27:39,820 --> 00:27:41,904
UTM South 40.

518
00:27:42,104 --> 00:27:44,776
This new layer can be hidden.

519
00:27:44,976 --> 00:27:47,355
And as a second step we will save

520
00:27:47,555 --> 00:27:50,757
simply the attributes of the layer,

521
00:27:50,957 --> 00:27:51,818
so without the geometry,

522
00:27:52,018 --> 00:27:55,280
in the form of an ASCII file

523
00:27:55,480 --> 00:27:56,964
a .csv text file,

524
00:27:57,164 --> 00:28:01,363
so a text file with values ​​
separated by commas.

525
00:28:04,869 --> 00:28:10,916
Similarly, the table will be added
to the list of available objects.

526
00:28:11,116 --> 00:28:15,210
If we go now to a database
management software.

527
00:28:15,410 --> 00:28:18,506
It is SQLite Studio.

528
00:28:18,706 --> 00:28:20,804
We can import.

529
00:28:21,004 --> 00:28:23,377
We will start by creating a database

530
00:28:23,577 --> 00:28:26,496
in which we will import the text file.

531
00:28:26,696 --> 00:28:30,218
So we will call this database "mahe_data".

532
00:28:32,210 --> 00:28:34,638
This database once created

533
00:28:34,838 --> 00:28:39,559
we will start by connecting to this database

534
00:28:39,759 --> 00:28:43,162
and we can see that it can
contain tables and views

535
00:28:43,362 --> 00:28:44,742
which are in fact query results

536
00:28:46,583 --> 00:28:47,802
made a little permanent.

537
00:28:48,002 --> 00:28:52,187
In the tables, we will import data
in a new table

538
00:28:52,387 --> 00:28:55,776
we will create this new table
that will be called "district"

539
00:28:55,976 --> 00:28:58,296
and import the text file

540
00:28:58,496 --> 00:29:01,832
which contains the attributes
of these districts

541
00:29:02,032 --> 00:29:03,869
which we previously saved.

542
00:29:05,203 --> 00:29:09,648
The first line is said
to represent column headers

543
00:29:09,848 --> 00:29:12,782
and we see that this table
now appears in the tree,

544
00:29:12,982 --> 00:29:15,248
this district table that contains
a number of columns

545
00:29:15,433 --> 00:29:20,236
which are the different fields
that we had in the QGIS district layer.

546
00:29:21,801 --> 00:29:24,621
We can consult the data themselves

547
00:29:26,584 --> 00:29:31,038
and modify the data structure if necessary.

548
00:29:33,067 --> 00:29:35,488
In a second step, we will
add another database

549
00:29:35,688 --> 00:29:40,168
which is actually
the backed-up QGIS database

550
00:29:40,368 --> 00:29:42,508
with the elements of geometry

551
00:29:42,708 --> 00:29:45,351
and we see that if we
connect to this database

552
00:29:45,551 --> 00:29:47,853
we have a much larger number of objects

553
00:29:48,053 --> 00:29:53,074
since in fact, to manage
the geometric dimension

554
00:29:53,274 --> 00:29:55,930
the SQLite database

555
00:29:56,130 --> 00:29:59,488
generates a whole bunch of objects

556
00:29:59,688 --> 00:30:01,630
which are necessary

557
00:30:03,703 --> 00:30:06,538
and which make the thing
a little more complex

558
00:30:06,738 --> 00:30:07,777
when we approach it like that from afar.

559
00:30:07,977 --> 00:30:11,421
But we also find the data table
of the districts of Mahé

560
00:30:11,621 --> 00:30:13,356
with the same columns, the same values

561
00:30:13,556 --> 00:30:15,327
which can be consulted
in the form of a table.

562
00:30:15,527 --> 00:30:19,537
There is no index yet

563
00:30:19,737 --> 00:30:22,069
but triggers

564
00:30:22,269 --> 00:30:24,199
which are in fact the rules

565
00:30:24,399 --> 00:30:26,607
that the database management system

566
00:30:26,807 --> 00:30:30,175
must check during each transaction.

567
00:30:30,375 --> 00:30:32,859
So we can define the validation rules

568
00:30:33,059 --> 00:30:34,632
case by case.

569
00:30:34,832 --> 00:30:40,243
That is it for this introduction to
database management system softwares

570
00:30:40,443 --> 00:30:44,246
that we will see in more details
in other lessons of the course.

