1
00:00:22,934 --> 00:00:24,205
Bienvenue dans ce cours 

2
00:00:24,405 --> 00:00:26,985
qui va porter sur les bases
de données relationnelles

3
00:00:27,185 --> 00:00:31,563
qui sont la forme la plus largement
répandue de base de données

4
00:00:31,763 --> 00:00:34,797
et que l'on retrouve dans absolument
tous les domaines de la vie courante.

5
00:00:34,997 --> 00:00:37,358
Les objectifs de cette leçon

6
00:00:37,558 --> 00:00:40,256
consistent donc
à découvrir les bases de données

7
00:00:40,456 --> 00:00:42,443
en particulier les bases
de données relationnelles

8
00:00:42,643 --> 00:00:44,937
et la manière
dont la dimension spatiale

9
00:00:45,137 --> 00:00:46,466
est intégrée
dans ces bases de données.

10
00:00:46,666 --> 00:00:48,550
Au terme de cette leçon

11
00:00:48,750 --> 00:00:51,491
vous devriez être capables
de décrire

12
00:00:51,691 --> 00:00:55,307
les concepts qui fondent
les bases de données relationnelles

13
00:00:55,507 --> 00:00:58,270
ainsi que les divers types d'objets
qu'elles contiennent.

14
00:00:59,782 --> 00:01:00,687
Dans la leçon précédente

15
00:01:00,887 --> 00:01:03,773
nous avons vu plusieurs formes
de stockage de données

16
00:01:03,973 --> 00:01:05,073
sous forme de fichiers simples

17
00:01:05,273 --> 00:01:06,692
ou de fichiers semi-structurés.

18
00:01:06,892 --> 00:01:09,969
Aujourd'hui, nous allons
passer en revue la suite

19
00:01:10,169 --> 00:01:12,613
des possibilités
de stockage de données

20
00:01:12,813 --> 00:01:14,488
à savoir les bases de données

21
00:01:14,688 --> 00:01:17,410
qui permettent
un stockage plus structuré

22
00:01:17,610 --> 00:01:20,470
et la plupart du temps
un stockage centralisé

23
00:01:20,670 --> 00:01:22,305
dans une architecture
client-serveur.

24
00:01:22,505 --> 00:01:23,567
Dans cette leçon

25
00:01:23,767 --> 00:01:27,045
nous allons aborder la question
de la définition d'une base de données

26
00:01:27,245 --> 00:01:30,121
les notions de fiabilité
de ces bases de données.

27
00:01:30,321 --> 00:01:34,034
Nous ferons
un bref survol historique

28
00:01:34,252 --> 00:01:37,177
de l'évolution des différents types
de base de données.

29
00:01:37,377 --> 00:01:40,938
Nous nous concentrerons
sur le modèle relationnel

30
00:01:41,138 --> 00:01:42,686
que nous verrons assez en détail.

31
00:01:42,886 --> 00:01:45,978
Nous parlerons ensuite de la manière

32
00:01:46,178 --> 00:01:48,655
dont la composante spatiale
est gérée

33
00:01:48,855 --> 00:01:50,360
dans ces bases de données.

34
00:01:50,560 --> 00:01:53,207
Et pour finir, un premier bref aperçu

35
00:01:53,407 --> 00:01:55,297
des logiciels SGBD,

36
00:01:55,497 --> 00:01:58,029
donc des logiciels Système de Gestion
de Bases de Données,

37
00:01:58,229 --> 00:02:01,366
que nous verrons aussi
à plusieurs reprises

38
00:02:01,566 --> 00:02:02,519
dans les cours suivants.

39
00:02:08,715 --> 00:02:10,707
Une base de données peut être
définie

40
00:02:10,907 --> 00:02:12,450
comme une collection
de données persistantes

41
00:02:12,650 --> 00:02:14,707
éventuellement centralisée

42
00:02:14,907 --> 00:02:16,933
utilisée par 
plusieurs applications

43
00:02:17,133 --> 00:02:19,087
et par plusieurs groupes
d'utilisateurs

44
00:02:19,287 --> 00:02:20,993
qui peuvent éventuellement
travailler en parallèle.

45
00:02:21,193 --> 00:02:24,299
On voit que avec cette définition
très générale

46
00:02:24,499 --> 00:02:27,453
les fichiers d'hébergement
de données

47
00:02:27,653 --> 00:02:29,284
que nous avons vu
lors de la précédente leçon

48
00:02:29,484 --> 00:02:31,757
peuvent aussi être considérés
comme des bases de données

49
00:02:31,957 --> 00:02:34,892
dans la mesure où elles offrent
une certaines persistance

50
00:02:35,092 --> 00:02:36,622
au stockage d'information.

51
00:02:36,822 --> 00:02:39,047
Les systèmes de gestion 
de bases de données

52
00:02:39,247 --> 00:02:40,648
sont par contre des logiciels

53
00:02:40,848 --> 00:02:44,284
qui permettent de créer,
de structurer, de documenter,

54
00:02:44,484 --> 00:02:45,652
de consulter les bases de données.

55
00:02:45,852 --> 00:02:49,038
Il s'agit en fait de l'interface
qui existe entre

56
00:02:49,238 --> 00:02:51,026
la base de données
et les utilisateurs

57
00:02:51,226 --> 00:02:53,299
ou les applications
qui utilisent les bases de données.

58
00:02:53,499 --> 00:02:55,727
Comme le montre cette image

59
00:02:55,927 --> 00:02:58,182
il en existe un très grand nombre

60
00:02:58,382 --> 00:03:00,569
autant dans le domaine commercial

61
00:03:00,769 --> 00:03:02,307
que dans le domaine du logiciel libre.

62
00:03:03,565 --> 00:03:05,000
Les modifications
d'une base de données

63
00:03:05,200 --> 00:03:06,895
sont le fruit de transactions.

64
00:03:07,095 --> 00:03:10,035
Les transactions étant
une suite d'opérations

65
00:03:10,235 --> 00:03:13,104
qui font passer la base de données
d'un état initial

66
00:03:13,304 --> 00:03:14,493
à un état final.

67
00:03:14,693 --> 00:03:17,265
Pour qu'une base de données

68
00:03:17,465 --> 00:03:19,990
passe d'un état initial
intègre et cohérent

69
00:03:20,190 --> 00:03:22,547
à un état final intègre et cohérent,

70
00:03:22,747 --> 00:03:26,705
les transactions doivent respecter
un certain nombre de critères

71
00:03:26,905 --> 00:03:32,451
qui sont l'atomicité, la cohérence
l'isolation et la durabilité,

72
00:03:32,651 --> 00:03:36,509
critères que l'on résume souvent
sous le nom de "propriété ACID"

73
00:03:36,709 --> 00:03:39,388
et que nous allons voir
un peu plus en détail à présent.

74
00:03:41,633 --> 00:03:43,996
Le principe d'atomicité
stipule que la transaction

75
00:03:44,196 --> 00:03:45,803
se fait complètement ou pas du tout.

76
00:03:46,003 --> 00:03:49,598
Dans le cas ici d'une transaction
qui comprend deux opérations,

77
00:03:49,798 --> 00:03:52,725
la première consistant
à retrancher 10 à un ensemble A

78
00:03:52,925 --> 00:03:55,802
et la seconde
à ajouter 10 à un ensemble B,

79
00:03:56,002 --> 00:03:59,270
avec pour condition de validité
que A + B = 100,

80
00:03:59,470 --> 00:04:02,218
on voit que l'opération se fait
en deux étapes

81
00:04:02,418 --> 00:04:04,770
pour arriver à un résultat

82
00:04:04,970 --> 00:04:07,442
qui est ensuite enregistré
dans la base de données

83
00:04:07,642 --> 00:04:09,927
par une opération
qui s'appelle un commit,

84
00:04:10,127 --> 00:04:11,868
une opération de validation.

85
00:04:12,068 --> 00:04:15,795
Il peut arriver
que l'une des ces opérations échoue

86
00:04:15,995 --> 00:04:18,604
et dans ce cas-là
le principe d'atomicité

87
00:04:18,804 --> 00:04:21,527
veut que la première opération
de la transaction

88
00:04:21,727 --> 00:04:25,327
puisse être reversible et annulée

89
00:04:25,527 --> 00:04:28,737
donc qu'on puisse retourner en fait
à l'état initial de la base de données.

90
00:04:28,937 --> 00:04:32,815
Les bases de données doivent vérifier
des principes de cohérence.

91
00:04:33,015 --> 00:04:36,516
Si nous avons ici
l'exemple d'une transaction

92
00:04:36,716 --> 00:04:39,181
qui consiste à retrancher 5
d'un ensemble A

93
00:04:39,381 --> 00:04:41,438
et ajouter 10 à un ensemble B

94
00:04:41,638 --> 00:04:44,615
avec une condition
de validité A + B = 100

95
00:04:44,815 --> 00:04:45,599
comme tout à l'heure,

96
00:04:45,799 --> 00:04:48,426
on voit bien
qu'au terme de la transaction

97
00:04:48,626 --> 00:04:52,477
le résultat ne respecte plus
la condition de validité

98
00:04:52,677 --> 00:04:56,930
si bien que la validation
doit être empêchée

99
00:04:57,130 --> 00:04:59,405
et l'opération
dans son ensemble annulée.

100
00:04:59,605 --> 00:05:01,399
Le principe d'isolation.

101
00:05:01,599 --> 00:05:04,448
On a ici le cas de deux transactions

102
00:05:04,648 --> 00:05:07,926
la première consistant
à retrancher 10 d'un ensemble A

103
00:05:08,126 --> 00:05:09,357
et rajouter 10 à un ensemble B

104
00:05:09,557 --> 00:05:11,666
avec toujours la même condition
de validité

105
00:05:11,866 --> 00:05:13,760
et une deuxième transaction

106
00:05:13,960 --> 00:05:15,630
qui fait à peu près
la même opération.

107
00:05:15,830 --> 00:05:19,188
On retranche 5 de l'ensemble B

108
00:05:19,388 --> 00:05:20,842
et on ajoute 5 à l'ensemble A.

109
00:05:21,042 --> 00:05:23,333
Et en fait le principe d'isolation

110
00:05:23,533 --> 00:05:28,090
veut que l'exécution
de ces transactions l'une après l'autre

111
00:05:28,290 --> 00:05:29,368
donne le même résultat

112
00:05:29,568 --> 00:05:32,080
que si les transactions
sont exécutées en même temps

113
00:05:32,280 --> 00:05:33,082
c'est-à-dire en série.

114
00:05:34,045 --> 00:05:37,383
On voit que si l'une 
de ces opérations échoue,

115
00:05:37,583 --> 00:05:38,963
la dernière par exemple,

116
00:05:39,163 --> 00:05:44,122
il faut s'assurer
que le principe d'annulation

117
00:05:44,322 --> 00:05:47,064
nous ramène la base de données
dans un état valide

118
00:05:47,264 --> 00:05:50,208
ce qui est le cas
dans le cas séquentiel.

119
00:05:50,408 --> 00:05:53,137
Mais par contre
lorsque les opérations se font en série

120
00:05:53,337 --> 00:05:57,163
on voit qu'il faut
qu'une procédure spéciale

121
00:05:57,363 --> 00:06:00,325
soit mise en place au niveau du système
de gestion de bases de données

122
00:06:00,525 --> 00:06:02,917
pour s'assurer de l'exécution en série

123
00:06:03,117 --> 00:06:04,087
en cas de pépin

124
00:06:04,287 --> 00:06:06,902
pour remettre la base
dans un état valide et cohérent.

125
00:06:07,102 --> 00:06:09,167
Finalement
le principe de durabilité

126
00:06:09,367 --> 00:06:12,039
stipule que l'enregistrement
en mémoire de la transaction

127
00:06:12,239 --> 00:06:13,788
au moment de la validation

128
00:06:13,988 --> 00:06:16,636
ne puisse pas être empêché

129
00:06:16,836 --> 00:06:19,233
ou interrompu
par un événement extérieur.

130
00:06:19,433 --> 00:06:22,081
Par exemple, une coupure de courant

131
00:06:22,281 --> 00:06:24,749
un tremblement de terre
ou que sais-je.

132
00:06:24,949 --> 00:06:27,509
Cela signifie techniquement en fait

133
00:06:27,709 --> 00:06:30,726
qu'il faut éviter de passer
par une mémoire tampon

134
00:06:30,926 --> 00:06:33,333
qui pourrait s'effacer
en cas de coupure de courant

135
00:06:33,533 --> 00:06:35,323
avant la validation proprement dite.

136
00:06:37,826 --> 00:06:39,428
En résumé, les principes ACID

137
00:06:39,628 --> 00:06:41,365
stipulent donc pour l'atomicité

138
00:06:41,565 --> 00:06:45,426
qu'une transaction doit être effectuée
complètement ou pas du tout,

139
00:06:45,626 --> 00:06:47,713
pour la cohérence

140
00:06:47,913 --> 00:06:50,026
que l'on va vérifier
au niveau de la base de données,

141
00:06:50,226 --> 00:06:52,515
les conditions de validité,

142
00:06:52,715 --> 00:06:54,412
le principe d'isolation,

143
00:06:54,612 --> 00:06:56,928
qu'une exécution en série

144
00:06:57,128 --> 00:06:59,768
donne le même résultat
qu'une exécution séquentielle

145
00:06:59,968 --> 00:07:02,308
des différentes opérations
d'une transaction.

146
00:07:02,508 --> 00:07:04,795
Et finalement
le principe de durabilité

147
00:07:04,995 --> 00:07:07,844
stipule que des incidents externes,

148
00:07:08,044 --> 00:07:09,349
coupure de courant ou autre,

149
00:07:09,549 --> 00:07:13,631
n'affectent pas la manière
dont l'information est stockée et validée

150
00:07:13,831 --> 00:07:15,002
dans la base de données.

151
00:07:24,484 --> 00:07:27,372
Nous passons donc maintenant
à la typologie historique des bases de données.

152
00:07:28,447 --> 00:07:30,302
Dès les années 50 et 60

153
00:07:30,502 --> 00:07:33,106
s'est développé
le stockage sous forme de fichiers,

154
00:07:33,306 --> 00:07:36,897
dont nous avons vu quelques exemples
lors de la leçon précédente,

155
00:07:37,097 --> 00:07:40,761
puis à partir des années 60-70

156
00:07:40,961 --> 00:07:42,194
se sont développées
dans un premier temps 

157
00:07:42,394 --> 00:07:43,419
les bases de données hiérarchiques.

158
00:07:43,619 --> 00:07:45,831
Les enregistrements
sont associés par des relations

159
00:07:46,031 --> 00:07:47,596
selon une arborescence descendante.

160
00:07:47,796 --> 00:07:50,347
Chaque élément a un
et un seul parent.

161
00:07:50,547 --> 00:07:52,741
Dans les domaines d'application,

162
00:07:52,941 --> 00:07:55,391
les structures d'organisation,
les systèmes de fichier,

163
00:07:55,591 --> 00:07:58,054
les systèmes taxonomiques, etc.

164
00:07:58,254 --> 00:08:01,022
Par la suite
les bases de données réseaux

165
00:08:01,222 --> 00:08:03,771
qui sont une variante des bases
de données hiérarchiques

166
00:08:03,971 --> 00:08:07,936
avec simplement une multiplicité
des parents possibles

167
00:08:08,136 --> 00:08:10,293
dont l'arborescence n'est plus 
strictement descendante.

168
00:08:10,493 --> 00:08:12,717
Il peut y avoir des structures
cycliques.

169
00:08:12,917 --> 00:08:15,047
A partir des années 70-80

170
00:08:15,247 --> 00:08:16,712
les bases de données relationnelles

171
00:08:16,912 --> 00:08:20,663
qui proposent
sur le principe d'enregistrement

172
00:08:20,863 --> 00:08:22,928
hébergé dans des tables
à deux dimensions.

173
00:08:23,128 --> 00:08:25,284
Une relation étant une dalle,

174
00:08:25,484 --> 00:08:28,070
un attribut se trouvant
dans une colonne ou un champ

175
00:08:28,270 --> 00:08:29,033
et l'objet dans les lignes.

176
00:08:29,233 --> 00:08:31,339
Et à partir des années 90

177
00:08:31,539 --> 00:08:32,553
les bases de données objets

178
00:08:32,753 --> 00:08:34,157
et les bases de données
semi-structurées

179
00:08:34,357 --> 00:08:37,208
dans lesquelles
les données sont stockées

180
00:08:37,408 --> 00:08:38,955
sous forme d'objets
qui peuvent avoir

181
00:08:39,155 --> 00:08:41,865
des structures spécifiques
et variables

182
00:08:42,065 --> 00:08:44,692
et de différents types.

183
00:08:44,892 --> 00:08:46,604
Nous parlerons dans cette leçon
plus précisément

184
00:08:46,804 --> 00:08:48,083
des bases de données relationnelles

185
00:08:48,283 --> 00:08:50,844
et le thème des bases
de données objets

186
00:08:51,044 --> 00:08:54,048
sera quant à lui abordé
plus spécifiquement

187
00:08:54,248 --> 00:08:55,447
dans un cours ultérieur.

188
00:09:05,837 --> 00:09:08,119
Le modèle relationnel
a donc été développé

189
00:09:08,319 --> 00:09:12,225
essentiellement pour répondre
aux principes ACID

190
00:09:12,425 --> 00:09:15,374
dans les transactions qui permettent
de modifier une base de données,

191
00:09:15,574 --> 00:09:19,326
de s'assurer d'avoir une bonne
cohérence de l'information,

192
00:09:19,526 --> 00:09:22,033
d'éviter la redondance
des informations.

193
00:09:22,233 --> 00:09:26,146
C'est un modèle qui est fondé
sur des bases théoriques solides

194
00:09:26,346 --> 00:09:29,228
puisque cela s'appuie
sur la théorie des ensembles

195
00:09:29,428 --> 00:09:31,480
dont est tiré l'algèbre relationnel.

196
00:09:31,680 --> 00:09:35,284
C'est un modèle qui a été
très largement utilisé

197
00:09:35,484 --> 00:09:37,771
par tous les grands acteurs
du domaine des bases de données.

198
00:09:37,971 --> 00:09:41,867
Aujourd'hui, on peut dire qu'environ 
80 à 90% des bases de données

199
00:09:42,067 --> 00:09:44,478
sont construites
sur le modèle relationnel.

200
00:09:44,678 --> 00:09:50,306
C'est quelque chose qui change
un petit peu avec le Big Data

201
00:09:50,506 --> 00:09:52,384
qui fait appel
à d'autres types de modèles.

202
00:09:52,584 --> 00:09:56,283
Mais le modèle relationnel reste
largement le plus important.

203
00:09:56,483 --> 00:09:58,729
C'est un modèle finalement 
qui a été développé

204
00:09:58,929 --> 00:10:00,386
à partir des années 70

205
00:10:00,586 --> 00:10:03,879
chez IBM par un ingénieur
du nom de Ted Codd.

206
00:10:04,079 --> 00:10:05,932
Dans le modèle relationnel

207
00:10:06,132 --> 00:10:08,238
les données sont donc organisées
sous forme de tables

208
00:10:08,438 --> 00:10:09,941
également appelées "relation".

209
00:10:10,141 --> 00:10:12,103
Une relation est constituée
de colonnes

210
00:10:12,303 --> 00:10:12,852
ou d'attributs

211
00:10:13,052 --> 00:10:15,263
caractérisés par un nom et un domaine,

212
00:10:15,463 --> 00:10:18,224
un domaine étant
un ensemble de valeurs,

213
00:10:18,424 --> 00:10:21,244
par exemple
le domaine des valeurs entières,

214
00:10:21,444 --> 00:10:22,762
les domaines des booléens,

215
00:10:22,962 --> 00:10:27,623
le domaine
des disciplines sportives, etc.

216
00:10:27,823 --> 00:10:30,833
Dans une table, chaque ligne
correspond à un enregistrement

217
00:10:31,033 --> 00:10:32,215
également appelé "tuple".

218
00:10:32,415 --> 00:10:36,173
Pour un tuple
il peut arriver qu'un attribut

219
00:10:36,373 --> 00:10:37,411
ne soit pas valué,

220
00:10:37,611 --> 00:10:38,457
donc qu'il n'ait pas de valeur

221
00:10:38,692 --> 00:10:44,015
et dans ce cas-là, on indique ce fait
par la valeur NULL.

222
00:10:44,215 --> 00:10:47,856
Un ensemble ne peut contenir
deux fois le même objet

223
00:10:48,056 --> 00:10:50,822
et c'est pour cette raison
que dans le modèle relationnel

224
00:10:51,022 --> 00:10:52,318
on doit absolument s'assurer

225
00:10:52,518 --> 00:10:54,266
que chaque objet est unique.

226
00:10:54,466 --> 00:10:59,323
La meilleure façon de s'assurer
que cet objet est unique

227
00:10:59,523 --> 00:11:04,048
c'est de définir un identifiant
spécifiquement pour les besoins

228
00:11:04,248 --> 00:11:07,517
comme dans le cas de la première table
que l'on voit ici

229
00:11:07,717 --> 00:11:11,200
où on a créé un numéro d'étudiant

230
00:11:11,400 --> 00:11:13,909
qui permet d'identifier
sans ambiguïté

231
00:11:14,109 --> 00:11:16,754
chaque étudiant.

232
00:11:18,279 --> 00:11:21,536
Cet identifiant, également parfois
appelé "clé primaire",

233
00:11:21,736 --> 00:11:25,091
peut être fabriqué
pour les besoins de la cause

234
00:11:25,291 --> 00:11:27,282
mais peut aussi être construit

235
00:11:27,482 --> 00:11:29,435
à partir des attributs existants

236
00:11:29,635 --> 00:11:33,896
par exemple en associant
le nom et le prénom des étudiants.

237
00:11:34,096 --> 00:11:36,543
On voit bien que si on se
contente du nom et du prénom

238
00:11:36,743 --> 00:11:39,711
on peut être confronté
au problème des homonymes

239
00:11:39,911 --> 00:11:44,498
et avoir plusieurs personnes
qui ne pourraient pas être distinguées

240
00:11:44,698 --> 00:11:46,471
par cet identifiant.

241
00:11:46,671 --> 00:11:50,687
D'où la nécessité
d'étendre le concept

242
00:11:50,887 --> 00:11:53,068
et d'intégrer l'adresse,
le nom de la rue,

243
00:11:53,268 --> 00:11:54,738
le numéro postal, etc.

244
00:11:56,685 --> 00:11:59,817
En fait, l'identifiant pourrait être
constitué de l'ensemble

245
00:12:00,017 --> 00:12:02,191
des champs de la table

246
00:12:02,391 --> 00:12:06,830
avec évidemment, on imagine bien,
un certain nombre d'inconvénients

247
00:12:07,030 --> 00:12:11,720
lorsqu'il s'agit
d'indexer les objets

248
00:12:11,920 --> 00:12:14,527
pour pouvoir les retrouver
plus vite lors d'une recherche

249
00:12:14,727 --> 00:12:17,350
ou bien pouvoir faire des tris
et des choses comme ça.

250
00:12:17,550 --> 00:12:22,780
C'est pour cette raison que l'utilisation
d'un identifiant spécifique

251
00:12:22,980 --> 00:12:26,734
est le cas de figure largement
le plus souvent rencontré.

252
00:12:26,934 --> 00:12:30,562
Les identifiants externes,
également appelés "clés étrangères",

253
00:12:30,762 --> 00:12:34,037
décrivent des liens
entre différentes relations,

254
00:12:34,237 --> 00:12:38,519
par exemple, dans le cas
d'un cours suivi par des étudiants

255
00:12:38,719 --> 00:12:40,395
on a une table d'étudiants,
une table de cours,

256
00:12:40,595 --> 00:12:42,032
une table de professeurs

257
00:12:42,232 --> 00:12:45,760
et on voit qu'un cours
est donné par un professeur

258
00:12:45,960 --> 00:12:49,551
et que ce professeur en fait doit exister
dans la table des professeurs

259
00:12:49,751 --> 00:12:51,714
pour que la base de données
soit intègre.

260
00:12:51,914 --> 00:12:54,219
Dans la relation suivi de cours,

261
00:12:54,419 --> 00:12:57,889
qui associe un numéro d'étudiant
avec un titre de cours,

262
00:12:58,089 --> 00:13:00,913
donc la liste des cours suivis
par les étudiants

263
00:13:01,113 --> 00:13:03,052
ou la liste des étudiants
qui suivent un cours,

264
00:13:03,252 --> 00:13:07,402
on voit que le numéro d'étudiant
référence un étudiant

265
00:13:07,602 --> 00:13:08,671
de la relation étudiant

266
00:13:08,871 --> 00:13:12,778
et "titre cours" référence
un cours dans la table des cours.

267
00:13:14,500 --> 00:13:17,517
La référence doit pointer
sur un objet unique

268
00:13:17,717 --> 00:13:18,783
évidemment

269
00:13:18,983 --> 00:13:22,523
et il peut arriver
que cet objet soit NULL

270
00:13:22,723 --> 00:13:25,740
si l'attribut est facultatif,

271
00:13:25,940 --> 00:13:28,074
par exemple
dans le cas de la salle de cours

272
00:13:28,274 --> 00:13:30,499
qui pourrait ne pas avoir 
encore été attribuée

273
00:13:30,699 --> 00:13:34,293
au moment où on documente la table.

274
00:13:34,493 --> 00:13:37,716
L'intégrité référentielle
de la base de données

275
00:13:37,977 --> 00:13:39,555
est en principe vérifié
automatiquement

276
00:13:39,755 --> 00:13:41,399
par le système de gestion
de bases de données.

277
00:13:41,599 --> 00:13:44,162
Si par exemple
un utilisateur veut assurer

278
00:13:44,362 --> 00:13:46,958
un nouveau cours de géologie
dans la table

279
00:13:47,158 --> 00:13:49,107
des cours suivis par les étudiants

280
00:13:49,307 --> 00:13:51,539
et que ce cours n'existe pas
dans la table cours,

281
00:13:51,739 --> 00:13:53,587
la transaction sera refusée.

282
00:13:53,787 --> 00:13:57,274
De même, si un utilisateur
veut changer le nom d'un cours

283
00:13:57,474 --> 00:14:00,663
et que ce nom n'existe pas
dans la table de référence,

284
00:14:00,863 --> 00:14:02,395
la transaction sera également
refusée.

285
00:14:04,725 --> 00:14:07,531
De même, si un utilisateur
veut supprimer un cours

286
00:14:07,731 --> 00:14:10,259
qui est référencé
par d'autres relations,

287
00:14:10,459 --> 00:14:12,008
l'opération peut être refusée.

288
00:14:12,208 --> 00:14:16,068
On peut supprimer les références
dans l'autre relation

289
00:14:16,268 --> 00:14:20,673
ou alternativement
annuler ces références.

290
00:14:22,638 --> 00:14:26,372
Pareillement, si un utilisateur
veut modifier le nom d'un cours

291
00:14:26,572 --> 00:14:28,716
dans une table et que ce nom
est référencé ailleurs

292
00:14:28,916 --> 00:14:30,406
on peut refuser l'opération

293
00:14:30,606 --> 00:14:32,956
ou mettre à jour
l'autre table également.

294
00:14:36,224 --> 00:14:38,089
Le modèle relationnel
ne se prête pas 

295
00:14:38,289 --> 00:14:40,963
à un enregistrement d'attributs
multivalués,

296
00:14:41,163 --> 00:14:44,757
donc qui ont plusieurs valeurs
ou d'attributs complexes,

297
00:14:44,957 --> 00:14:46,719
donc composés de plusieurs éléments.

298
00:14:46,919 --> 00:14:51,309
Il est de ce fait nécessaire
de les modéliser autrement.

299
00:14:51,509 --> 00:14:55,736
Dans le cas d'un attribut
monovalué complexe,

300
00:14:55,936 --> 00:14:58,440
comme par exemple une adresse

301
00:14:58,640 --> 00:15:00,886
qui est composée d'une rue,
d'un numéro dans la rue,

302
00:15:01,086 --> 00:15:02,583
d'un numéro postal, d'une localité,

303
00:15:02,783 --> 00:15:08,729
une possibilité consiste à définir
un attribut, un champ par composant,

304
00:15:08,929 --> 00:15:14,024
comme illustré par la table
qui se trouve ici à droite,

305
00:15:14,224 --> 00:15:17,438
et par la suite de construire
dans la base de données

306
00:15:17,638 --> 00:15:21,008
une vue, qui est une table virtuelle

307
00:15:21,208 --> 00:15:24,260
contenant en fait l'agrégation
de ces différents champs

308
00:15:24,460 --> 00:15:26,834
pour restituer l'idée d'adresse.

309
00:15:27,034 --> 00:15:31,776
L'autre possibilité consiste
à créer un attribut "adresse globale"

310
00:15:31,976 --> 00:15:34,079
qui serait de type
chaîne de caractère

311
00:15:34,279 --> 00:15:37,019
dans lequel on va enregistrer
l'ensemble de l'adresse,

312
00:15:37,219 --> 00:15:40,406
chemin, numéro
numéro postal, localité.

313
00:15:40,606 --> 00:15:44,095
On voit que dans ces relations

314
00:15:44,295 --> 00:15:48,675
le numéro d'étudiant est un identifiant
de la relation étudiant.

315
00:15:48,875 --> 00:15:50,986
Pour un attribut multivalué,

316
00:15:51,186 --> 00:15:53,867
comme par exemple le cas
de prénoms multiples,

317
00:15:54,067 --> 00:15:59,450
une possibilité serait de définir
plusieurs attributs

318
00:15:59,650 --> 00:16:01,472
pour chaque prénom,

319
00:16:01,672 --> 00:16:02,947
prénom 1, prénom 2, etc.

320
00:16:03,147 --> 00:16:06,105
C'est un mauvais choix
parce qu'en fait

321
00:16:06,305 --> 00:16:09,009
on ne sait pas combien de prénoms
il faut prévoir,

322
00:16:09,209 --> 00:16:13,581
si c'est pas des prénoms
ça peut être un autre type d'attribut

323
00:16:13,781 --> 00:16:17,689
qui pourrait avoir une succession
innombrable d'éléments

324
00:16:17,889 --> 00:16:21,131
donc on voit bien
que ça ne fonctionne pas très bien.

325
00:16:21,331 --> 00:16:25,413
D'autant plus que cela conduit
à définir beaucoup de champs

326
00:16:25,613 --> 00:16:27,324
qui seront remplis de valeurs nulles.

327
00:16:27,524 --> 00:16:29,990
C'est pas quelque chose
qui est très optimal

328
00:16:30,190 --> 00:16:31,014
du point de vue base de données.

329
00:16:31,214 --> 00:16:37,235
Une solution alternative consiste
à créer une table supplémentaire

330
00:16:37,435 --> 00:16:40,163
dans laquelle vont être hébergé
les prénoms

331
00:16:40,363 --> 00:16:45,077
en relation avec l'identifiant
des étudiants

332
00:16:45,277 --> 00:16:47,711
auxquels ces prénoms se rattachent

333
00:16:47,911 --> 00:16:51,609
et donc on voit
que le champ "numéro étudiant",

334
00:16:51,809 --> 00:16:53,972
qui est une clé primaire
de la table étudiant,

335
00:16:54,172 --> 00:16:57,172
devient une clé étrangère

336
00:16:57,372 --> 00:16:58,778
de la table "étude prénom".

337
00:16:58,978 --> 00:17:01,974
Une autre possibilité
un peu plus subtile

338
00:17:02,174 --> 00:17:05,236
consiste à intégrer
dans la table "étude prénom"

339
00:17:05,436 --> 00:17:07,444
le numéro du prénom 

340
00:17:07,644 --> 00:17:09,829
de sorte à pouvoir restituer
l'ordre dans lequel

341
00:17:10,029 --> 00:17:12,513
les prénoms apparaissent,

342
00:17:12,713 --> 00:17:14,911
premier prénom, second prénom, etc.

343
00:17:15,111 --> 00:17:19,077
Dans ce cas également, le numéro
d'étudiant est une clé primaire

344
00:17:19,277 --> 00:17:20,239
pour la table "étudiant"

345
00:17:20,439 --> 00:17:23,383
et une clé étrangère
pour la table "étude prénom"

346
00:17:23,583 --> 00:17:26,498
qui elle n'a pas de clé primaire.

347
00:17:26,698 --> 00:17:28,881
Nous avons donc passé en revue

348
00:17:29,081 --> 00:17:32,788
les principales notions de base
du modèle relationnel

349
00:17:32,988 --> 00:17:35,323
à savoir le domaine de valeurs

350
00:17:35,523 --> 00:17:37,720
l'attribut, la relation, le tuple

351
00:17:37,920 --> 00:17:39,843
l'identifiant, l'identifiant externe.

352
00:17:40,043 --> 00:17:42,700
Il nous reste encore à évoquer 

353
00:17:42,900 --> 00:17:46,175
les différents opérateurs
de l'algèbre relationnel

354
00:17:46,457 --> 00:17:48,233
qui fondent les opérations 

355
00:17:48,433 --> 00:17:51,010
que l'on va pouvoir
par la suite faire sur ces tables,

356
00:17:51,210 --> 00:17:54,887
opérations que nous verrons
de manière assez détaillée

357
00:17:55,087 --> 00:17:57,955
dans la deuxième semaine
de ce module

358
00:17:58,155 --> 00:18:01,972
avec tout ce qui est requête,
langage SQL, etc.

359
00:18:03,757 --> 00:18:07,561
Ces opérateurs sont en premier lieu
l'opérateur d'unions,

360
00:18:07,761 --> 00:18:10,503
donc on est dans
une logique ensembliste.

361
00:18:10,703 --> 00:18:15,905
Pour l'exemple, on prend ici
une série de photographies

362
00:18:16,105 --> 00:18:19,961
qui ont été réalisées par un auteur,
une certaine année,

363
00:18:20,161 --> 00:18:20,912
dans une certaine ville,

364
00:18:21,112 --> 00:18:23,819
et on voit que l'union
de deux tables

365
00:18:24,019 --> 00:18:30,806
consiste en fait à agréger
ces deux tables

366
00:18:31,006 --> 00:18:32,294
en une seule.

367
00:18:34,784 --> 00:18:37,169
La différence entre deux tables

368
00:18:37,369 --> 00:18:40,379
est la soustraction
de la seconde à la première

369
00:18:40,579 --> 00:18:47,837
donc l'élimination des objets
redondants de la première.

370
00:18:50,134 --> 00:18:53,392
Cette opération
n'est pas commutative,

371
00:18:53,592 --> 00:18:56,528
si on la fait dans l'autre sens
le résultat va être différent.

372
00:18:57,753 --> 00:19:00,148
Nous avons ensuite le produit croisé

373
00:19:00,348 --> 00:19:05,271
qui consiste à associer
chaque élément

374
00:19:05,471 --> 00:19:06,105
chaque tuple

375
00:19:06,305 --> 00:19:09,832
de la première table
à chaque tuple de la seconde.

376
00:19:10,032 --> 00:19:14,169
Donc ici, les version couleurs
et noir / blanc des photos qui...

377
00:19:14,369 --> 00:19:18,025
nous avons donc 2 fois 3, 6 photos.

378
00:19:18,225 --> 00:19:22,322
Et puis les opérations de sélection
sur une table,

379
00:19:22,522 --> 00:19:29,509
sélection qui consiste à identifier, 
à extraire un certain nombre d'éléments.

380
00:19:29,709 --> 00:19:34,079
Des opérations de projection
qui consistent à extraire

381
00:19:34,279 --> 00:19:37,695
un certain nombre d'attributs
pour l'ensemble de la table.

382
00:19:37,895 --> 00:19:42,317
Ce qui dans le cas précis débouche
sur quelque chose qui n'a pas grand sens,

383
00:19:42,517 --> 00:19:46,133
en tout cas qui est contraire
aux principes de la théorie des ensembles

384
00:19:46,333 --> 00:19:48,704
puisqu'on a des objets identiques.

385
00:19:48,904 --> 00:19:51,724
Donc c'est une opération
qui ne serait pas valide.

386
00:19:53,924 --> 00:19:55,779
Et finalement
les opérations de jointure

387
00:19:55,979 --> 00:19:58,555
qui consistent à associer
deux tables

388
00:19:58,755 --> 00:20:02,247
par l'intermédiaire d'un champ
qui leur serait commun.

389
00:20:02,447 --> 00:20:05,800
Ici, la table des photographies
couleurs

390
00:20:06,000 --> 00:20:09,041
avec une table qui associerait
villes et pays.

391
00:20:09,241 --> 00:20:12,819
Le champ commun étant évidemment
la ville.

392
00:20:13,019 --> 00:20:19,462
Ces opérations de jointure
peuvent être assorties d'une condition,

393
00:20:19,662 --> 00:20:24,442
donc on pourrait ne garder
que les éléments jointifs

394
00:20:24,642 --> 00:20:26,754
qui ont pour pays le Sénégal

395
00:20:26,954 --> 00:20:29,418
et donc une seule photographie

396
00:20:29,618 --> 00:20:33,366
sur les trois qui étaient comprises
dans la jointure de départ.

397
00:20:44,511 --> 00:20:47,011
Nous en venons maintenant
aux spécificités

398
00:20:47,211 --> 00:20:50,431
des bases de données qui possèdent
une composante spatiale

399
00:20:50,631 --> 00:20:53,826
spécificités qui sont
au nombre de trois

400
00:20:54,026 --> 00:20:55,828
principalement.

401
00:20:56,028 --> 00:20:59,488
Tout d'abord, le type de données,

402
00:20:59,688 --> 00:21:03,409
donc les domaines concernant
ces types de données.

403
00:21:03,609 --> 00:21:09,961
On voit que dans la table
en haut à gauche,

404
00:21:10,161 --> 00:21:13,276
dans une base de données
traditionnelle on a

405
00:21:13,476 --> 00:21:16,165
un certain nombre de type
de données bien défini,

406
00:21:16,365 --> 00:21:18,002
varchar pour le texte,

407
00:21:18,202 --> 00:21:19,920
les entiers pour le numérique,

408
00:21:20,120 --> 00:21:22,726
le réel également
pour les nombres et les dates.

409
00:21:22,926 --> 00:21:25,195
Dans la base de données spatiale

410
00:21:25,395 --> 00:21:27,199
on ajoute de nouveaux 
types de données,

411
00:21:27,399 --> 00:21:29,999
de type point, ligne, polygone, etc.

412
00:21:30,199 --> 00:21:32,222
Enfin, les géométries de base

413
00:21:32,422 --> 00:21:35,750
qui sont gérées par les systèmes
d'information géographique.

414
00:21:35,950 --> 00:21:39,120
Le second domaine important

415
00:21:39,320 --> 00:21:41,100
est celui de l'indexation,

416
00:21:41,300 --> 00:21:43,064
l'indexation des objets spatiaux

417
00:21:43,264 --> 00:21:46,072
pour pouvoir par la suite
effectuer des requêtes

418
00:21:46,272 --> 00:21:48,012
et retrouver rapidement les objets

419
00:21:48,212 --> 00:21:50,538
et finalement
un certain nombre de fonctions

420
00:21:50,738 --> 00:21:54,035
qui permettent d'effectuer
des opérations spécifiques

421
00:21:54,235 --> 00:21:55,364
sur les objets géométriques.

422
00:21:57,303 --> 00:22:01,141
Il existe plusieurs formes
d'indexation des données.

423
00:22:01,341 --> 00:22:04,622
Dans le domaine des bases
de données non-spatiales

424
00:22:04,822 --> 00:22:08,683
on utilise souvent une structure

425
00:22:08,883 --> 00:22:09,918
appelée B-tree,

426
00:22:10,118 --> 00:22:12,098
donc une arborescence hiérarchique

427
00:22:12,298 --> 00:22:15,847
qui permet en fait de retrouver
facilement les données.

428
00:22:16,047 --> 00:22:18,479
On a dans cette illustration

429
00:22:18,679 --> 00:22:20,657
un exemple d'un arbre d'ordre 5

430
00:22:20,857 --> 00:22:27,404
dans lequel un noeud peut avoir
au plus 4 clés et 5 enfants,

431
00:22:27,604 --> 00:22:30,493
chaque noeud ayant au moins
2 clés et 3 enfants.

432
00:22:32,011 --> 00:22:33,579
Cette idée d'arborescence
hiérarchique

433
00:22:33,779 --> 00:22:35,944
se retrouve dans le domaine
des bases de données spatiales

434
00:22:36,144 --> 00:22:39,752
sous la forme de R-tree

435
00:22:39,952 --> 00:22:42,630
dans lequel les objets
les plus proches

436
00:22:42,830 --> 00:22:46,460
sont regroupés et représentés
à l'échelle supérieure

437
00:22:46,660 --> 00:22:48,077
par une enveloppe minimale

438
00:22:48,277 --> 00:22:50,961
qui est le minimum
bounding rectangle.

439
00:22:51,161 --> 00:22:54,564
Et lorsque l'on fait ensuite
une requête pour retrouver des objets

440
00:22:54,764 --> 00:22:59,478
en fait si la requête n'intersecte pas
une enveloppe minimale

441
00:22:59,678 --> 00:23:01,798
on peut écarter
tous les objets de cette enveloppe

442
00:23:01,998 --> 00:23:05,260
et se concentrer sur ceux
qui restent en jeu.

443
00:23:05,460 --> 00:23:07,413
Dans l'illustration qui est ici

444
00:23:07,613 --> 00:23:08,903
on voit à gauche

445
00:23:09,103 --> 00:23:16,802
le lien entre une approche
hiérarchique non-spatiale

446
00:23:17,002 --> 00:23:19,025
et une approche hiérarchique
spatiale

447
00:23:19,225 --> 00:23:24,923
et puis à droite un exemple
de structuration d'index spatial

448
00:23:25,123 --> 00:23:30,003
qui concerne les bureaux
de poste en Allemagne.

449
00:23:30,203 --> 00:23:34,418
Le Quadtree est une autre méthode
d'indexation spatiale

450
00:23:34,618 --> 00:23:41,029
qui est pas mal utilisée dans les systèmes 
de tuilage de cartes géographiques

451
00:23:41,229 --> 00:23:42,649
type Google, etc.

452
00:23:42,849 --> 00:23:45,831
Il s'agit d'une structure
arborescente

453
00:23:46,031 --> 00:23:49,441
dans laquelle chaque noeud
possède exactement 4 enfants

454
00:23:49,641 --> 00:23:52,477
donc chaque zone géographique
est divisée en 4

455
00:23:52,677 --> 00:23:56,995
et à nouveau en 4 chaque fois que
l'on descend d'un niveau de zoom.

456
00:23:57,195 --> 00:24:03,367
Le mode d'indexation
en grille est similaire

457
00:24:03,567 --> 00:24:07,053
dans le sens qu'il s'agit aussi
d'une tessellation régulière

458
00:24:08,791 --> 00:24:12,996
simplement que la subdivision
de chaque entité

459
00:24:13,196 --> 00:24:15,066
ne se fait pas nécessairement en 4

460
00:24:15,266 --> 00:24:19,644
mais peut se faire en 9, en 16, etc.

461
00:24:19,844 --> 00:24:23,925
Parmi les fonctions spécifiques
aux bases de données spatiales

462
00:24:24,125 --> 00:24:28,470
on peut distinguer
trois familles principales.

463
00:24:28,670 --> 00:24:31,946
Tout d'abord
la famille des mesures spatiales

464
00:24:32,146 --> 00:24:35,419
qui donne des indications de longueur
de surface, de distance

465
00:24:35,619 --> 00:24:38,899
à propos des objets
géométriques.

466
00:24:39,099 --> 00:24:44,200
Des fonctions spatiales
qui créent de nouvelles entités,

467
00:24:44,400 --> 00:24:48,508
par exemple on peut imaginer
la création d'une zone tampon

468
00:24:48,708 --> 00:24:50,099
autour d'un objet géométrique.

469
00:24:50,299 --> 00:24:54,198
L'intersection de deux objets
qui crée un nouvel objet,

470
00:24:54,398 --> 00:24:56,174
l'union de deux objets, etc

471
00:24:57,997 --> 00:24:59,772
Et des opérateurs topologiques

472
00:24:59,972 --> 00:25:04,662
qui testent la véracité
de relations de voisinage.

473
00:25:04,862 --> 00:25:08,558
Est-ce que deux géométries
se chevauchent ?

474
00:25:08,795 --> 00:25:09,612
Est-ce qu'elles se touchent ? 

475
00:25:09,812 --> 00:25:11,896
Est-ce qu'elles sont contenues
l'une dans l'autre ?

476
00:25:12,096 --> 00:25:13,121
Ou vice versa, etc.

477
00:25:14,528 --> 00:25:16,695
Tous ces différents types de fonctions

478
00:25:16,895 --> 00:25:19,865
sont de plus en plus souvent
implémentés 

479
00:25:20,065 --> 00:25:22,968
dans les systèmes de gestion
de bases de données spatiales.

480
00:25:33,784 --> 00:25:35,152
Comme je l'ai dit
au début de ce cours,

481
00:25:35,352 --> 00:25:38,844
il existe un très grand nombre de systèmes
de gestion de bases de données

482
00:25:39,044 --> 00:25:41,789
consacrés au modèle relationnel

483
00:25:43,170 --> 00:25:46,536
non seulement il existe un très grand
nombre de bases de données

484
00:25:46,736 --> 00:25:49,852
mais ces bases de données
sont accessibles

485
00:25:50,052 --> 00:25:53,040
par l'intermédiaire
de toute une série de clients

486
00:25:53,240 --> 00:25:56,786
qui sont soit
des logiciels commerciaux

487
00:25:56,986 --> 00:25:58,795
soit des logiciels libres.

488
00:25:58,995 --> 00:26:02,997
Tous ces clients offrent en fait
un interface utilisateur

489
00:26:03,197 --> 00:26:06,992
et permettent d'entrer en contact
avec ces bases de données

490
00:26:07,192 --> 00:26:08,320
et de les manipuler.

491
00:26:08,520 --> 00:26:11,574
Parmi les fonctionnalités
que l'on souhaite trouver

492
00:26:11,774 --> 00:26:13,351
dans les systèmes de gestion
de bases de données,

493
00:26:13,551 --> 00:26:15,480
il en est en fait de trois types,

494
00:26:15,680 --> 00:26:19,809
tout d'abord celles qui permettent
de gérer la structure des données,

495
00:26:20,009 --> 00:26:22,399
donc de créer de nouveaux champs,
de nouveaux attributs

496
00:26:22,599 --> 00:26:23,912
avec leur domaine de valeur,

497
00:26:24,112 --> 00:26:28,750
de créer de nouveaux index,
clés primaires, clés externes, etc., 

498
00:26:28,950 --> 00:26:33,692
de consulter les données enregistrées
dans la base de données,

499
00:26:33,892 --> 00:26:36,180
de consulter les tables de valeur

500
00:26:36,380 --> 00:26:39,359
éventuellement de pouvoir importer
des données depuis l'extérieur

501
00:26:39,559 --> 00:26:41,855
pour peupler ces différentes tables

502
00:26:42,055 --> 00:26:44,322
et finalement
toutes les fonctionnalités

503
00:26:44,522 --> 00:26:48,268
qui sont liées à la construction
et à l'exécution de requêtes

504
00:26:48,468 --> 00:26:51,359
pour aller rechercher des objets
dans une base de données

505
00:26:51,559 --> 00:26:54,804
sur la base d'un certain nombre
de critères.

506
00:26:55,004 --> 00:26:57,326
C'est une chose que nous allons 
voir plus en détail

507
00:26:57,526 --> 00:27:04,107
en particulier dans les leçons
de la deuxième semaine de ce module.

508
00:27:04,307 --> 00:27:07,758
Dans l'immédiat, nous allons
prendre un petit exemple

509
00:27:07,958 --> 00:27:12,058
qui est celui
des districts des Seychelles

510
00:27:12,258 --> 00:27:17,059
que l'on peut exporter
dans un format base de données,

511
00:27:17,259 --> 00:27:19,086
en l'occurrence
une base de données SpatiaLite.

512
00:27:20,845 --> 00:27:24,864
Donc on va appeler ce fichier
"mahe.sqlite"

513
00:27:25,064 --> 00:27:26,967
et l'enregistrer.

514
00:27:29,181 --> 00:27:31,803
On peut préciser
quelques paramètres,

515
00:27:32,003 --> 00:27:35,997
la couche enregistrée
va être ajoutée en fait...

516
00:27:36,197 --> 00:27:39,620
ah, il demande de préciser
le système de projection utilisé,

517
00:27:39,820 --> 00:27:41,904
UTM sud 40.

518
00:27:42,104 --> 00:27:44,776
On peut masquer
cette nouvelle couche.

519
00:27:44,976 --> 00:27:47,355
Et dans un deuxième temps
on va enregistrer

520
00:27:47,555 --> 00:27:50,757
simplement les attributs
de la couche,

521
00:27:50,957 --> 00:27:51,818
donc sans la géométrie,

522
00:27:52,018 --> 00:27:55,280
sous la forme d'un fichier ASCII,

523
00:27:55,480 --> 00:27:56,964
un fichier texte .csv,

524
00:27:57,164 --> 00:28:01,363
donc un fichier texte avec des valeurs
séparées par des virgules.

525
00:28:04,869 --> 00:28:10,916
Pareillement, la table va être ajoutée
dans la liste des objets disponibles.

526
00:28:11,116 --> 00:28:15,210
Si on passe maintenant à un logiciel
de gestion de bases de données.

527
00:28:15,410 --> 00:28:18,506
Il s'agit de SQLite Studio.

528
00:28:18,706 --> 00:28:20,804
On peut importer.

529
00:28:21,004 --> 00:28:23,377
On va commencer
par créer une base de données en fait

530
00:28:23,577 --> 00:28:26,496
dans laquelle on va importer
le fichier texte.

531
00:28:26,696 --> 00:28:30,218
Donc on va appeler cette base
de données "mahe_data".

532
00:28:32,210 --> 00:28:34,638
Cette base de données une fois créée

533
00:28:34,838 --> 00:28:39,559
on va commencer par se connecter
à cette base de données

534
00:28:39,759 --> 00:28:43,162
et on voit qu'elle peut contenir
des tables et des vues

535
00:28:43,362 --> 00:28:44,742
qui sont en fait
des résultats de requêtes

536
00:28:46,583 --> 00:28:47,802
rendues un peu permanent.

537
00:28:48,002 --> 00:28:52,187
Dans le tables, on va importer
des données dans une nouvelle table,

538
00:28:52,387 --> 00:28:55,776
on va créer cette nouvelle table
qu'on va appeler "district"

539
00:28:55,976 --> 00:28:58,296
et importer le fichier texte

540
00:28:58,496 --> 00:29:01,832
qui contient
les attributs de ces districts

541
00:29:02,032 --> 00:29:03,869
qu'on a sauvegardé précédemment.

542
00:29:05,203 --> 00:29:09,648
On dit que la première ligne
représente les en-têtes des colonnes

543
00:29:09,848 --> 00:29:12,782
et on voit que cette table apparaît
maintenant dans l'arborescence,

544
00:29:12,982 --> 00:29:15,248
cette table district qui contient
un certain nombre de colonnes

545
00:29:15,433 --> 00:29:20,236
qui sont les différents champs que nous 
avions dans la couche district de QGIS.

546
00:29:21,801 --> 00:29:24,621
On peut consulter également
les données elles-mêmes

547
00:29:26,584 --> 00:29:31,038
et modifier la structure
de données si nécéssaire.

548
00:29:33,067 --> 00:29:35,488
Dans un deuxième temps, on va ajouter
une autre base de données

549
00:29:35,688 --> 00:29:40,168
qui est en fait la base de données
sauvegardée de QGIS

550
00:29:40,368 --> 00:29:42,508
avec les éléments de géométrie

551
00:29:42,708 --> 00:29:45,351
et on voit que si on se connecte
à cette base de données

552
00:29:45,551 --> 00:29:47,853
on a un nombre d'objets
beaucoup plus considérable

553
00:29:48,053 --> 00:29:53,074
puisqu'en fait, pour gérer
la dimension géométrique

554
00:29:53,274 --> 00:29:55,930
la base de donnée SQLite

555
00:29:56,130 --> 00:29:59,488
génère tout un tas d'objets

556
00:29:59,688 --> 00:30:01,630
qui sont nécessaires

557
00:30:03,703 --> 00:30:06,538
et qui rendent la chose
quand on l'aborde comme ça de loin

558
00:30:06,738 --> 00:30:07,777
un peu plus complexe.

559
00:30:07,977 --> 00:30:11,421
Mais on retrouve aussi la table
de données des districts de Mahé

560
00:30:11,621 --> 00:30:13,356
avec les mêmes colonnes,
les mêmes valeurs

561
00:30:13,556 --> 00:30:15,327
que l'on peut consulter
sous forme de table.

562
00:30:15,527 --> 00:30:19,537
On voit qu'il n'y en plus 
pas encore d'index

563
00:30:19,737 --> 00:30:22,069
mais des déclencheurs,
triggers en anglais,

564
00:30:22,269 --> 00:30:24,199
qui sont en fait les règles

565
00:30:24,399 --> 00:30:26,607
que le système de gestion
de bases de données

566
00:30:26,807 --> 00:30:30,175
doit vérifier
lors de chaque transaction.

567
00:30:30,375 --> 00:30:32,859
Donc on peut définir 
les règles de validation

568
00:30:33,059 --> 00:30:34,632
au cas par cas.

569
00:30:34,832 --> 00:30:40,243
Voila pour cette introduction aux logiciels
système de gestion de bases de données

570
00:30:40,443 --> 00:30:44,246
que nous reverrons plus en détails 
dans d'autres leçons du cours.

