1
00:00:00,670 --> 00:00:04,140
Now that we know everything about
subscriptions, boolean

2
00:00:04,140 --> 00:00:07,460
subscriptions, multi assignment
subscriptions,

3
00:00:07,460 --> 00:00:09,480
composite subscriptions and we have

4
00:00:09,480 --> 00:00:14,510
seen lots of examples of RX operators,
let's look

5
00:00:14,510 --> 00:00:18,080
at how we could implement some of them
ourselves.

6
00:00:18,080 --> 00:00:19,840
And the main work horse that we're going
to

7
00:00:19,840 --> 00:00:25,910
use, is this overload in the observable
companion object that

8
00:00:25,910 --> 00:00:28,700
we call Observable.create.

9
00:00:28,700 --> 00:00:31,979
Here's the picture, the marble diagram for
Observable.create.

10
00:00:33,255 --> 00:00:38,800
Observable.create takes a function from
Observer to Subscription.

11
00:00:38,800 --> 00:00:41,790
And in that function the Observer can call
onNext

12
00:00:41,790 --> 00:00:46,240
on the Observer, and then finally
onCompleted or onError.

13
00:00:46,240 --> 00:00:51,560
And the result of this application here
will return us an Observable

14
00:00:51,560 --> 00:00:55,920
of T, we call this the mother of all
factory methods.

15
00:00:55,920 --> 00:00:57,775
And we will see that most of the

16
00:00:57,775 --> 00:01:02,396
Rx operators can be implemented using this
particular overload.

17
00:01:02,396 --> 00:01:11,500
The first Observable collection that we're
going to implement is a very, very,

18
00:01:11,500 --> 00:01:17,030
very simple one, namely Observable never.
This is an observable stream

19
00:01:17,030 --> 00:01:20,570
that will never give any notifications.

20
00:01:20,570 --> 00:01:24,910
No uncompleted, no OnError, no OnNext,
nothing.

21
00:01:24,910 --> 00:01:26,100
It's completely silent.

22
00:01:28,140 --> 00:01:30,150
The second Observable collection that
we're

23
00:01:30,150 --> 00:01:33,910
going to implement is Observable error.

24
00:01:33,910 --> 00:01:37,420
This is slightly less trivial, because the
only thing that

25
00:01:37,420 --> 00:01:42,450
this one does is, it will call OnError on
the observer.

26
00:01:44,440 --> 00:01:49,696
As we promised, we're going to implement
never with observable.create.

27
00:01:50,880 --> 00:01:53,080
And in order to implement never,

28
00:01:53,080 --> 00:01:57,670
what we have to do is we have to come up
with a function that takes an observer

29
00:01:57,670 --> 00:02:00,930
and returns a subscription, and then when
we pass

30
00:02:00,930 --> 00:02:05,120
that to observable.create, we will get
back the observable.

31
00:02:06,160 --> 00:02:10,490
Never is really, really as simple as I
promised you.

32
00:02:10,490 --> 00:02:13,870
Because what never does, it takes an
observer and it

33
00:02:13,870 --> 00:02:17,530
does nothing with it, and it immediately
returns a subscription.

34
00:02:17,530 --> 00:02:18,680
So you can

35
00:02:18,680 --> 00:02:23,080
reason that, you know, the observer,
nothing will be called on the observer,

36
00:02:23,080 --> 00:02:27,820
so there will be no notifications when you
subscribe to never.

37
00:02:29,730 --> 00:02:34,500
The observable error is implemented as
another factory function.

38
00:02:34,500 --> 00:02:39,780
So we define another apply function, that
takes as the argument a throwable.

39
00:02:39,780 --> 00:02:44,110
And again, we call observable.create, by
passing it a function

40
00:02:44,110 --> 00:02:48,760
that takes an observer.
And what this one does, is it immediately

41
00:02:48,760 --> 00:02:55,020
calls observer.onError, with the argument,
and then returns the empty subscription.

42
00:02:55,020 --> 00:02:57,720
Because, after you have seen the error,
you

43
00:02:57,720 --> 00:03:00,460
don't have to do anything with that
subscription anymore.

44
00:03:02,050 --> 00:03:06,320
The third observable collection that we're
going to implement is startWith.

45
00:03:06,320 --> 00:03:09,410
StartWith takes an observable collection,

46
00:03:09,410 --> 00:03:14,952
and prepends some extra elements in front.
To implement startWith,

47
00:03:14,952 --> 00:03:19,075
we will be using observable.create

48
00:03:19,075 --> 00:03:22,710
yet again.
Here's the definition of startWith.

49
00:03:22,710 --> 00:03:30,710
It takes a varargs in scala, we indicate
that by putting a star after the argument

50
00:03:30,710 --> 00:03:34,670
type, and it returns an observable of T.
And what do we do?

51
00:03:34,670 --> 00:03:39,200
Well, the first thing that we do is we
take the observer and we

52
00:03:40,200 --> 00:03:46,580
push out all the values from the argument
list, onto the observer.

53
00:03:46,580 --> 00:03:51,400
And, once that's done, we just subscribe
that same observer to our original stream.

54
00:03:51,400 --> 00:03:52,730
The source stream.

55
00:03:52,730 --> 00:03:57,300
And, that will then, push out all the
other values on it.

56
00:03:57,300 --> 00:03:59,090
So, the picture looks, as follows.

57
00:03:59,090 --> 00:03:59,720
The first,

58
00:03:59,720 --> 00:04:01,840
if this is our argument list.

59
00:04:01,840 --> 00:04:04,432
We will first call OnNext to push out each
of

60
00:04:04,432 --> 00:04:08,820
these, and then we just subscribe to the
original source stream.

61
00:04:08,820 --> 00:04:13,370
Which will just copy all the values into
the next output stream.

62
00:04:15,380 --> 00:04:18,880
Alright, we've now seen a few simple
examples.

63
00:04:18,880 --> 00:04:25,560
Let's look at some more realistic
operators on observable collections.

64
00:04:25,560 --> 00:04:27,300
The first one we're going to do is filter.

65
00:04:28,990 --> 00:04:31,630
Just as a reminder, filter takes a
predicate.

66
00:04:31,630 --> 00:04:34,490
In this case, is it a circle.

67
00:04:34,490 --> 00:04:39,400
And then throws away all other values that
don't satisfy that predicate.

68
00:04:41,140 --> 00:04:48,460
To implement filter, we're going to use
our observable.create yet again.

69
00:04:48,460 --> 00:04:51,730
And what we're going to do is we just have
to copy all

70
00:04:51,730 --> 00:04:57,190
the values from the input stream to the
output stream if the predicate holds.

71
00:04:57,190 --> 00:05:00,260
And if the predicate is not true for a

72
00:05:00,260 --> 00:05:03,870
particular element, we just drop it on the
floor.

73
00:05:03,870 --> 00:05:06,360
How do we do that with observable.create?

74
00:05:06,360 --> 00:05:08,288
Well, simply like this.

75
00:05:08,288 --> 00:05:12,430
We call observable.create, passing at this
function

76
00:05:12,430 --> 00:05:16,840
that given observer will return a
subscription.

77
00:05:16,840 --> 00:05:18,470
Well, how do we get the subscription?

78
00:05:18,470 --> 00:05:22,390
By subscribing to our source stream, and
then we pass

79
00:05:22,390 --> 00:05:27,000
in here the three functions for OnNext,
OnError, and OnCompleted.

80
00:05:27,000 --> 00:05:31,910
When we get an OnCompleted, the source
stream is completed and

81
00:05:31,910 --> 00:05:34,740
then the output stream is also completed.

82
00:05:34,740 --> 00:05:38,300
When we get an OnError, well that means
there was an error on

83
00:05:38,300 --> 00:05:42,210
the source stream, so we just propagate
the error on the target stream.

84
00:05:42,210 --> 00:05:46,780
And now the interesting case is when we
get a regular OnNext.

85
00:05:48,070 --> 00:05:51,160
In that case, we get a value of T of type
T.

86
00:05:51,160 --> 00:05:53,720
We check whether the predicate holds or
not.

87
00:05:53,720 --> 00:05:57,000
And if the predicate is true, we propagate
the value

88
00:05:57,000 --> 00:05:58,500
to the output stream.

89
00:05:58,500 --> 00:06:01,430
So here you see that this implementation
of

90
00:06:01,430 --> 00:06:05,670
filter really, really is very close to our
intuition.

91
00:06:05,670 --> 00:06:10,790
We just listen to all of, all the
notification on the input stream.

92
00:06:10,790 --> 00:06:13,350
And only if the predicate holds.

93
00:06:13,350 --> 00:06:17,490
We propagate it and we also propagate
errors and completions.

94
00:06:20,090 --> 00:06:25,640
Of course we cannot implement any
operators without having implemented map.

95
00:06:25,640 --> 00:06:30,500
Just to remind ourselves what map does,
map takes a collection as its input,

96
00:06:30,500 --> 00:06:32,710
in this case an observable collection, it

97
00:06:32,710 --> 00:06:35,720
produces an observable collection as its
output.

98
00:06:35,720 --> 00:06:37,120
And it has a function.

99
00:06:37,120 --> 00:06:39,510
And what it does is it simply copies all

100
00:06:39,510 --> 00:06:43,000
the values from the input stream to the
output stream.

101
00:06:43,000 --> 00:06:44,920
But, while, when doing that,

102
00:06:44,920 --> 00:06:47,250
it quickly applies that function.

103
00:06:47,250 --> 00:06:51,160
So in this case, it turns all the circles
into diamonds.

104
00:06:53,360 --> 00:06:59,740
Map is actually simpler than filter.
The, the two last cases are the same.

105
00:06:59,740 --> 00:07:03,090
When we have an OnCompleted, we just
propagate the OnCompleted.

106
00:07:03,090 --> 00:07:06,580
When we have an OnError, we just propagate
the OnError.

107
00:07:06,580 --> 00:07:11,440
And now when we get a regular OnNext, all
we do, is we call the function

108
00:07:11,440 --> 00:07:17,110
F on the value that we got on OnNext, and
propagate that to the observer.

109
00:07:17,110 --> 00:07:18,880
So again, you see

110
00:07:18,880 --> 00:07:22,920
that the implementation of map very
closely

111
00:07:22,920 --> 00:07:25,360
reflects our intuition of how it should
work.

112
00:07:29,030 --> 00:07:32,120
What is fun is to look at the
implementation of map on

113
00:07:32,120 --> 00:07:38,720
iterables and compare how it relates to
the implementation of map on observables.

114
00:07:38,720 --> 00:07:41,830
And what we will see is they are very very
similar, and

115
00:07:41,830 --> 00:07:44,450
that's unsurprising because as we know,

116
00:07:44,450 --> 00:07:48,130
iterable and observables were each other's
duals.

117
00:07:48,130 --> 00:07:50,880
Here's the definition of a map for
iterables.

118
00:07:50,880 --> 00:07:54,120
Again, it takes a function from T to S.

119
00:07:54,120 --> 00:07:58,040
And in this case, instead of an
observable, it returns an iterable.

120
00:07:58,040 --> 00:08:00,450
And the source collection is also an
iterable.

121
00:08:01,590 --> 00:08:02,510
What do we do?

122
00:08:02,510 --> 00:08:06,070
Well, in this case, we use immediately

123
00:08:06,070 --> 00:08:10,050
the constructor calls, we, there's no
factory methods

124
00:08:10,050 --> 00:08:11,740
for iterables, so we just call new

125
00:08:11,740 --> 00:08:15,860
iterable and we define the methods in
there.

126
00:08:15,860 --> 00:08:20,440
So what we have to do, the iterable has to
define a method iterator,

127
00:08:20,440 --> 00:08:22,710
that returns an iterator.

128
00:08:22,710 --> 00:08:26,010
But before we return that iterator, what
we do

129
00:08:26,010 --> 00:08:30,090
is we take the iterator from the source
collection.

130
00:08:31,780 --> 00:08:34,910
And then, what we do is we do exactly the
same as what

131
00:08:34,910 --> 00:08:40,350
we did with the, map for observables, if
we get a regular value.

132
00:08:40,350 --> 00:08:44,280
So if hasNext is true, we call next.
And, you know?

133
00:08:44,280 --> 00:08:45,652
We pass the value

134
00:08:45,652 --> 00:08:47,370
to the output.

135
00:08:47,370 --> 00:08:55,210
And you know, we also just propagate the
hasNext of the source to the output.

136
00:08:55,210 --> 00:08:58,340
So, again, you see here that this
implementation follows

137
00:08:58,340 --> 00:09:02,040
the intuition that you have of map, very
closely.

138
00:09:02,040 --> 00:09:04,580
It just copies the stream and while it's

139
00:09:04,580 --> 00:09:07,880
copying, it is applying f to every
element.

140
00:09:10,820 --> 00:09:13,630
Okay.
We have now seen a couple of examples.

141
00:09:13,630 --> 00:09:19,380
And we learned that implementing filter a
map wasn't too hard.

142
00:09:19,380 --> 00:09:21,560
Time for a bigger challenge.

143
00:09:21,560 --> 00:09:26,510
Let's try to implement a conversion from
observables to futures.

144
00:09:26,510 --> 00:09:29,620
So, what we want is we want to take a
future.

145
00:09:29,620 --> 00:09:32,320
And turn that into an observable that

146
00:09:32,320 --> 00:09:36,010
just contains one value, and then
immediately doesn't

147
00:09:36,010 --> 00:09:41,440
uncomplete it.
Now, in order to define future, we

148
00:09:41,440 --> 00:09:46,810
have to make a little excursion and come
up with subject.

149
00:09:48,100 --> 00:09:49,590
What are subjects?

150
00:09:49,590 --> 00:09:55,180
Well, subjects are to observables as
promises are to futures.

151
00:09:55,180 --> 00:09:57,790
Just to remind ourselves what futures are.

152
00:09:57,790 --> 00:10:01,490
If we look at the implementation of map in
the future class,

153
00:10:01,490 --> 00:10:06,890
we saw that it looked as follows.
We created a new promise.

154
00:10:06,890 --> 00:10:11,650
Then we waited for the completion of our
future, and we applied

155
00:10:11,650 --> 00:10:16,370
the function, and then pass that to the
promise by calling complete.

156
00:10:18,370 --> 00:10:21,690
And then we returned the future part of
the promise.

157
00:10:23,390 --> 00:10:27,290
In the picture, the promise we can
visualize

158
00:10:27,290 --> 00:10:30,870
a promise as follows.
A promise has two operations.

159
00:10:30,870 --> 00:10:36,640
We can complete a promise by sending it a
result of type Try of t.

160
00:10:36,640 --> 00:10:39,560
And from a promise we can grab a future.

161
00:10:39,560 --> 00:10:44,040
And then on that future we can call
onComplete by passing it this callback.

162
00:10:44,040 --> 00:10:48,790
So whenever we pass in the complete here,
the result for complete.

163
00:10:48,790 --> 00:10:51,760
The callback of this future will be
called.

164
00:10:54,550 --> 00:10:57,450
For observables, we have something that is
very,

165
00:10:57,450 --> 00:11:01,580
very similar, and that type is called
subject.

166
00:11:01,580 --> 00:11:05,990
A subject is, it has the same idea

167
00:11:05,990 --> 00:11:09,320
as a promise, but the implementation is
slightly different.

168
00:11:09,320 --> 00:11:14,540
Instead of, you know, taking a promise
from the future, a subject is both

169
00:11:14,540 --> 00:11:20,020
an observer and an observable.
But it works the same.

170
00:11:20,020 --> 00:11:22,070
What you can do is you can put a

171
00:11:22,070 --> 00:11:26,800
value into a subject by calling onNext,
onCompleted, or onError.

172
00:11:26,800 --> 00:11:29,862
That's the observer part of a subject.

173
00:11:29,862 --> 00:11:32,010
And then the other thing that you can do
is you

174
00:11:32,010 --> 00:11:38,030
can subscribe to a subject, written
observer or again with three callbacks.

175
00:11:38,030 --> 00:11:40,730
And then whenever you call onNext here, it

176
00:11:40,730 --> 00:11:43,850
will be propagated to the callback
function there.

177
00:11:43,850 --> 00:11:45,830
And whenever you call onCompleted,

178
00:11:45,830 --> 00:11:48,990
it will be propagated to the observer on
the

179
00:11:48,990 --> 00:11:55,090
other side, exactly how a promised worked
for futures.

180
00:11:55,090 --> 00:11:58,800
Now, maybe you remember the lecture about
cold versus hot

181
00:11:58,800 --> 00:12:02,150
observables, and what, what we said there
is that a

182
00:12:02,150 --> 00:12:07,280
cold observable is one where you get a
private, source

183
00:12:07,280 --> 00:12:10,970
for each subscription, and a hot
observable was one where

184
00:12:10,970 --> 00:12:12,730
the source was shared.

185
00:12:12,730 --> 00:12:17,580
Well, here you see that the subject makes
a cold observable hot.

186
00:12:17,580 --> 00:12:23,090
Once you subscribe to a subject here, it
has kind of only one side here.

187
00:12:23,090 --> 00:12:25,530
So, it's a sharing point where you can

188
00:12:25,530 --> 00:12:29,740
have multiple subscribers that listen to
one source.

189
00:12:31,560 --> 00:12:35,780
To drill down a little bit into that
aspect of subjects,

190
00:12:35,780 --> 00:12:38,060
let's look at the following code.

191
00:12:38,060 --> 00:12:43,020
And this code shows that a subject behaves
like a channel, like a fan-out point.

192
00:12:44,480 --> 00:12:49,640
And the first subject that we're going to
use here is called a publish subject.

193
00:12:49,640 --> 00:12:54,415
And we're creating a publish subject of
integers, and let's call that one channel.

194
00:12:54,415 --> 00:12:57,797
And we're going to subscribe to that
channel

195
00:12:57,797 --> 00:13:00,823
with two subscribers, a and b, and they

196
00:13:00,823 --> 00:13:04,310
just print whatever value comes out of
them.

197
00:13:05,980 --> 00:13:08,550
Now, on the channel, we're going to push a
sequence

198
00:13:08,550 --> 00:13:13,600
of values, and we're going to subscribe
and unsubscribe as well.

199
00:13:13,600 --> 00:13:19,350
The first thing we're going to do is to
push 42 onto the channel.

200
00:13:19,350 --> 00:13:26,000
So that's what happens here.
Since both a and b here are at

201
00:13:26,000 --> 00:13:29,150
this point subscribed to our channel.

202
00:13:29,150 --> 00:13:32,230
What we will see is that a will receive
42.

203
00:13:32,230 --> 00:13:36,710
And b will also receive 42 because both
are subscribed.

204
00:13:36,710 --> 00:13:40,880
Now, the next thing is that a will
unsubscribe.

205
00:13:40,880 --> 00:13:44,350
In which case, it will not receive any
further notifications.

206
00:13:44,350 --> 00:13:48,930
Remember, that's what, is what
unsubscription means.

207
00:13:48,930 --> 00:13:51,480
Once you unsubscribe, you will not be
notified

208
00:13:51,480 --> 00:13:59,274
of any other notifications.
So, if we call onNext

209
00:13:59,274 --> 00:14:06,080
4711, then b who is still subscribed will
receive that.

210
00:14:06,080 --> 00:14:09,700
But a as you see here, will not receive
this 4711.

211
00:14:09,700 --> 00:14:16,510
Now let's call uncompleted on the channel.
We indicate that with this

212
00:14:16,510 --> 00:14:21,290
little exclamation mark.
And after that, we're going to subscribe

213
00:14:21,290 --> 00:14:28,050
another subscriber here called c, that,
that we show over there on the right.

214
00:14:29,800 --> 00:14:34,400
And last thing that we do, is we're
sending 13 on the channel.

215
00:14:35,790 --> 00:14:41,710
Now the channel is such that, after you've
called onCompleted on it,

216
00:14:41,710 --> 00:14:44,320
it will ignore all subsequent values.

217
00:14:44,320 --> 00:14:47,660
So, this value, 13, as you see, is not
propagated.

218
00:14:47,660 --> 00:14:49,890
Because, as soon as you call onCompleted
on

219
00:14:49,890 --> 00:14:54,730
the channel, all the subscribers will
receive an onCompleted.

220
00:14:54,730 --> 00:14:57,770
And anything you send on the channel after

221
00:14:57,770 --> 00:15:00,860
you've sent an onCompleted will just be
ignored.

222
00:15:00,860 --> 00:15:08,740
So c will only see uncompleted, and b will
see 42, 4711, and then uncompleted.

223
00:15:08,740 --> 00:15:14,560
But the Rx contract we will talk about
that in a future lesson, will guarantee

224
00:15:14,560 --> 00:15:19,879
that after you've seen uncompleted on, or
onError, you never see any more values.

225
00:15:21,000 --> 00:15:26,910
One interesting thing to notice is that
subscriber c here that subscribes

226
00:15:26,910 --> 00:15:32,484
to the channel after it was completed,
still receives the onCompleted.

227
00:15:32,484 --> 00:15:34,170
And in that way

228
00:15:34,170 --> 00:15:39,870
c knows that it is going to subscribe to
an already completed channel, so you see

229
00:15:39,870 --> 00:15:46,280
here it's, happens afterwards, but it
still got the onCompleted here.

230
00:15:46,280 --> 00:15:49,184
The second subject that we're going to

231
00:15:49,184 --> 00:15:52,670
investigate is the so called replay
subject.

232
00:15:52,670 --> 00:15:55,900
A replay subject is something that buffers
all

233
00:15:55,900 --> 00:15:57,950
the values that it has seen in the past.

234
00:15:59,110 --> 00:16:03,950
So, let's create a ReplaySubject, let's
create two subscriptions

235
00:16:03,950 --> 00:16:09,230
to it, a and b.
Again, we see them here in this picture.

236
00:16:09,230 --> 00:16:16,710
And let's send again 42 onto the channel.
Since both a and b

237
00:16:16,710 --> 00:16:24,050
were subscribed to it, we see that a gets
42, and b also gets 42.

238
00:16:24,050 --> 00:16:27,140
Now a unsubscribes from the channel, which

239
00:16:27,140 --> 00:16:30,940
means it will not receive any future
notifications.

240
00:16:30,940 --> 00:16:33,008
So, a only ever will see 42.

241
00:16:33,008 --> 00:16:39,930
We're going to send 4711 on the channel
which will be received by b.

242
00:16:41,030 --> 00:16:46,870
And then we will call onCompleted here,
which will be received by b.

243
00:16:48,370 --> 00:16:49,140
Now after

244
00:16:49,140 --> 00:16:55,270
the channel has been completed, we
subscribe subscriber c to the channel.

245
00:16:55,270 --> 00:17:00,460
And guess what, since the channel has a
history

246
00:17:00,460 --> 00:17:05,750
cached, whenever you subscribe with c, it
will replay the whole sequence

247
00:17:05,750 --> 00:17:11,010
so c will receive 42, 4711, and
onCompleted.

248
00:17:11,010 --> 00:17:15,040
And again, if we push anything on the
channel

249
00:17:15,040 --> 00:17:18,030
after it has been completed, this value
will

250
00:17:18,030 --> 00:17:20,300
just be ignored and dropped on the floor.

251
00:17:24,610 --> 00:17:30,670
There are four different kinds of subjects
in Rx that are most commonly used.

252
00:17:30,670 --> 00:17:34,590
And they are the publish subject that we
already saw.

253
00:17:34,590 --> 00:17:37,800
The replay subject that we already saw,
and then there's

254
00:17:37,800 --> 00:17:41,890
two new ones, the async subject and the
behavior subject.

255
00:17:41,890 --> 00:17:44,870
Let's revisit the publish subject for a
second.

256
00:17:44,870 --> 00:17:49,600
The publish subject always sends out the
current value.

257
00:17:49,600 --> 00:17:50,430
What does that mean?

258
00:17:50,430 --> 00:17:53,140
Say that, you know, the subscription here
below

259
00:17:53,140 --> 00:17:56,230
subscribes at the point where the arrow
is.

260
00:17:56,230 --> 00:17:58,870
What it will see, it will only see
onCompleted.

261
00:17:58,870 --> 00:18:03,140
And, the, the top subscriber here always
was subscribing

262
00:18:03,140 --> 00:18:05,760
from the beginning, so it has seen the
whole sequence.

263
00:18:05,760 --> 00:18:07,940
So, this is what we saw in the previous
example.

264
00:18:09,250 --> 00:18:12,270
The replay subject, we've seen that as
well.

265
00:18:12,270 --> 00:18:14,610
In this case, it caches all the

266
00:18:14,610 --> 00:18:19,380
values so if the bottom one here
subscribes at this point,

267
00:18:19,380 --> 00:18:24,240
it will get all the values and then
finally, the onCompleted.

268
00:18:25,980 --> 00:18:31,480
Now there, the two other ones.
let's do the behavior subject first.

269
00:18:31,480 --> 00:18:36,110
A behavior subject always caches the
latest value.

270
00:18:36,110 --> 00:18:39,910
So in this case when the bottom line here,

271
00:18:39,910 --> 00:18:43,630
when the bottom subscriber here subscribes
at this point.

272
00:18:43,630 --> 00:18:45,160
The latest value was 4711.

273
00:18:45,160 --> 00:18:51,010
So at the moment you subscribe here, you
get the latest value 4711 plus

274
00:18:51,010 --> 00:18:56,260
all future values, and then in this case,
onCompleted.

275
00:18:56,260 --> 00:18:59,540
The last subject here is an async subject,
and

276
00:18:59,540 --> 00:19:03,730
an async subject caches the final value of
a stream.

277
00:19:03,730 --> 00:19:05,336
So it caches the last

278
00:19:05,336 --> 00:19:10,040
onNext before an onCompleted.

279
00:19:10,040 --> 00:19:15,150
And in this case, you see that both
subscribers here get the same value.

280
00:19:15,150 --> 00:19:19,840
And the async subject is a little bit like
a replay subject, even though

281
00:19:19,840 --> 00:19:21,590
you subscribe to it after it has

282
00:19:21,590 --> 00:19:25,050
completed, it will send out the cached
value.

283
00:19:28,310 --> 00:19:34,980
To close off the subject of subjects, pun
intended, let's do a little quiz.

284
00:19:34,980 --> 00:19:39,170
Let's define a channel that is an
AsyncSubject of integers.

285
00:19:39,170 --> 00:19:42,950
And, again, we have our two subscribers, a
and b.

286
00:19:42,950 --> 00:19:48,580
That just print the values again in our
picture there's a and b here,

287
00:19:48,580 --> 00:19:53,540
and we're going to send the same values
over to channel 42, then a

288
00:19:53,540 --> 00:19:58,146
unsubscribes, then we send 4711,

289
00:19:58,146 --> 00:20:02,960
then we call onCompleted.
Our next subscriber enters, and

290
00:20:02,960 --> 00:20:08,400
finally we called 13, and after we've
already closed the channel.

291
00:20:08,400 --> 00:20:14,690
The question is, which of these sequences
here, a, b or c, is correct?

292
00:20:17,630 --> 00:20:22,080
Let's look at a.
According to this,

293
00:20:22,080 --> 00:20:27,680
a receives the sequence 4711 and
onCompleted.

294
00:20:27,680 --> 00:20:33,670
However, a already unsubscribed, before
the channel completed.

295
00:20:33,670 --> 00:20:37,310
So a will never get the onCompleted
because it has unsubscribed.

296
00:20:37,310 --> 00:20:38,840
So this is wrong.

297
00:20:40,290 --> 00:20:42,828
Let's look at c here.

298
00:20:42,828 --> 00:20:50,340
C joined after the channel was completed.
But since this is an async subject,

299
00:20:50,340 --> 00:20:55,160
it should only see the last value, and so
this 42 should not be in there.

300
00:20:55,160 --> 00:20:56,590
So, this one is also wrong.

301
00:20:58,040 --> 00:21:02,840
And the last one here, this is the correct
answer.

302
00:21:02,840 --> 00:21:08,150
Because we're sending 42, 4711, and then
onCompleted, and

303
00:21:08,150 --> 00:21:13,190
then AsyncSubject caches the last onNext
before an onCompleted.

304
00:21:13,190 --> 00:21:15,060
And then that's in this case 4711.

305
00:21:15,060 --> 00:21:17,350
That's here.

306
00:21:17,350 --> 00:21:20,602
And then it immediately sends out
onCompleted.

307
00:21:23,500 --> 00:21:24,000
Alright.

308
00:21:25,020 --> 00:21:29,050
Now that we know about subjects, let's
revisit how

309
00:21:29,050 --> 00:21:32,960
we're going to create an observable from a
future.

310
00:21:35,110 --> 00:21:38,420
To convert the future to an observable,
we're going to

311
00:21:38,420 --> 00:21:43,740
define a new constructor function in the
observable companion class.

312
00:21:43,740 --> 00:21:45,940
So we, we're going to define apply here

313
00:21:48,910 --> 00:21:52,090
that takes a future and returns an
observable.

314
00:21:53,640 --> 00:21:55,900
And what we're going to do is we're going
to use

315
00:21:55,900 --> 00:22:01,930
the fact that an AsyncSubject behaves very
much like a promise.

316
00:22:01,930 --> 00:22:04,380
Remember a promise was something where I
can

317
00:22:04,380 --> 00:22:06,870
put in a value and then whenever I wanted

318
00:22:06,870 --> 00:22:09,752
to listen to that value, whenever I can,
I,

319
00:22:09,752 --> 00:22:14,468
that onComplete on the promise, I got that
value.

320
00:22:14,468 --> 00:22:16,504
Well the same thing, we're going to do
here.

321
00:22:16,504 --> 00:22:22,584
So we're creating async subject, and then
what we're going to do is we're

322
00:22:22,584 --> 00:22:28,756
going to take the future and give as it
onComplete the following functions.

323
00:22:28,756 --> 00:22:36,270
When the future completes with a failure,
well, we just send onError to the subject.

324
00:22:36,270 --> 00:22:39,570
However, when the future terminates
successfully with

325
00:22:39,570 --> 00:22:45,160
some value c, what we do is we send that
value c onto the subject.

326
00:22:45,160 --> 00:22:47,760
And we complete the subject.

327
00:22:47,760 --> 00:22:52,640
And now, we return the subject and all is
great and fine.

328
00:22:52,640 --> 00:22:57,700
Because when we subscribe to this subject,
to the observer part of

329
00:22:57,700 --> 00:23:03,050
the subject that comes out of here, it
will give us always this value.

330
00:23:03,050 --> 00:23:05,010
Which is exactly the value

331
00:23:05,010 --> 00:23:06,930
that comes out of the future.

332
00:23:09,690 --> 00:23:15,050
As we've seen in a previous example,
futures use this try class, so their

333
00:23:15,050 --> 00:23:20,710
callbacks take a value of type Try of T,
which has two

334
00:23:20,710 --> 00:23:26,840
subtypes, namely success with a proper
value of type T, or a failure.

335
00:23:26,840 --> 00:23:29,500
On the other hand, in observables.

336
00:23:29,500 --> 00:23:33,720
What we do is we typically take three call
backs.

337
00:23:33,720 --> 00:23:34,890
One for OnNext,

338
00:23:34,890 --> 00:23:40,920
one for OnError, OnCompleted.
But in Rx, there's also a type that

339
00:23:40,920 --> 00:23:46,880
corresponds very closely to the tri-type.
And this is the type notification of T.

340
00:23:46,880 --> 00:23:52,180
A notification of T has instead of two
cases, it has three cases.

341
00:23:52,180 --> 00:23:57,620
It has an OnNext, which directly
corresponds to the success case here.

342
00:23:57,620 --> 00:24:00,390
It has an OnError, that directly
corresponds

343
00:24:00,390 --> 00:24:02,560
to the failure case in a Try.

344
00:24:02,560 --> 00:24:06,910
But it also needs the third case, to
indicate successful termination,

345
00:24:06,910 --> 00:24:10,000
and that is the third case of the sum
here, OnCompleted.

346
00:24:11,270 --> 00:24:15,010
And there is a method on Observable called

347
00:24:15,010 --> 00:24:19,030
materialize that turns an Observable of T
into

348
00:24:19,030 --> 00:24:25,900
an Observable of notifications of T, and
in that case, you can do a pattern match.

349
00:24:25,900 --> 00:24:29,680
On the notification of the very similar to
how you do a

350
00:24:29,680 --> 00:24:34,800
pattern match on the Try of T in the
OnComplete of a future.

351
00:24:37,480 --> 00:24:43,010
Here's the marble diagram for materialize.
We see here our regular

352
00:24:43,010 --> 00:24:48,250
stream where there's onNext, onNext,
onCompleted and when we materialize what

353
00:24:48,250 --> 00:24:53,850
we do is we inject that into the
notification type.

354
00:24:53,850 --> 00:24:59,760
So now we get a value onNext that has the
value that was passed here in the onNext.

355
00:24:59,760 --> 00:25:03,000
We have a value onNext here for the second
one, and

356
00:25:03,000 --> 00:25:03,820
then onCompleted.

357
00:25:03,820 --> 00:25:08,570
And then, the underlying stream has it's
own completed as well.

358
00:25:11,530 --> 00:25:13,750
Remember when we were.

359
00:25:13,750 --> 00:25:17,670
Discussing futures that we said that
sometimes you need

360
00:25:17,670 --> 00:25:21,260
to do blocking, even though that's a bad
practice,

361
00:25:21,260 --> 00:25:23,200
but you know, say that you want to debug

362
00:25:23,200 --> 00:25:26,080
things, or you, sometimes you just need to
block.

363
00:25:26,080 --> 00:25:31,660
And to make this really, really apparent
in futures, we use this

364
00:25:31,660 --> 00:25:37,580
await thing here the await class, where
you, where you did .result.

365
00:25:37,580 --> 00:25:41,920
And then you know, you would wait at most
ten seconds in this case.

366
00:25:41,920 --> 00:25:47,350
But the blocking was made very, very, very
explicit by using this await.

367
00:25:48,710 --> 00:25:50,750
The same is true for observables.

368
00:25:50,750 --> 00:25:54,380
Sometimes you just want to block on an
observable.

369
00:25:54,380 --> 00:25:56,896
for example, if you're de-bugging.

370
00:25:56,896 --> 00:26:01,950
Or, maybe, you know, you want to, you have
to move back to a blocking,

371
00:26:01,950 --> 00:26:03,240
situation.

372
00:26:03,240 --> 00:26:08,900
It's not recommended, but just in case,
you can do the same with observables.

373
00:26:11,340 --> 00:26:17,090
And the operator that we use for that is
called two blocking observable.

374
00:26:17,090 --> 00:26:19,380
So when you have an observable and you do
two

375
00:26:19,380 --> 00:26:24,590
blocking observable, you get a few extra
methods that are blocking.

376
00:26:24,590 --> 00:26:30,610
But all the other regular methods in Rx
are all non-blocking.

377
00:26:30,610 --> 00:26:37,780
One interesting aspect of Rx, as I said,
is that all operators are non-blocking.

378
00:26:37,780 --> 00:26:39,825
Let's look at this following example.

379
00:26:39,825 --> 00:26:44,110
We creating an observable stream, using
Observable.interval, so this

380
00:26:44,110 --> 00:26:47,880
is the observable creation method that
will create the

381
00:26:47,880 --> 00:26:50,720
stream that will tick every second, and we
will

382
00:26:50,720 --> 00:26:53,765
take the first five values of that using
take(5).

383
00:26:55,070 --> 00:26:58,280
If we want to turn that into a list, we
first

384
00:26:58,280 --> 00:27:00,750
have to call this dangerous method

385
00:27:00,750 --> 00:27:05,320
and it's long on purpose,
toBlockingObservable,

386
00:27:05,320 --> 00:27:07,820
and then we can call toList.

387
00:27:07,820 --> 00:27:11,900
So what you see here is that we go from an
observable[Long],

388
00:27:11,900 --> 00:27:17,770
to an list of long, and we do that by
calling this toBlockingObservable.

389
00:27:17,770 --> 00:27:23,950
So, when we print ys, we get the list zero
to five.

390
00:27:26,300 --> 00:27:33,940
Now, say that we call the sum operator.
On the original, sequence axis here.

391
00:27:33,940 --> 00:27:37,720
So we have an observable of long, and we
call sum.

392
00:27:37,720 --> 00:27:40,270
So that sums up all the values.

393
00:27:40,270 --> 00:27:45,390
Well since all the operators, the regular
operators are non-blocking, the

394
00:27:45,390 --> 00:27:49,950
result of summing the numbers is still an
observable of longs.

395
00:27:49,950 --> 00:27:51,660
However it's an observable

396
00:27:51,660 --> 00:27:54,020
that has only a single value.

397
00:27:54,020 --> 00:27:59,620
So when we want to get that value out of
this observable, what we do is we again,

398
00:27:59,620 --> 00:28:06,120
we can call toBlockingObservable and then
we can call the function single.

399
00:28:06,120 --> 00:28:10,830
To get from an observable of long to an
observable.

400
00:28:10,830 --> 00:28:17,030
And notice that single will throw if the
argument, if the source stream does

401
00:28:17,030 --> 00:28:19,580
not contain exactly one element.

402
00:28:21,620 --> 00:28:26,570
As you may remember from the lectures on,
on lists, before.

403
00:28:26,570 --> 00:28:29,900
A lot of the aggregate operators like sum
and average

404
00:28:29,900 --> 00:28:33,700
and so on, can be defined in terms of
reduce.

405
00:28:33,700 --> 00:28:37,150
Reduce is a function that has the
following signature.

406
00:28:37,150 --> 00:28:43,030
It takes a binary operator, T and T, and
it returns a T.

407
00:28:43,030 --> 00:28:47,040
And what it does, it just collapses all
the values

408
00:28:47,040 --> 00:28:48,540
in the input stream.

409
00:28:48,540 --> 00:28:52,100
Into a single value by applying this
operator.

410
00:28:52,100 --> 00:28:55,580
So the marble diagram shows that very
nicely.

411
00:28:55,580 --> 00:28:59,530
We have our source stream here, and the

412
00:28:59,530 --> 00:29:04,960
reduction collapses all the values by
combining them.

413
00:29:04,960 --> 00:29:08,840
And you see here they kind of are nicely
stacked on top of each other.

414
00:29:10,340 --> 00:29:13,480
The thing in Rx is that reduce

415
00:29:13,480 --> 00:29:15,050
still returns an observable.

416
00:29:15,050 --> 00:29:18,100
So, as you can see here it returns

417
00:29:18,100 --> 00:29:21,900
an observable collection that has a single
value.

418
00:29:21,900 --> 00:29:24,000
Which is very much like a future.

419
00:29:24,000 --> 00:29:29,500
So, another possibility would have been
that reduce would have returned a future.

420
00:29:29,500 --> 00:29:33,590
But since we can turn a future, an
observable,

421
00:29:33,590 --> 00:29:36,480
into a future, you can always do that by
hand.

422
00:29:36,480 --> 00:29:38,620
And we have just shown you how you

423
00:29:38,620 --> 00:29:39,700
can do that yourself.

424
00:29:41,352 --> 00:29:46,740
What is interesting with blocking is that
we are removing concurrency.

425
00:29:46,740 --> 00:29:50,960
So if we start with an observable
collection and we want to go to a

426
00:29:50,960 --> 00:29:56,080
list, we have to block, which means that
we have to remove concurrency.

427
00:29:57,810 --> 00:30:03,720
In the next lecture, we will show how to
go from an iterable collection,

428
00:30:03,720 --> 00:30:05,660
to an observable collection.

429
00:30:05,660 --> 00:30:09,790
And in this case, we have to add
concurrency.

430
00:30:09,790 --> 00:30:13,840
And that reminds us of another duality.

431
00:30:13,840 --> 00:30:15,410
Namely, De Morgan's duality.

432
00:30:15,410 --> 00:30:18,510
And this is a duality that every
programmer knows

433
00:30:18,510 --> 00:30:22,380
and that all of us use everyday when we're
programming.

434
00:30:22,380 --> 00:30:29,040
And De Morgan's law says the following,
that not a and b is the same as not a or

435
00:30:29,040 --> 00:30:30,070
not b.

436
00:30:30,070 --> 00:30:37,270
And conversely, not a or b is the same as
not a and not b.

437
00:30:37,270 --> 00:30:39,570
What this says is that and and or are
dual.

438
00:30:40,980 --> 00:30:46,060
And the energy between this, that drives
this duality is negation.

439
00:30:48,090 --> 00:30:54,240
Interestingly we have seen that iterable
and observable are each others dual.

440
00:30:54,240 --> 00:31:00,150
And there, it's not negation that is the
energy between them but it's concurrency.

441
00:31:00,150 --> 00:31:02,600
And that's what we will see in the next
lesson.

442
00:31:03,890 --> 00:31:07,130
In the next lesson, we are going to tackle
this challenge.

443
00:31:07,130 --> 00:31:11,130
Given an iterable collection.

444
00:31:11,130 --> 00:31:13,790
We want to create an observable
collection.

445
00:31:15,050 --> 00:31:16,960
And the challenge is that we want to make

446
00:31:16,960 --> 00:31:21,280
this work even if this iterable collection
is infinite.

447
00:31:22,400 --> 00:31:27,270
And in particular what we want to do is
that at any time as we're iterating

448
00:31:27,270 --> 00:31:29,830
over the source collection, we want to be

449
00:31:29,830 --> 00:31:34,870
able to unsubscribe from the resulting
observable collection.

450
00:31:36,710 --> 00:31:40,730
As a cliff hanger, I'll give you the wrong
implementation.

451
00:31:40,730 --> 00:31:49,310
So, let's try to define this naively,
using our big friend, observable, create.

452
00:31:49,310 --> 00:31:54,490
Here's our function from takes an iterable
and it returns an observable.

453
00:31:54,490 --> 00:31:55,590
And what are we going to do?

454
00:31:55,590 --> 00:31:59,440
Well, let's do this.
Now if we would just go to foreach over

455
00:31:59,440 --> 00:32:06,680
the search collection, and then bump out
the values on the observer.

456
00:32:06,680 --> 00:32:09,740
Then we complete and then ret, return a
subscription.

457
00:32:11,320 --> 00:32:16,300
If you think about this a little bit, you
will see that this doesn't really work.

458
00:32:16,300 --> 00:32:20,185
If the sequence is infinite, it will never
reach the onCompleted.

459
00:32:21,800 --> 00:32:25,750
If the sequence fails, it doesn't call
OnError.

460
00:32:25,750 --> 00:32:31,960
And even, since the subscription here is
trivial, it doesn't allow

461
00:32:31,960 --> 00:32:36,170
us to unsubscribe as we're iterating over
the foreach loop.

462
00:32:36,170 --> 00:32:41,800
So this implementation is completely
wrong.

463
00:32:41,800 --> 00:32:42,600
Completely wrong.

464
00:32:42,600 --> 00:32:44,930
We should really, really kind of forget
this.

465
00:32:46,220 --> 00:32:47,570
Remove it from our brains.

466
00:32:47,570 --> 00:32:51,790
The question, however, is how can we make
this work?

467
00:32:51,790 --> 00:32:54,470
And for that, we need schedulers.

