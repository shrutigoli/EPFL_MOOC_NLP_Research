1
00:00:03,010 --> 00:00:05,208
Dans une séquence vidéo précédente
nous avons étudié

2
00:00:05,208 --> 00:00:07,558
le cas des tableaux 
de taille fixe en Java.

3
00:00:07,558 --> 00:00:09,268
Nous avons vu que pour ces tableaux,

4
00:00:09,268 --> 00:00:12,258
une fois la taille fixée au moment 
de l'initialisation du tableau,

5
00:00:12,258 --> 00:00:15,605
il n'est plus possible de la modifier 
lorsque le programme s'exécute.

6
00:00:15,605 --> 00:00:18,263
Nous allons aujourd'hui étudier
les tableaux dynamiques

7
00:00:18,263 --> 00:00:20,316
qui nous affranchiront
de cette contrainte.

8
00:00:20,616 --> 00:00:23,583
Les tableaux dynamiques ont la
particularité de pouvoir voir leur taille

9
00:00:23,583 --> 00:00:26,404
croître ou décroître pendant que
le programme s'exécute.

10
00:00:26,404 --> 00:00:30,196
Leur utilisation nécessite en réalité 
un certain nombre de concepts

11
00:00:30,196 --> 00:00:31,861
liés à l'orienté objet.

12
00:00:31,951 --> 00:00:33,936
Cependant tout comme pour 
les chaines de caractères,

13
00:00:33,936 --> 00:00:36,411
il n'est pas nécessaire
d'avoir une connaissance préalable

14
00:00:36,411 --> 00:00:38,388
de ces concepts pour pouvoir utiliser

15
00:00:38,388 --> 00:00:40,513
les fonctionnalités 
requises au préalable.

16
00:00:40,663 --> 00:00:43,688
Nous avons choisi de les présenter
très tôt dans le cadre de ce cours

17
00:00:43,688 --> 00:00:46,664
car les tableaux dynamiques sont 
d'une utilisation très naturelle

18
00:00:46,664 --> 00:00:48,952
pour la résolution
de nombreux problèmes

19
00:00:48,952 --> 00:00:51,386
qui ne sont pas forcément liés
à l'orienté objet.

20
00:00:52,062 --> 00:00:53,544
Comme pour les tableaux statiques,

21
00:00:53,544 --> 00:00:56,916
les tableaux dynamiques sont 
une collection de données homogènes.

22
00:00:56,916 --> 00:00:58,668
Pour pouvoir les utiliser,

23
00:00:58,668 --> 00:01:01,230
on a recours à un type particulier 
pré défini en Java

24
00:01:01,230 --> 00:01:05,557
qui s'appelle « ArrayList », 
ce type n'est pas défini par défaut,

25
00:01:05,557 --> 00:01:09,687
pour l'utiliser dans un fichier
il faut inclure au début du fichier

26
00:01:09,687 --> 00:01:15,194
une directive d'importation qui va rendre
accessible le type ArrayList.

27
00:01:17,324 --> 00:01:20,658
On peut déclarer en Java 
une variable de type « ArrayList »

28
00:01:20,658 --> 00:01:22,889
en ayant recours
à la syntaxe suivante :

29
00:01:22,889 --> 00:01:26,117
on met le nom de la variable
et en guise de type,

30
00:01:26,117 --> 00:01:28,637
il faudra mettre
le nom réservé « ArrayList »

31
00:01:28,637 --> 00:01:33,575
suivi des deux symboles ouvrant et fermant
inférieur et supérieur,

32
00:01:33,575 --> 00:01:36,473
et entre ces deux symboles 
le type de données

33
00:01:36,473 --> 00:01:38,671
qu'on veut mettre dans le tableau.

34
00:01:39,061 --> 00:01:42,270
Notez que le type doit être 
impérativement un type évolué ;

35
00:01:42,433 --> 00:01:44,449
voici un exemple concret :

36
00:01:44,449 --> 00:01:47,995
ici on est en train de déclarer 
une variable tableau,

37
00:01:47,995 --> 00:01:54,005
le type de cette variable est un tableau
dynamique de chaîne de caractères.

38
00:01:55,034 --> 00:01:58,515
Vous noterez que la variable ainsi déclarée
n'est pas initialisée,

39
00:01:58,515 --> 00:02:00,656
on ne lui affecte pas de valeurs initiales.

40
00:02:00,656 --> 00:02:04,126
Comment faire pour initialiser 
un tableau dynamique ?

41
00:02:05,447 --> 00:02:08,147
Une façon courante d'initialiser
un tableau dynamique

42
00:02:08,147 --> 00:02:11,097
est de l'initialiser au moyen
d'un tableau vide,

43
00:02:11,097 --> 00:02:13,249
un tableau sans aucun élément.

44
00:02:13,249 --> 00:02:15,317
Ceci se fait par la tournure suivante :

45
00:02:15,317 --> 00:02:17,495
donc à la variable associée au tableau

46
00:02:17,495 --> 00:02:22,424
nous allons affecter un tableau vide
qui est créé par la tournure suivante,

47
00:02:22,436 --> 00:02:26,490
donc une tournure à respecter
exactement sous cette forme là

48
00:02:26,490 --> 00:02:29,250
le mot réservé « new », 
le mot réservé « ArrayList »,

49
00:02:29,250 --> 00:02:32,432
ici il faudra mettre exactement 
le même type

50
00:02:32,432 --> 00:02:35,554
que celui qu'on a mis au moment
de la déclaration du tableau,

51
00:02:35,554 --> 00:02:38,407
suivi des deux parenthèses
à ne pas oublier.

52
00:02:38,753 --> 00:02:43,132
Ici nous avons recours en fait 
à une tournure liée à l'orienté objet

53
00:02:43,132 --> 00:02:44,995
mais il n'est pas nécessaire 
d'en comprendre

54
00:02:44,995 --> 00:02:47,398
les tenants et aboutissants
pour l'employer.

55
00:02:47,398 --> 00:02:51,152
Ce qu'il faut retenir ici c'est 
qu'au moyen de cette instruction,

56
00:02:51,152 --> 00:02:53,113
vous avez construit 
un tableau dynamique

57
00:02:53,113 --> 00:02:54,645
sans aucun élément.

58
00:02:54,645 --> 00:02:58,427
Ici vous avez un exemple concret 
de déclaration initialisation

59
00:02:58,427 --> 00:03:00,768
d'un tableau dynamique 
de chaîne de caractères,

60
00:03:00,768 --> 00:03:04,579
la variable tableau contient
la référence à un tableau dynamique

61
00:03:04,579 --> 00:03:07,051
de chaîne de caractères 
sans aucun élément.

62
00:03:07,571 --> 00:03:10,805
Puisque ce tableau ainsi déclaré 
ne contient aucun élément,

63
00:03:10,805 --> 00:03:12,792
nous allons naturellement
nous poser la question

64
00:03:12,792 --> 00:03:15,560
de comment mettre des valeurs 
dans ce tableau.

65
00:03:17,257 --> 00:03:19,796
Comme pour les chaîne de caractères,
il existe un certain nombre

66
00:03:19,796 --> 00:03:23,129
de fonctionnalités de méthodes spécifiques
liées au type « ArrayList » ;

67
00:03:23,129 --> 00:03:25,362
pour pouvoir utiliser ces fonctionnalités

68
00:03:25,362 --> 00:03:29,608
il faut recourir à une syntaxe particulière,
nom du tableau, suivi du point,

69
00:03:29,608 --> 00:03:31,701
suivi du nom de la méthode 
de la fonctionnalité

70
00:03:31,701 --> 00:03:34,930
et ensuite on doit indiquer 
entre parenthèses les données

71
00:03:34,930 --> 00:03:38,706
dont a besoin la fonctionnalité,
la méthode pour pouvoir s'exécuter.

72
00:03:39,337 --> 00:03:41,232
Vous avez ici un exemple concret

73
00:03:41,232 --> 00:03:43,569
je déclare un tableau dynamique
de chaîne de caractères

74
00:03:43,569 --> 00:03:46,476
qui s'appelle « prenoms »
et j'initialise ce tableau

75
00:03:46,476 --> 00:03:48,164
au moyen d'un tableau vide.

76
00:03:49,399 --> 00:03:52,032
Ensuite j'ai recours à 
une fonctionnalité particulière

77
00:03:52,032 --> 00:03:54,665
définie pour les « ArrayLists »
qui s'appelle « size ».

78
00:03:54,665 --> 00:03:57,299
Cette fonctionnalité retourne 
simplement la taille courante

79
00:03:57,299 --> 00:03:58,769
du tableau dynamique.

80
00:03:58,774 --> 00:04:01,218
J'ai eu recours à la syntaxe
que je viens d'évoquer

81
00:04:01,218 --> 00:04:03,431
à savoir, le nom du tableau,
suivi de point,

82
00:04:03,431 --> 00:04:05,284
suivi du nom de la fonctionnalité.

83
00:04:05,284 --> 00:04:07,319
« Size » n'a besoin d'aucune
information extérieure

84
00:04:07,319 --> 00:04:09,731
pour pouvoir fournir la taille du tableau,

85
00:04:09,731 --> 00:04:12,410
donc je dois mettre une liste 
de parenthèses vides ;

86
00:04:12,822 --> 00:04:15,800
évidemment l'exécution 
de cette instruction va afficher 0

87
00:04:15,800 --> 00:04:18,889
puisque j'ai initialisé le tableau 
au moyen d'un tableau vide.

88
00:04:20,850 --> 00:04:23,017
Voici maintenant une liste non exahaustive

89
00:04:23,017 --> 00:04:25,519
de quelques fonctionnalités typiques
associées aux tableaux.

90
00:04:25,530 --> 00:04:28,261
Nous venons juste de parler 
de la méthode « size »

91
00:04:28,261 --> 00:04:31,090
qui permet de connaître
la taille d'un tableau

92
00:04:31,090 --> 00:04:33,849
et qui le retourne sous la forme d'un entier.

93
00:04:34,427 --> 00:04:37,242
Il existe d'autres méthodes 
comme « get » et « set »

94
00:04:37,242 --> 00:04:39,768
que je vais employer exactement
selon le même principe,

95
00:04:39,768 --> 00:04:43,157
à savoir nom du tableau, point,
suivi du nom de la fonctionnalité

96
00:04:43,157 --> 00:04:46,405
et je constate qu'ici,
contrairement à la méthode « size »,

97
00:04:46,405 --> 00:04:51,029
j'ai besoin de fournir des données
à la méthode « get » ou « set »

98
00:04:51,029 --> 00:04:53,399
pour que celles-ci puissent fonctionner.

99
00:04:54,302 --> 00:04:56,339
Les méthodes « get » et « set » sont l'équivalent

100
00:04:56,339 --> 00:05:00,141
du mécanisme d’indexation
pour les tableaux statiques.

101
00:05:00,141 --> 00:05:03,248
Pour un tableau statique simple,
si je souhaite accéder

102
00:05:03,248 --> 00:05:06,148
à l'élément d'indice 'i'
j'utilise l'indexation ;

103
00:05:06,148 --> 00:05:08,523
ce mécanisme n'existe pas 
pour les tableaux dynamiques ;

104
00:05:08,908 --> 00:05:12,166
à la place il faut avoir recours à 
des méthodes telles « get » ou « set ».

105
00:05:12,166 --> 00:05:14,255
Pour un tableau dynamique,

106
00:05:14,255 --> 00:05:18,629
si je veux accéder à l'élément d'indice 'i',

107
00:05:18,629 --> 00:05:20,332
j'utiliserai cette notation

108
00:05:20,332 --> 00:05:22,445
plutôt que celle-ci.

109
00:05:22,445 --> 00:05:24,897
De même si je veux modifier
un tableau statique

110
00:05:24,897 --> 00:05:27,290
je vais utiliser cette notation,

111
00:05:27,290 --> 00:05:30,167
donc si je veux modifier la i ème case
d'un tableau statique

112
00:05:30,167 --> 00:05:32,110
je vais utiliser cette notation,

113
00:05:32,110 --> 00:05:34,001
ceci n'existe pas 
pour les tableaux dynamiques,

114
00:05:34,001 --> 00:05:37,679
il faudra à la place avoir recours 
à ce type de notation,

115
00:05:37,679 --> 00:05:42,807
donc nom du tableau, point set,
entre parenthèses l'indice de la case

116
00:05:42,807 --> 00:05:46,567
dont je veux modifier le contenu
et la valeur correspondante,

117
00:05:46,567 --> 00:05:50,262
donc cette notation n'existe pas non plus
pour les tableaux dynamiques.

118
00:05:50,782 --> 00:05:52,621
Les restrictions 
sur les bornes de l'indice

119
00:05:52,621 --> 00:05:55,350
restent cependant les mêmes
que pour un tableau de taille fixe,

120
00:05:55,350 --> 00:05:59,875
à savoir l'indice varie entre 0
et taille du tableau -1,

121
00:05:59,875 --> 00:06:02,374
taille du tableau -1 s'écrit
pour un tableau dynamique

122
00:06:02,374 --> 00:06:03,745
comme ceci, par exemple.

123
00:06:03,745 --> 00:06:06,079
Donc, comme pour les tableaux 
de taille fixe,

124
00:06:06,079 --> 00:06:10,293
toute tentative d'accès avec un indice
qui serait en dehors de ces bornes

125
00:06:10,293 --> 00:06:13,569
va se traduire par une erreur 
à l'exécution du programme.

126
00:06:14,706 --> 00:06:17,869
Il est possible de tester
si un tableau dynamique est vide

127
00:06:17,869 --> 00:06:20,679
en utilisant la fonctionnalité « isEmpty ».

128
00:06:21,069 --> 00:06:23,820
C'est une fonctionnalité 
qui n'a pas besoin de données

129
00:06:23,820 --> 00:06:26,201
pour pouvoir fonctionner,
donc elle va nous retourner

130
00:06:26,201 --> 00:06:28,963
une valeur de type booléen, true ou false

131
00:06:28,963 --> 00:06:31,661
dépendamment du fait que le tableau
contienne des valeurs ou pas.

132
00:06:31,661 --> 00:06:36,575
La valeur retournée sera true si
le tableau ne contient aucune valeur

133
00:06:36,575 --> 00:06:39,006
et false dans le cas contraire.

134
00:06:39,807 --> 00:06:43,479
La méthode clear a pour vocation
de vider un tableau dynamique,

135
00:06:43,479 --> 00:06:45,434
ce qui veut dire qu'elle en supprime
tous les éléments,

136
00:06:45,434 --> 00:06:47,118
et elle le transforme en tableau vide ;

137
00:06:47,484 --> 00:06:49,340
si on imagine par exemple
qu'à un moment donné

138
00:06:49,340 --> 00:06:51,356
j'ai dans un programme 
un tableau dynamique

139
00:06:51,356 --> 00:06:53,212
qui est dans cet état de remplissage,

140
00:06:53,212 --> 00:06:55,810
on imagine qu'il s'agit 
d'un tableau d'entiers appelé « tab »,

141
00:06:55,810 --> 00:06:59,039
si j'invoque la fonctionnalité « isEmpty »

142
00:07:00,799 --> 00:07:04,434
il est clair que le résultat sera 
le booléen false

143
00:07:04,444 --> 00:07:05,924
puisque le tableau n'est pas vide.

144
00:07:06,173 --> 00:07:10,079
Maintenant je peux appliquer
la fonctionnalité « .clear() », par exemple,

145
00:07:10,079 --> 00:07:12,536
qui aura pour vocation de 
supprimer tous les éléments

146
00:07:12,536 --> 00:07:16,292
et de le transformer en tableau vide,
il n'y a plus d'élément à l'intérieur,

147
00:07:16,292 --> 00:07:21,865
donc si à nouveau j'appelle
ma fonctionnalité « isEmpty »

148
00:07:21,865 --> 00:07:25,472
cette fois-ci le résultat sera true
puisque le tableau est désormais vide.

149
00:07:27,350 --> 00:07:29,496
La méthode « remove » permet de supprimer

150
00:07:29,496 --> 00:07:32,052
l'élément d'indice i 
dans un tableau dynamique ;

151
00:07:32,052 --> 00:07:34,429
donc si on imagine par exemple
qu'à un moment donné

152
00:07:34,429 --> 00:07:37,844
nous ayons un tableau dynamique 
d'entiers à trois cases

153
00:07:37,844 --> 00:07:39,729
qui ait cette allure particulière,

154
00:07:39,729 --> 00:07:43,471
les indices varient entre 0 et taille -1
ce qui nous donne ceci,

155
00:07:43,471 --> 00:07:45,743
supposons que le tableau s'appelle « tab »

156
00:07:45,743 --> 00:07:50,083
si maintenant j'appelle la fonctionnalité
« size » sur ce tableau,

157
00:07:50,083 --> 00:07:53,220
le retour sera 3 puisque 
mon tableau contient trois cases ;

158
00:07:53,220 --> 00:07:56,755
si maintenant j'appelle 
la méthode « remove »

159
00:07:56,755 --> 00:07:58,535
en lui passant pour indice 1

160
00:07:58,535 --> 00:08:00,616
c'est cet élément qui doit être supprimé

161
00:08:00,616 --> 00:08:01,896
donc tous les éléments

162
00:08:01,896 --> 00:08:05,899
qui viennent à la suite de cet élément
vont être décalés vers la gauche

163
00:08:05,899 --> 00:08:10,319
et au final je vais aboutir 
à un tableau à deux cases,

164
00:08:11,579 --> 00:08:15,066
et si j'applique 
ma fonctionnalité « tab.size() »

165
00:08:15,066 --> 00:08:17,382
le retour sera évidemment 2 ;

166
00:08:17,884 --> 00:08:19,865
on voit ici que pour un tableau dynamique

167
00:08:19,865 --> 00:08:22,865
la taille peut effectivement varier
en cours d'exécution

168
00:08:22,865 --> 00:08:26,072
au gré des appels à des méthodes
de cette nature là.

169
00:08:26,873 --> 00:08:29,273
L'indice de l'élément qu'on veut supprimer

170
00:08:29,273 --> 00:08:31,473
doit bien évidemment 
exister dans le tableau

171
00:08:31,473 --> 00:08:33,773
au moment où on invoque
la fonctionnalité « remove ».

172
00:08:34,121 --> 00:08:39,085
Supposons par exemple qu'au lieu 
de faire un « tab.remove(1) »

173
00:08:39,085 --> 00:08:42,104
j'essaie de faire un « tab.remove(4) »

174
00:08:42,104 --> 00:08:45,332
ceci se traduira par une erreur
à l'exécution du programme.

175
00:08:46,408 --> 00:08:49,826
S'il est possible de supprimer 
des éléments d'un tableau dynamique,

176
00:08:49,826 --> 00:08:52,979
il est aussi possible d'ajouter
des valeurs dans un tel tableau,

177
00:08:52,979 --> 00:08:55,547
pour ceci on va utiliser la méthode « add »

178
00:08:55,547 --> 00:08:58,219
et il faudra fournir la valeur
que l'on souhaite ajouter au tableau,

179
00:08:58,219 --> 00:09:01,873
la valeur sera systématiquement
ajoutée à la fin du tableau.

180
00:09:01,873 --> 00:09:06,270
Prenons un exemple concret 
d'un tableau d'entiers,

181
00:09:07,460 --> 00:09:12,500
donc ici « tab.size() » retourne 3

182
00:09:12,500 --> 00:09:17,996
j'ajoute à mon tableau la valeur 8
en utilisant la méthode « add »

183
00:09:18,416 --> 00:09:23,036
le résultat sera un tableau
avec une case supplémentaire

184
00:09:23,036 --> 00:09:26,943
cette case est à la fin donc 
j'aurai ceci dans tab

185
00:09:26,943 --> 00:09:32,819
et évidemment « tab.size »
me retourne cette fois 4,

186
00:09:32,819 --> 00:09:36,173
on voit que mon tableau
a grandi d'une case.

187
00:09:36,610 --> 00:09:40,396
Voici maintenant un exemple
avec quelques manipulations de base

188
00:09:40,396 --> 00:09:43,303
que l'on peut classiquement faire
sur un tableau dynamique

189
00:09:43,303 --> 00:09:46,458
donc nous avons vu que pour pouvoir
utiliser le type « ArrayList »

190
00:09:46,458 --> 00:09:49,059
il était nécessaire 
de commencer le fichier

191
00:09:49,059 --> 00:09:50,680
par une directive d'importation

192
00:09:50,680 --> 00:09:52,791
qui aura pour vocation
de rendre accessible

193
00:09:52,791 --> 00:09:55,056
le type ArrayList dans le programme.

194
00:09:55,056 --> 00:09:57,724
Je peux désormais utiliser 
le type « ArrayList »

195
00:09:57,724 --> 00:09:59,742
pour déclarer une variable

196
00:09:59,742 --> 00:10:01,712
et ici je suis en train de déclarer 
une variable

197
00:10:01,712 --> 00:10:04,531
de type tableau dynamique
de chaîne de caractères.

198
00:10:04,531 --> 00:10:06,213
Nous avons également vu

199
00:10:06,213 --> 00:10:08,295
que pour initialiser le tableau 
à un tableau vide,

200
00:10:08,295 --> 00:10:10,267
il faut utiliser ce genre de tournure,

201
00:10:10,267 --> 00:10:12,601
donc à la fin de l'exécution 
de cette instruction

202
00:10:12,601 --> 00:10:16,130
j'obtiens en liste la référence 
à un tableau dynamique vide ;

203
00:10:16,500 --> 00:10:18,958
j'exécute ensuite l'instruction suivante

204
00:10:20,528 --> 00:10:24,344
j'appelle la méthode « add » qui me permet
d'ajouter un élément particulier,

205
00:10:24,344 --> 00:10:28,313
donc ici la chaîne de caractères "un" 
en fin de tableau dynamique,

206
00:10:28,313 --> 00:10:31,287
comme le tableau est vide, 
ça ne fait pas beaucoup de différence,

207
00:10:31,287 --> 00:10:35,565
je vais avoir au final un tableau 
dynamique liste qui aura cette allure.

208
00:10:35,565 --> 00:10:39,687
J'exécute l'instruction suivante
qui ajoute une chaîne de caractères

209
00:10:39,687 --> 00:10:42,160
la chaîne de caractères "deux"
en fin de tableau

210
00:10:42,160 --> 00:10:46,641
donc ici je vais obtenir
le contenu suivant.

211
00:10:48,901 --> 00:10:52,436
Si je veux faire afficher le contenu
de mon tableau dynamique à ce stade,

212
00:10:52,445 --> 00:10:55,485
j'utilise une « boucle for ».
Nous avons vu que nous pouvions utiliser

213
00:10:55,485 --> 00:11:00,059
par exemple une « boucle for » itérant
sur un ensemble de valeurs.

214
00:11:00,059 --> 00:11:03,783
Ici ma « boucle for » va prendre en séquence
chacun des éléments de la liste

215
00:11:03,783 --> 00:11:07,330
et les imprimer en les séparant
par un espace.

216
00:11:07,330 --> 00:11:11,177
Donc ici l'affichage obtenu au terme
de l'exécution de cette instruction

217
00:11:11,177 --> 00:11:15,541
va être la chaîne "un" séparée 
par un espace de la chaîne "deux"

218
00:11:15,541 --> 00:11:18,246
qui vont s'afficher 
de cette manière à l'écran.

219
00:11:19,376 --> 00:11:22,682
Si je souhaite accéder à la i-ème case
d'un tableau dynamique

220
00:11:22,712 --> 00:11:25,583
soit pour consulter son contenu,
soit pour le modifier,

221
00:11:25,583 --> 00:11:27,775
je devrais utiliser les méthodes « get » et « set ».

222
00:11:27,775 --> 00:11:30,006
Donc si j'exécute cette instruction,

223
00:11:30,006 --> 00:11:33,217
sachant qu'à ce stade le remplissage
du tableau est celui-ci,

224
00:11:33,217 --> 00:11:35,727
je vais utiliser la méthode « get »

225
00:11:35,727 --> 00:11:39,365
qui va accéder à l'élément 
d'indice 1 dans le tableau,

226
00:11:39,365 --> 00:11:44,418
cet élément d'indice 1 
est la chaîne de caractères "deux"

227
00:11:44,418 --> 00:11:48,510
et à ce moment là je vais afficher 
la chaîne de caractères "deux".

228
00:11:50,480 --> 00:11:53,361
Lorsque j'exécute l'instruction suivante

229
00:11:53,363 --> 00:11:56,387
je vais modifier l'élément 
qui se trouve à l'indice 0

230
00:11:56,387 --> 00:12:00,520
pour faire en sorte que sa nouvelle valeur
soit la chaîne de caractères "premier".

231
00:12:00,520 --> 00:12:08,438
Donc mon tableau va désormais
ressembler à ceci,

232
00:12:09,768 --> 00:12:12,776
après l'exécution de cette instruction.

233
00:12:16,376 --> 00:12:21,924
L'élément d'indice 0 qui était "un"
a désormais été changé en "premier".

234
00:12:23,472 --> 00:12:26,085
Dans tous les exemples de tableaux 
dynamiques montrés jusqu'ici

235
00:12:26,085 --> 00:12:27,883
le contenu était de type
chaîne de caractères

236
00:12:27,883 --> 00:12:29,869
c'est évidemment un choix délibéré

237
00:12:29,869 --> 00:12:33,839
qui répondait à la contrainte que
le contenu d'un tableau dynamique en Java

238
00:12:33,839 --> 00:12:36,561
doit systématiquement 
être de type évolué.

239
00:12:36,561 --> 00:12:39,305
Il peut cependant se trouver 
que l'on ait besoin

240
00:12:39,305 --> 00:12:42,267
de travailler avec des tableaux 
dynamiques d'entiers de tables.

241
00:12:42,267 --> 00:12:43,918
Comment procéder ?

242
00:12:44,378 --> 00:12:46,080
xCe qu'il suffit de savoir à ce stade

243
00:12:46,080 --> 00:12:48,909
c'est que Java offre 
pour chaque type de base

244
00:12:48,909 --> 00:12:51,738
un type évolué correspondant.
Par exemple pour le type « int »

245
00:12:51,738 --> 00:12:54,569
vous disposez du type 
« Integer », avec un « grand I »

246
00:12:54,572 --> 00:12:56,817
qui est équivalent 
et qui est de type évolué.

247
00:12:56,817 --> 00:12:58,828
De même pour le type « double »

248
00:12:58,828 --> 00:13:01,506
vous allez avoir un équivalent « Double »,
avec un « grand D »

249
00:13:01,506 --> 00:13:04,837
et ceci est valable 
pour chaque type de base.

250
00:13:05,717 --> 00:13:07,833
Ces types évolués d'un genre particulier

251
00:13:07,833 --> 00:13:10,399
s'avèrent particulièrement utiles
dans certains contextes

252
00:13:10,399 --> 00:13:12,210
typiquement pour les « ArrayList ».

253
00:13:12,210 --> 00:13:13,244
Pourquoi ?

254
00:13:13,244 --> 00:13:15,249
Parce que nous avons vu 
que dans un « Arraylist »

255
00:13:15,249 --> 00:13:19,381
il n'était possible de stocker 
que des valeurs de type évolué.

256
00:13:19,381 --> 00:13:22,198
Je ne peux ainsi jamais déclarer
dans un programme Java

257
00:13:22,198 --> 00:13:24,763
un « ArrayList double », avec un petit d,
ou un « ArrayList int ».

258
00:13:26,480 --> 00:13:30,297
Par contre je peux tout à fait
déclarer un « ArrayList » de « Integer ».

259
00:13:30,547 --> 00:13:32,907
Une fois la déclaration du tableau faite

260
00:13:32,907 --> 00:13:35,619
en respectant la contrainte que
le contenu est de type évolué,

261
00:13:35,619 --> 00:13:37,613
je peux ensuite tout à fait mettre

262
00:13:37,613 --> 00:13:39,947
des valeurs de type élémentaire 
dans mon tableau

263
00:13:39,947 --> 00:13:41,603
pour une raison très simple,

264
00:13:41,603 --> 00:13:44,415
c'est que la conversion 
de types de base en types évolués,

265
00:13:44,415 --> 00:13:46,807
peut alors se faire automatiquement.

266
00:13:46,807 --> 00:13:49,099
Ce n'était pas le cas 
dans les premières versions de Java

267
00:13:49,099 --> 00:13:50,834
mais c'est désormais
comme ça que cela fonctionne

268
00:13:50,834 --> 00:13:52,943
et je peux ainsi travailler
avec des tableaux

269
00:13:52,943 --> 00:13:55,052
dynamiques d'entiers ou double

270
00:13:55,052 --> 00:13:57,163
en étant presque affranchi 
de la contrainte

271
00:13:57,163 --> 00:13:59,762
de l'utilisation des types évolués.

272
00:13:59,762 --> 00:14:02,181
Voyons ça maintenant sur un exemple concret

273
00:14:03,082 --> 00:14:04,669
Nous souhaitons ici 
écrire un petit programme

274
00:14:04,669 --> 00:14:06,971
qui remplit un tableau dynamique d'entiers

275
00:14:06,971 --> 00:14:09,751
au moyen de nombres strictement positifs.

276
00:14:09,751 --> 00:14:12,941
On suppose que les valeurs
vont être demandées à l'utilisateur

277
00:14:12,962 --> 00:14:15,755
et nous souhaitons également adhérer
à un certain nombre de conventions

278
00:14:15,755 --> 00:14:20,361
si l'utilisateur introduit la valeur 0
ce sera pour nous la convention

279
00:14:20,361 --> 00:14:23,430
que l'on souhaite recommencer 
le remplissage depuis le début

280
00:14:23,430 --> 00:14:26,905
et si l'utilisateur introduit 
un nombre négatif

281
00:14:26,905 --> 00:14:30,678
ce sera pour nous la convention 
que l'on souhaite effacer

282
00:14:30,678 --> 00:14:33,272
le dernier élément 
introduit dans le tableau.

283
00:14:33,772 --> 00:14:36,727
Le déroulement du programme 
pourrait avoir l'allure suivante

284
00:14:36,727 --> 00:14:38,734
donc on va demander à l'utilisateur

285
00:14:38,734 --> 00:14:40,954
de saisir trois valeurs
strictement positives,

286
00:14:40,954 --> 00:14:43,123
et on va lui demander chacune 
de ces valeurs en séquence,

287
00:14:43,123 --> 00:14:46,628
ici on lui demande d'introduire
la valeur d'indice 0

288
00:14:46,628 --> 00:14:48,410
et on suppose qu'il a introduit 5,

289
00:14:48,410 --> 00:14:50,342
cette valeur étant strictement positive,

290
00:14:50,342 --> 00:14:52,783
on va la stocker dans le tableau.

291
00:14:53,373 --> 00:14:56,409
On lui demande ensuite 
la seconde valeur, celle d'indice 1,

292
00:14:56,409 --> 00:14:58,687
cette valeur est strictement positive,

293
00:14:58,687 --> 00:15:00,915
on va l'introduire
à nouveau dans le tableau.

294
00:15:02,345 --> 00:15:04,455
Ensuite on lui demande d'introduire 
la dernière valeur,

295
00:15:04,455 --> 00:15:07,458
la valeur d'indice 2, mais il se trouve 
que l'utilisateur entre un 0

296
00:15:07,458 --> 00:15:11,825
ce qui correspond à la convention
recommencer depuis le début,

297
00:15:11,825 --> 00:15:13,784
ce qui veut dire qu'à ce stade,

298
00:15:13,784 --> 00:15:16,040
on veut faire en sorte 
que le tableau se vide à nouveau ;

299
00:15:16,040 --> 00:15:18,402
donc puisque le tableau s'est vidé
la prochaine valeur

300
00:15:18,402 --> 00:15:21,744
qu'on va demander à l'utilisateur, 
c'est de nouveau la valeur d'indice 0,

301
00:15:21,744 --> 00:15:27,631
ici l'utilisateur introduit un 7,
nous allons donc avoir ce tableau

302
00:15:27,631 --> 00:15:32,118
il introduit ensuite un 2
nous allons avoir ce tableau.

303
00:15:32,678 --> 00:15:36,141
Ensuite il introduit pour 
la dernière valeur de nouveau,

304
00:15:37,621 --> 00:15:40,614
une valeur négative
ce qui correspond pour nous

305
00:15:40,614 --> 00:15:44,049
à la seconde convention,
celle d'effacer le dernier élément.

306
00:15:44,049 --> 00:15:46,341
Le dernier élément introduit est le 2

307
00:15:46,341 --> 00:15:50,800
donc nous souhaitons faire en sorte 
que désormais le tableau soit ceci,

308
00:15:50,800 --> 00:15:53,225
et c'est pourquoi à la prochaine étape,

309
00:15:53,225 --> 00:15:57,029
on va demander à l'utilisateur 
d'introduire la seconde valeur

310
00:15:57,029 --> 00:16:00,326
puisque le tableau ne contient 
désormais qu'une seule valeur.

311
00:16:00,616 --> 00:16:03,070
A ce moment là l'utilisateur entre un 4,

312
00:16:03,070 --> 00:16:04,964
que nous allons stocker
dans le tableau,

313
00:16:06,164 --> 00:16:08,939
il introduit ensuite 
en dernière instance un 12

314
00:16:08,939 --> 00:16:11,211
et nous allons avoir ce tableau.

315
00:16:12,941 --> 00:16:15,551
Puisque nous avons bien
les trois valeurs souhaitées,

316
00:16:15,551 --> 00:16:19,831
nous avons construit notre tableau
tel que nous l'avons souhaité

317
00:16:19,831 --> 00:16:24,180
et nous allons au final aboutir 
à un tableau qui contient 7, 4 et 12,

318
00:16:24,180 --> 00:16:26,333
qui sont des valeurs
strictement positives.

319
00:16:27,213 --> 00:16:31,265
Nous voyons ici que tout au long 
de l'exécution de ce programme,

320
00:16:31,265 --> 00:16:34,706
la taille de notre tableau croît et 
décroît au gré de nos besoins.

321
00:16:34,706 --> 00:16:36,600
Donc c'est typiquement un cas

322
00:16:36,600 --> 00:16:39,866
où l'utilisation d'un tableau dynamique
est particulièrement adaptée.

323
00:16:40,486 --> 00:16:42,345
Voyons maintenant 
comme tout cela se traduit

324
00:16:42,345 --> 00:16:44,770
sous la forme d'un programme Java.

325
00:16:46,550 --> 00:16:48,559
Les traitements montrés
dans l'exemple précédent

326
00:16:48,559 --> 00:16:50,211
peuvent être mis en oeuvre au moyen

327
00:16:50,211 --> 00:16:52,193
d'un petit programme Java
ayant cette allure.

328
00:16:52,303 --> 00:16:55,835
Nous commençons par déclarer 
un tableau dynamique d'entiers,

329
00:16:55,835 --> 00:16:59,216
comme nous ne pouvons pas créer 
de « ArrayList » de type « int »,

330
00:16:59,216 --> 00:17:02,519
de type élémentaire,
nous utilisons le type « Integer » ;

331
00:17:02,519 --> 00:17:05,049
notre tableau dynamique s'appelle « vect »

332
00:17:05,049 --> 00:17:08,160
et il est initialisé comme
un tableau dynamique vide

333
00:17:08,173 --> 00:17:11,258
donc au final la variable « vect » contiendra

334
00:17:11,258 --> 00:17:14,382
la référence à un tableau 
dynamique vide d'entiers.

335
00:17:15,742 --> 00:17:17,591
Nous demandons ensuite à l'utilisateur

336
00:17:17,591 --> 00:17:20,005
combien de valeurs il veut 
introduire dans son tableau

337
00:17:20,005 --> 00:17:23,354
et nous saisissons la taille voulue
par l'utilisateur pour le tableau

338
00:17:23,354 --> 00:17:25,239
au moyen d'une interaction clavier ;

339
00:17:25,869 --> 00:17:27,595
nous demandons ensuite à l'utilisateur

340
00:17:27,595 --> 00:17:30,391
de saisir les différentes valeurs
pour remplir le tableau

341
00:17:30,391 --> 00:17:32,524
et donc pour cela 
nous allons utiliser une boucle

342
00:17:32,524 --> 00:17:34,720
puisqu'il va introduire 
potentiellement plusieurs valeurs.

343
00:17:35,250 --> 00:17:36,693
La boucle est telle que

344
00:17:36,693 --> 00:17:39,776
tant que la taille actuelle du tableau 
n'a pas atteint la taille voulue

345
00:17:40,026 --> 00:17:42,036
alors nous continuons à boucler.

346
00:17:43,166 --> 00:17:44,711
A chaque itération de la boucle

347
00:17:44,711 --> 00:17:48,194
nous allons demander à l'utilisateur
de saisir une des valeurs du tableau.

348
00:17:48,194 --> 00:17:49,845
Mais quelle valeur précisément ?

349
00:17:50,115 --> 00:17:52,346
Donc ici nous voulons
indiquer à l'utilisateur

350
00:17:52,346 --> 00:17:54,471
l'indice de la valeur à saisir.

351
00:17:54,471 --> 00:17:58,051
Supposons que l'état de remplissage
du tableau soit le suivant.

352
00:17:59,981 --> 00:18:01,285
Donc à ce moment là

353
00:18:01,915 --> 00:18:05,659
« vect.size() » vaut 2

354
00:18:06,989 --> 00:18:08,773
et le dernier élément

355
00:18:09,743 --> 00:18:10,889
a pour indice 1

356
00:18:12,909 --> 00:18:16,679
c'est-à-dire « vect.size() - 1 »,

357
00:18:17,579 --> 00:18:22,627
c'est-à-dire que la prochaine valeur
du tableau que nous voulons saisir

358
00:18:22,627 --> 00:18:26,007
a bien pour indice « vect.size() »

359
00:18:26,007 --> 00:18:28,028
et c'est ce que nous retrouvons ici.

360
00:18:28,028 --> 00:18:32,487
Nous allons demander à l'utilisateur
d'entrer la valeur

361
00:18:32,487 --> 00:18:37,377
qui est à la position « vect.size() »
qui va occuper la position « vect.size() ».

362
00:18:38,303 --> 00:18:42,036
La valeur à mettre dans le tableau
est à nouveau saisie

363
00:18:42,036 --> 00:18:43,489
via une interaction clavier.

364
00:18:43,489 --> 00:18:46,488
et c'est à ce moment que l'on commence
à tester les différents cas

365
00:18:46,488 --> 00:18:49,071
pour adhérer aux différentes
conventions exposées

366
00:18:49,071 --> 00:18:51,141
dans l'exemple de déroulement précédent.

367
00:18:51,901 --> 00:18:54,039
Une des conventions que 
nous voulions mettre en oeuvre

368
00:18:54,039 --> 00:18:58,066
est que si la valeur introduite
par l'utilisateur est négative

369
00:18:58,066 --> 00:19:00,617
cela voudrait dire que 
nous voulons supprimer

370
00:19:00,617 --> 00:19:03,550
le dernier élément introduit
dans le tableau.

371
00:19:03,550 --> 00:19:06,849
Donc concrètement,
nous allons utiliser la méthode « remove »

372
00:19:06,849 --> 00:19:08,867
pour réaliser cette suppression.

373
00:19:09,957 --> 00:19:14,088
Et à ce moment là il faudrait supprimer
le dernier élément du tableau,

374
00:19:14,088 --> 00:19:16,557
l'élément d'indice
« vect.size() - 1 »

375
00:19:16,557 --> 00:19:18,571
tel que nous l'avons vu ici.

376
00:19:19,431 --> 00:19:21,342
Cela étant, il faut prendre une précaution

377
00:19:21,342 --> 00:19:24,095
nous ne pouvons procéder
à cette suppression

378
00:19:24,095 --> 00:19:26,539
que si le tableau dynamique
n'est pas vide,

379
00:19:26,539 --> 00:19:28,726
et donc nous devons
combiner ce premier test

380
00:19:28,726 --> 00:19:30,157
avec un second test

381
00:19:30,607 --> 00:19:33,555
qui va tester si le vecteur,
le tableau dynamique,

382
00:19:33,555 --> 00:19:38,208
est vide ou non, donc nous n'allons
procéder à la suppression

383
00:19:38,208 --> 00:19:42,842
que si la valeur est négative,
et que le tableau n'est pas vide.

384
00:19:43,342 --> 00:19:46,417
Le fait qu'il soit vide est testé avec
la fonctionnalité « isEmpty »

385
00:19:46,417 --> 00:19:50,584
le fait qu'il ne soit pas vide est
exprimé avec la négation ici.

386
00:19:51,994 --> 00:19:54,581
Si la condition exprimée ici
n'est pas vérifiée

387
00:19:54,581 --> 00:19:56,603
nous devons procéder ensuite
à d'autres tests

388
00:19:56,603 --> 00:19:58,728
nous avions vu que nous voulions
adhérer à la convention

389
00:19:58,728 --> 00:20:01,202
que si l'utilisateur introduit la valeur 0,

390
00:20:01,422 --> 00:20:03,511
cela signifie que nous voulons
vider le tableau

391
00:20:03,511 --> 00:20:06,854
donc nous procédons
à un test alternatif ici.

392
00:20:06,854 --> 00:20:09,656
Le fait de vider complètement
un tableau dynamique

393
00:20:09,656 --> 00:20:12,618
se fait au moyen de
la fonctionnalité « clear »

394
00:20:12,898 --> 00:20:14,200
donc ici simplement,

395
00:20:14,550 --> 00:20:18,071
si la valeur introduite
par l'utilisateur est nulle,

396
00:20:18,311 --> 00:20:21,119
alors on vide complètement le tableau.

397
00:20:22,399 --> 00:20:24,752
Sinon, si nous atteignons
ce stade de l'execution

398
00:20:24,752 --> 00:20:26,770
cela signifie que soit
la valeur introduite

399
00:20:26,770 --> 00:20:28,841
est strictement positive,
soit le vecteur est nul.

400
00:20:29,101 --> 00:20:30,867
Il n'est donc pas strictement garanti

401
00:20:30,867 --> 00:20:32,682
que la valeur introduite
soit positive,

402
00:20:32,682 --> 00:20:35,558
il faut donc le retester,
c'est ce que nous faisons ici.

403
00:20:36,058 --> 00:20:38,341
Si c'est le cas,
si la condition est vérifiée

404
00:20:38,341 --> 00:20:41,499
nous pouvons alors ajouter la valeur
à notre tableau dynamique

405
00:20:41,499 --> 00:20:44,655
et ceci se fait au moyen
de la fonctionnalité « add ».

406
00:20:45,355 --> 00:20:47,481
Donc nous allons itérer ces traitements

407
00:20:47,481 --> 00:20:50,086
tant que le tableau dynamique

408
00:20:50,086 --> 00:20:52,918
n'a pas atteint la taille
souhaitée par l'utilisateur.

409
00:20:53,668 --> 00:20:55,708
Remarquons ici un point assez important.

410
00:20:55,708 --> 00:20:58,626
Nous avons construit notre tableau
nous l'avons déclaré

411
00:20:58,626 --> 00:21:01,137
en utilisant le type évolué « Integer »

412
00:21:01,137 --> 00:21:03,572
ceci signifie que dans notre tableau

413
00:21:03,572 --> 00:21:06,745
nous n'avons pas directement
des valeurs entières

414
00:21:06,745 --> 00:21:08,287
comme ceci,

415
00:21:08,617 --> 00:21:10,294
et comme je l'ai montré
très schématiquement

416
00:21:10,294 --> 00:21:11,862
dans le déroulement de l'exemple,

417
00:21:11,862 --> 00:21:14,519
mais pour être tout à fait exacte
nous avons dans le tableau

418
00:21:14,519 --> 00:21:17,717
des références vers des entiers.

419
00:21:17,717 --> 00:21:20,489
Donc ici la situation serait la suivante :

420
00:21:20,489 --> 00:21:23,168
à la position 0
nous aurions une référence

421
00:21:23,168 --> 00:21:27,941
vers une zone mémoire contenant 12
et non pas directement la valeur 12.

422
00:21:28,791 --> 00:21:33,077
Comment se fait-il dans ce cas
que nous ayons pu introduire

423
00:21:33,077 --> 00:21:35,639
une valeur de type « int » dans le tableau

424
00:21:35,639 --> 00:21:37,214
comme nous avons fait ici.

425
00:21:38,684 --> 00:21:41,105
En effet puisque notre
tableau a été déclaré

426
00:21:41,105 --> 00:21:42,998
comme contenant des « Integers »

427
00:21:42,998 --> 00:21:45,977
nous nous attendons à ne 
pouvoir ajouter à ce tableau

428
00:21:45,977 --> 00:21:47,998
que des valeurs strictement
du même type

429
00:21:47,998 --> 00:21:52,027
et donc pas directement un entier
mais une référence vers un entier,

430
00:21:52,027 --> 00:21:55,741
ce que pour l'heure nous ne savons
pas construire ou initialiser.

431
00:21:55,741 --> 00:21:58,507
Nous avons cependant pu
introduire directement un « int »

432
00:21:59,037 --> 00:22:02,581
Alors ceci est permis grâce
à la conversion automatique

433
00:22:02,581 --> 00:22:05,483
qui se fait entre
les types de base

434
00:22:06,193 --> 00:22:08,082
et les types évolués correspondants.

435
00:22:08,082 --> 00:22:11,492
Donc en réalité lorsque 
nous exécutons cette instruction

436
00:22:11,492 --> 00:22:15,436
ce que nous introduisons dans le tableau
n'est pas directement la valeur « val »

437
00:22:15,436 --> 00:22:18,556
introduite par l'utilisateur,
qui elle est de type « int »,

438
00:22:18,976 --> 00:22:20,939
mais nous introduisons dans le tableau

439
00:22:20,939 --> 00:22:24,383
un « Integer » qui est une référence
vers la valeur « val »

440
00:22:24,383 --> 00:22:27,933
et tout ceci se fait de façon
complétement automatique et transparente,

441
00:22:27,933 --> 00:22:30,870
nous n'avons pas à nous
préoccuper de cette conversion.

442
00:22:31,500 --> 00:22:33,448
Donc grace à cette conversion automatique,

443
00:22:33,448 --> 00:22:37,187
il devient complètement naturel
de pouvoir travailler également

444
00:22:37,517 --> 00:22:42,183
avec des tableaux dynamiques d'entiers,
de « doubles » ou de type de base;

445
00:22:42,183 --> 00:22:45,255
la seule précaution qu'il est
indispensable de prendre

446
00:22:45,255 --> 00:22:48,023
est que, au moment
de la déclaration du tableau,

447
00:22:48,023 --> 00:22:52,172
il faut absolument le déclarer
en utilisant le type évolué correspondant.

448
00:22:53,562 --> 00:22:56,102
Cette conversion automatique
entre un type de base

449
00:22:56,102 --> 00:22:58,141
et un type évolué correspondant,

450
00:22:58,141 --> 00:23:02,160
est ce que l'on appelle
en termes techniques « l'autoboxing ».

451
00:23:04,570 --> 00:23:06,930
Nous avons vu qu'un « ArrayList »
ne peut contenir

452
00:23:06,930 --> 00:23:08,780
que des éléments de type évolué,

453
00:23:08,780 --> 00:23:12,108
examinons pour finir l'incidence
que cela a sur la comparaison

454
00:23:12,108 --> 00:23:14,077
des éléments d'un tel tableau.

455
00:23:14,077 --> 00:23:15,707
A la première instruction

456
00:23:15,707 --> 00:23:18,855
je vais avoir la conversion automatique
d'une valeur de type de base

457
00:23:18,855 --> 00:23:20,858
en une valeur de type « Integer »,

458
00:23:20,858 --> 00:23:24,613
mais ce que je vais en réalité
ajouter dans mon tableau dynamique

459
00:23:24,613 --> 00:23:26,870
ça n'est pas directement
la valeur 2000

460
00:23:26,870 --> 00:23:29,254
mais une référence vers cette valeur.

461
00:23:29,254 --> 00:23:31,588
Donc je me trouve dans
une situation en mémoire

462
00:23:31,588 --> 00:23:33,211
qui est la suivante.

463
00:23:34,901 --> 00:23:38,815
Ici j'ai stocké dans mon tableau
non pas directement la valeur 2000

464
00:23:38,815 --> 00:23:40,319
mais son adresse.

465
00:23:41,679 --> 00:23:44,093
Donc lorsque j'exécute
la seconde instruction

466
00:23:44,093 --> 00:23:46,268
c'est exactement 
la même situation

467
00:23:47,358 --> 00:23:48,788
qui se produit,

468
00:23:48,788 --> 00:23:51,287
sauf qu'à ce moment j'ai 2 références.

469
00:23:51,547 --> 00:23:54,778
Il se trouve que ces références
ont un contenu similaire,

470
00:23:59,218 --> 00:24:01,530
mais elles ont été créées
par deux « add » distinctes

471
00:24:01,530 --> 00:24:05,978
et à ce moment là, il s'agit bien de deux
zones mémoire distinctes, différentes.

472
00:24:05,978 --> 00:24:11,127
Donc ici, si je souhaite comparer le
contenu de la première entrée du tableau

473
00:24:11,527 --> 00:24:14,955
avec la seconde,
par une tournure de cette nature là,

474
00:24:15,285 --> 00:24:18,181
le résultat de l'exécution
de cette instruction

475
00:24:18,181 --> 00:24:21,522
va être en réalité fausse.

476
00:24:22,122 --> 00:24:23,935
Pourquoi ? Parce que j'ai
bel et bien à faire

477
00:24:23,935 --> 00:24:25,718
à 2 zones mémoire distinctes,

478
00:24:25,718 --> 00:24:27,517
et donc il ne s'agit pas
du même emplacement

479
00:24:27,517 --> 00:24:29,849
et la comparaison va retourner fausse.

480
00:24:29,849 --> 00:24:32,780
S'il m'intéressait de
comparer plutôt les contenus

481
00:24:32,780 --> 00:24:35,929
alors comme pour les chaines
de caractères je ne dois pas recourir

482
00:24:35,929 --> 00:24:38,666
à un test d'égalité avec « == »

483
00:24:38,666 --> 00:24:42,154
mais plutôt avoir recours au
un test d'égalité avec « equals »

484
00:24:42,534 --> 00:24:45,887
donc on accède au premier élément
du tableau qui est un « Integer »

485
00:24:45,887 --> 00:24:50,282
et on applique sur cet élément
la méthode « equals » pour le comparer

486
00:24:51,422 --> 00:24:52,962
au second élément du tableau.

487
00:24:52,962 --> 00:24:56,265
Et ici, le résultat de l'exécution
de cette instruction

488
00:24:56,265 --> 00:24:59,598
sera bel et bien « true »
car les valeurs sont identiques.

489
00:24:59,598 --> 00:25:03,017
Les valeurs pointées par
les références sont identiques.
