1
00:00:03,010 --> 00:00:05,208
In a previous episode we studied

2
00:00:05,208 --> 00:00:07,558
fixed-size arrays in Java.

3
00:00:07,558 --> 00:00:09,268
We saw that for this type
of arrays,

4
00:00:09,268 --> 00:00:12,258
once the size is set when we
initialize the array,

5
00:00:12,258 --> 00:00:15,605
it isn't possible to modify it anymore
when the program executes.

6
00:00:15,605 --> 00:00:18,263
Today we'll study dynamic
arrays,

7
00:00:18,263 --> 00:00:20,316
which will free us from
this constraint.

8
00:00:20,616 --> 00:00:23,583
Dynamic arrays have the particularity
to be able to increase

9
00:00:23,583 --> 00:00:26,404
or decrease their size while
the program executes.

10
00:00:26,404 --> 00:00:30,196
Their use requires a number
of concepts

11
00:00:30,196 --> 00:00:31,861
related to object-oriented
programing.

12
00:00:31,951 --> 00:00:33,936
However, as with character strings,

13
00:00:33,936 --> 00:00:36,411
it isn't necessary to have any
preliminary knowledge

14
00:00:36,411 --> 00:00:38,388
of these concepts to be able
to use

15
00:00:38,388 --> 00:00:40,513
their functionalities.

16
00:00:40,663 --> 00:00:43,688
We decided to present them very early
in the context of this course,

17
00:00:43,688 --> 00:00:46,664
because dynamic arrays can be used
in very natural manners

18
00:00:46,664 --> 00:00:48,952
to resolve many problems

19
00:00:48,952 --> 00:00:51,386
that aren't necessarily related to
object-oriented programming.

20
00:00:52,062 --> 00:00:53,544
As with fixed-size arrays,

21
00:00:53,544 --> 00:00:56,916
dynamic arrays are a collection of
homogeneous data.

22
00:00:56,916 --> 00:00:58,668
To use them,

23
00:00:58,668 --> 00:01:01,230
we use a particular predefined type
in Java

24
00:01:01,230 --> 00:01:05,557
called ArrayList. This type isn't
defined by default.

25
00:01:05,557 --> 00:01:09,687
To use it in a program, you must include,
at the beginning of the file,

26
00:01:09,687 --> 00:01:15,194
an import directive that will make
the ArrayList type accessible.

27
00:01:17,324 --> 00:01:20,658
In Java, we can declare a variable
of ArrayList type

28
00:01:20,658 --> 00:01:22,889
by using the following
syntax:

29
00:01:22,889 --> 00:01:26,117
we put the variable name, and
as type,

30
00:01:26,117 --> 00:01:28,637
we put the reserved name
"ArrayList",

31
00:01:28,637 --> 00:01:33,575
followed by two characters "less than"
and "greater than".

32
00:01:33,575 --> 00:01:36,473
Between these two characters, we
put the type of data

33
00:01:36,473 --> 00:01:38,671
we want to put in the array.

34
00:01:39,061 --> 00:01:42,270
Note that the type must imperatively
be an advanced type.

35
00:01:42,433 --> 00:01:44,449
Here's a concrete example:

36
00:01:44,449 --> 00:01:47,995
here we declare a variable
"tableau" [TN: means "array"],

37
00:01:47,995 --> 00:01:54,005
the type of this variable is a dynamic
array of strings.

38
00:01:55,034 --> 00:01:58,515
Note that the so-declared variable
isn't initialized:

39
00:01:58,515 --> 00:02:00,656
we didn't assign any initial value to it.

40
00:02:00,656 --> 00:02:04,126
How can we initialize an ArrayList?

41
00:02:05,447 --> 00:02:08,147
A usual way of initializing an ArrayList

42
00:02:08,147 --> 00:02:11,097
is to initialize it with an
empty array,

43
00:02:11,097 --> 00:02:13,249
an array without any elements.

44
00:02:13,249 --> 00:02:15,317
This is done like this:

45
00:02:15,317 --> 00:02:17,495
to the variable associated with
the array,

46
00:02:17,495 --> 00:02:22,424
we'll assign an empty array created
in the following manner.

47
00:02:22,436 --> 00:02:26,490
It has to be used exactly like this.

48
00:02:26,490 --> 00:02:29,250
The reserved word new, the
reserved word ArrayList,

49
00:02:29,250 --> 00:02:32,432
here we'll put the exact same type

50
00:02:32,432 --> 00:02:35,554
as the one we used for the
array declaration,

51
00:02:35,554 --> 00:02:38,407
followed by two parenthesis,
not to forget.

52
00:02:38,753 --> 00:02:43,132
Here we resort to a way related
to object-oriented programming,

53
00:02:43,132 --> 00:02:44,995
but it isn't necessary to
fully understand

54
00:02:44,995 --> 00:02:47,398
the ins and outs of it
to use it.

55
00:02:47,398 --> 00:02:51,152
What you must remember here is that
with this instruction line,

56
00:02:51,152 --> 00:02:53,113
you constructed a  dynamic
array

57
00:02:53,113 --> 00:02:54,645
without any elements.

58
00:02:54,645 --> 00:02:58,427
Here you have a concrete example
of declaration-initialization

59
00:02:58,427 --> 00:03:00,768
of an ArrayList of Strings.

60
00:03:00,768 --> 00:03:04,579
The "tableau" variable contains a
reference to a dynamic array

61
00:03:04,579 --> 00:03:07,051
of Strings without any element yet.

62
00:03:07,571 --> 00:03:10,805
As this so-declared array doesn't
contain any elements,

63
00:03:10,805 --> 00:03:12,792
we'll naturally ask ourselves
the following question:

64
00:03:12,792 --> 00:03:15,560
how do we put the values in
this array?

65
00:03:17,257 --> 00:03:19,796
As for the strings, there exists a number

66
00:03:19,796 --> 00:03:23,129
of specific methods related to
the ArrayList type.

67
00:03:23,129 --> 00:03:25,362
To be able to use these functions,

68
00:03:25,362 --> 00:03:29,608
you must use a particular syntax; the
array's name, followed by a dot,

69
00:03:29,608 --> 00:03:31,701
followed by the name of the
function

70
00:03:31,701 --> 00:03:34,930
and then we must indicate, in
parenthesis, the data

71
00:03:34,930 --> 00:03:38,706
that the function needs to be
able to be executed.

72
00:03:39,337 --> 00:03:41,232
Here you have a concrete
example.

73
00:03:41,232 --> 00:03:43,569
I declare an ArrayList of strings,

74
00:03:43,569 --> 00:03:46,476
named "prenoms" [TN: means "first name"]
and I initialize this array

75
00:03:46,476 --> 00:03:48,164
with an empty array.

76
00:03:49,399 --> 00:03:52,032
Then I use a particular
function

77
00:03:52,032 --> 00:03:54,665
defined for ArrayList, called "size".

78
00:03:54,665 --> 00:03:57,299
This function simply returns
the current size

79
00:03:57,299 --> 00:03:58,769
of the ArrayList.

80
00:03:58,774 --> 00:04:01,218
I used the syntax I just
mentioned,

81
00:04:01,218 --> 00:04:03,431
that is the array's name,
followed by a dot,

82
00:04:03,431 --> 00:04:05,284
followed by the function's name.

83
00:04:05,284 --> 00:04:07,319
"size" doesn't need any
external information

84
00:04:07,319 --> 00:04:09,731
to return us the array's size,

85
00:04:09,731 --> 00:04:12,410
so I must put an empty pair
of parenthesis.

86
00:04:12,822 --> 00:04:15,800
Of course, this instruction line's
execution will print 0,

87
00:04:15,800 --> 00:04:18,889
as I've initialized the array with
an empty array.

88
00:04:20,850 --> 00:04:23,017
Now here's a non-exhaustive
list

89
00:04:23,017 --> 00:04:25,519
of a few typical functions associated
with arrays.

90
00:04:25,530 --> 00:04:28,261
We just saw the "size" function
[a.k.a. "size" method]

91
00:04:28,261 --> 00:04:31,090
that allows us to get the array's size

92
00:04:31,090 --> 00:04:33,849
and that returns it as an integer.

93
00:04:34,427 --> 00:04:37,242
There exists other functions/methods
such as "get" and "set"

94
00:04:37,242 --> 00:04:39,768
that I'll use according to the
same principle,

95
00:04:39,768 --> 00:04:43,157
that is the array's name, a dot,
followed by the function's name.

96
00:04:43,157 --> 00:04:46,405
Here I notice that unlike the
"size" method,

97
00:04:46,405 --> 00:04:51,029
I need to give data to the
"get" or "set" methods

98
00:04:51,029 --> 00:04:53,399
in order for them to work.

99
00:04:54,302 --> 00:04:56,339
The "get" and "set" methods are
the equivalent

100
00:04:56,339 --> 00:05:00,141
of the indexation mechanism for
static arrays.

101
00:05:00,141 --> 00:05:03,248
For a simple static array, if I want
to access

102
00:05:03,248 --> 00:05:06,148
the element of index 'i', I
use indexation.

103
00:05:06,148 --> 00:05:08,523
This mechanism doesn't exist
for dynamic arrays.

104
00:05:08,908 --> 00:05:12,166
Instead, you must use methods
such as "get" and "set".

105
00:05:12,166 --> 00:05:14,255
For a dynamic array,

106
00:05:14,255 --> 00:05:18,629
if I want to access the element
of index 'i',

107
00:05:18,629 --> 00:05:20,332
I'll use this notation

108
00:05:20,332 --> 00:05:22,445
rather than this one.

109
00:05:22,445 --> 00:05:24,897
The same applies if I want to modify
a static array.

110
00:05:24,897 --> 00:05:27,290
I'll use this notation,

111
00:05:27,290 --> 00:05:30,167
so if I want to modify the i-th
cell of a static array

112
00:05:30,167 --> 00:05:32,110
I'll use this notation.

113
00:05:32,110 --> 00:05:34,001
This doesn't exist for dynamic
arrays,

114
00:05:34,001 --> 00:05:37,679
instead we'll have to use this
type of notation;

115
00:05:37,679 --> 00:05:42,807
the array's name, a dot, "set",  and in
parenthesis the index of the cell

116
00:05:42,807 --> 00:05:46,567
that I want to modify and the
corresponding value.

117
00:05:46,567 --> 00:05:50,262
So this notation doesn't exist either
for dynamic arrays.

118
00:05:50,782 --> 00:05:52,621
The restrictions on the
index's bounds

119
00:05:52,621 --> 00:05:55,350
stay however the same as for a
fixed-size array,

120
00:05:55,350 --> 00:05:59,875
the index varies between 0 and
the array's size - 1.

121
00:05:59,875 --> 00:06:02,374
array's size - 1 is written
like this for

122
00:06:02,374 --> 00:06:03,745
a dynamic array, for example.

123
00:06:03,745 --> 00:06:06,079
So, as with fixed-size arrays,

124
00:06:06,079 --> 00:06:10,293
any access attempt with an index
out of the bounds

125
00:06:10,293 --> 00:06:13,569
will translate into an error
at the program's execution.

126
00:06:14,706 --> 00:06:17,869
It's possible to test if a dynamic
array is empty

127
00:06:17,869 --> 00:06:20,679
by using the "isEmpty" function.

128
00:06:21,069 --> 00:06:23,820
This is a function that doesn't
need any data

129
00:06:23,820 --> 00:06:26,201
to work. It will return

130
00:06:26,201 --> 00:06:28,963
a value of boolean type,
true or false,

131
00:06:28,963 --> 00:06:31,661
depending if the array contains
values or not.

132
00:06:31,661 --> 00:06:36,575
The returned value will be true if
the array doesn't contain any values

133
00:06:36,575 --> 00:06:39,006
and false otherwise.

134
00:06:39,807 --> 00:06:43,479
The "clear" method empties
an ArrayList,

135
00:06:43,479 --> 00:06:45,434
which means that it deletes all
its elements,

136
00:06:45,434 --> 00:06:47,118
and transforms it into an empty
array.

137
00:06:47,484 --> 00:06:49,340
If we imagine for example that
at a given moment

138
00:06:49,340 --> 00:06:51,356
in a program, I have an ArrayList

139
00:06:51,356 --> 00:06:53,212
that is in this state of filling

140
00:06:53,212 --> 00:06:55,810
-- let's imagine that it's an ArrayList
of integers named "tab" --

141
00:06:55,810 --> 00:06:59,039
if I call the "isEmpty" function,

142
00:07:00,799 --> 00:07:04,434
it's obvious that the result
will be the false boolean,

143
00:07:04,444 --> 00:07:05,924
as the array isn't empty.

144
00:07:06,173 --> 00:07:10,079
I can now apply the "clear" function,
for example,

145
00:07:10,079 --> 00:07:12,536
that will delete all the elements

146
00:07:12,536 --> 00:07:16,292
and transform it into an empty array.
There is no more element in it.

147
00:07:16,292 --> 00:07:21,865
So if I call again the "isEmpty" function,

148
00:07:21,865 --> 00:07:25,472
this time the result will be true,
as the array is now empty.

149
00:07:27,350 --> 00:07:29,496
The "remove" method allows us
to delete

150
00:07:29,496 --> 00:07:32,052
the element of index 'i' in an ArrayList.

151
00:07:32,052 --> 00:07:34,429
So if we imagine for example that
at a given moment,

152
00:07:34,429 --> 00:07:37,844
we have an ArrayList of integers
with three cells,

153
00:07:37,844 --> 00:07:39,729
that has this particular form,

154
00:07:39,729 --> 00:07:43,471
the indexes vary between 0 and
size - 1, which gives us this.

155
00:07:43,471 --> 00:07:45,743
Let's assume that the array is
named "tab".

156
00:07:45,743 --> 00:07:50,083
Now, if I call the "size" function
on this array,

157
00:07:50,083 --> 00:07:53,220
it will return 3 because my array
contains three cells.

158
00:07:53,220 --> 00:07:56,755
Now if I call the "remove"
method

159
00:07:56,755 --> 00:07:58,535
and pass it the index 1,

160
00:07:58,535 --> 00:08:00,616
this element will be removed,

161
00:08:00,616 --> 00:08:01,896
so all the elements

162
00:08:01,896 --> 00:08:05,899
that follow this element will be
shifted to the left

163
00:08:05,899 --> 00:08:10,319
and I'll finally obtain an array
with two cells.

164
00:08:11,579 --> 00:08:15,066
And if I apply my "tab.size()" function again,

165
00:08:15,066 --> 00:08:17,382
it will obviously return 2.

166
00:08:17,884 --> 00:08:19,865
Here we see that for an ArrayList,

167
00:08:19,865 --> 00:08:22,865
the size can indeed vary during
the execution

168
00:08:22,865 --> 00:08:26,072
with the calls to methods of
this nature.

169
00:08:26,873 --> 00:08:29,273
The index of the element that
we want to remove

170
00:08:29,273 --> 00:08:31,473
obivously has to exist
in the array

171
00:08:31,473 --> 00:08:33,773
when we call the "remove" function.

172
00:08:34,121 --> 00:08:39,085
Let's suppose for example that instead
of doing "tab.remove(1)*,

173
00:08:39,085 --> 00:08:42,104
I try doing "tab.remove(4)".

174
00:08:42,104 --> 00:08:45,332
This will result in an error during
the program's execution.

175
00:08:46,408 --> 00:08:49,826
If it's possible to remove elements
from an ArrayList,

176
00:08:49,826 --> 00:08:52,979
it is also possible to add values
in such an array.

177
00:08:52,979 --> 00:08:55,547
To achieve this we'll use the
"add" method,

178
00:08:55,547 --> 00:08:58,219
and we'll have to give the value that
we want to add to the array.

179
00:08:58,219 --> 00:09:01,873
The value will systematically be added
at the end of the array.

180
00:09:01,873 --> 00:09:06,270
Let's take a concrete example of
an array of integers.

181
00:09:07,460 --> 00:09:12,500
Here, "tab.size()" returns 3.

182
00:09:12,500 --> 00:09:17,996
I add the value 8 to my array
by using the "add" method.

183
00:09:18,416 --> 00:09:23,036
The result will be an array with
an additional cell.

184
00:09:23,036 --> 00:09:26,943
This cell is at the end so I'll
have this in "tab",

185
00:09:26,943 --> 00:09:32,819
and of course "tab.size()" will now
return 4;

186
00:09:32,819 --> 00:09:36,173
we can see that the array
increased by one cell.

187
00:09:36,610 --> 00:09:40,396
Now here's an example with a
few basic manipulations

188
00:09:40,396 --> 00:09:43,303
that we can usually do on an ArrayList.

189
00:09:43,303 --> 00:09:46,458
So we saw that to be able to
use the ArrayList type,

190
00:09:46,458 --> 00:09:49,059
it was necessary to begin the
file

191
00:09:49,059 --> 00:09:50,680
with an import directive

192
00:09:50,680 --> 00:09:52,791
that will make the ArrayList type

193
00:09:52,791 --> 00:09:55,056
available in the program.

194
00:09:55,056 --> 00:09:57,724
I can now use the ArrayList
type

195
00:09:57,724 --> 00:09:59,742
to declare a variable

196
00:09:59,742 --> 00:10:01,712
and here I'm declaring a variable

197
00:10:01,712 --> 00:10:04,531
of type ArrayList of Strings.

198
00:10:04,531 --> 00:10:06,213
We also saw

199
00:10:06,213 --> 00:10:08,295
that in order to initialize the array
to an empty array,

200
00:10:08,295 --> 00:10:10,267
we have to use this sort
of notation.

201
00:10:10,267 --> 00:10:12,601
So at the end of the execution
of this instruction line,

202
00:10:12,601 --> 00:10:16,130
I get as a list the reference to
an empty ArrayList.

203
00:10:16,500 --> 00:10:18,958
I then execute the following
instruction line.

204
00:10:20,528 --> 00:10:24,344
I call the "add" method that allows me
to add a particular element,

205
00:10:24,344 --> 00:10:28,313
here the string "un" [TN: means "one"]
at the end of the ArrayList.

206
00:10:28,313 --> 00:10:31,287
As the array is empty, it doesn't make
a big difference;

207
00:10:31,287 --> 00:10:35,565
ultimately I'll have a dynamic
array that will look like this.

208
00:10:35,565 --> 00:10:39,687
I execute the following instruction line
that adds a string,

209
00:10:39,687 --> 00:10:42,160
the string "deux" [TN: means "two"]
at the end of the array.

210
00:10:42,160 --> 00:10:46,641
So here I get the following
content in the array.

211
00:10:48,901 --> 00:10:52,436
If I want to print the content of
my ArrayList at this stage,

212
00:10:52,445 --> 00:10:55,485
I use a for-loop.
We saw that we could use

213
00:10:55,485 --> 00:11:00,059
for example a for-loop iterating
over a set of values.

214
00:11:00,059 --> 00:11:03,783
Here my for-loop will alternately take
each element of the list

215
00:11:03,783 --> 00:11:07,330
and print it by separating
them with a space.

216
00:11:07,330 --> 00:11:11,177
So here, after the execution of this
instruction line, will be printed

217
00:11:11,177 --> 00:11:15,541
the string "un" separated by a
whitespace from the string "two",

218
00:11:15,541 --> 00:11:18,246
that will get printed like this
on the screen.

219
00:11:19,376 --> 00:11:22,682
If I want to access the i-th cell
of an ArrayList,

220
00:11:22,712 --> 00:11:25,583
either to look at its content, or
to modify it,

221
00:11:25,583 --> 00:11:27,775
I'll have to use the "get" and "set"
methods.

222
00:11:27,775 --> 00:11:30,006
So if I execute this instruction line,

223
00:11:30,006 --> 00:11:33,217
knowing that the array filling at this
stage is like this,

224
00:11:33,217 --> 00:11:35,727
I'll use the "get" method

225
00:11:35,727 --> 00:11:39,365
that will access the element of
index 1 in the array.

226
00:11:39,365 --> 00:11:44,418
This element of index 1 is the
string "deux"

227
00:11:44,418 --> 00:11:48,510
and at that moment I'll print
the sequence "deux".

228
00:11:50,480 --> 00:11:53,361
When I execute the following
instruction line,

229
00:11:53,363 --> 00:11:56,387
I'll modify the element at
the index 0

230
00:11:56,387 --> 00:12:00,520
in order that its new value is the string
"premier" [TN: means "first"].

231
00:12:00,520 --> 00:12:08,438
So my array will now look like this,

232
00:12:09,768 --> 00:12:12,776
after the execution of this
instruction line.

233
00:12:16,376 --> 00:12:21,924
The element of index 0 that was "un"
has been changed into "premier".

234
00:12:23,472 --> 00:12:26,085
In every example of ArrayList
showed until now,

235
00:12:26,085 --> 00:12:27,883
the content was of type "String".

236
00:12:27,883 --> 00:12:29,869
Of course, it's a deliberate
choice

237
00:12:29,869 --> 00:12:33,839
that responds to the constraint that the
content of an ArrayList in Java

238
00:12:33,839 --> 00:12:36,561
must systematically be of an
advanced type.

239
00:12:36,561 --> 00:12:39,305
It can however turn out that
we need

240
00:12:39,305 --> 00:12:42,267
to work with dynamic arrays
of integers.

241
00:12:42,267 --> 00:12:43,918
How would we then proceed?

242
00:12:44,378 --> 00:12:46,080
It's enough to know at this stage

243
00:12:46,080 --> 00:12:48,909
that Java offers for each basic type,

244
00:12:48,909 --> 00:12:51,738
a corresponding advanced type.
For example, for the 'int' type,

245
00:12:51,738 --> 00:12:54,569
you have the Integer type, with
an uppercase 'I',

246
00:12:54,572 --> 00:12:56,817
that is equivalent to "int" but is
of advanced type.

247
00:12:56,817 --> 00:12:58,828
The same applies for the
"double" type.

248
00:12:58,828 --> 00:13:01,506
There is an equivalent, "Double
with an uppercase 'D';

249
00:13:01,506 --> 00:13:04,837
and this is valid for each basic type.

250
00:13:05,717 --> 00:13:07,833
These advanced types of a
patricular kind

251
00:13:07,833 --> 00:13:10,399
are particularly useful in
some contexts,

252
00:13:10,399 --> 00:13:12,210
typically for ArrayList.

253
00:13:12,210 --> 00:13:13,244
Why?

254
00:13:13,244 --> 00:13:15,249
Because we saw that in
an ArrayList,

255
00:13:15,249 --> 00:13:19,381
it's only possible to store values
of advanced type.

256
00:13:19,381 --> 00:13:22,198
Thereby, in a Java program,
I can never declare

257
00:13:22,198 --> 00:13:24,763
an ArrayList of "double" with a lowercase
'd', nor an ArrayList of "int".

258
00:13:26,480 --> 00:13:30,297
I can however declare an ArrayList
of "Integer".

259
00:13:30,547 --> 00:13:32,907
Once the array's declaration
is done

260
00:13:32,907 --> 00:13:35,619
and respects the constraint that
the content is of an advanced type,

261
00:13:35,619 --> 00:13:37,613
I can put

262
00:13:37,613 --> 00:13:39,947
values of elementary type in
my array,

263
00:13:39,947 --> 00:13:41,603
for a very simple reason.

264
00:13:41,603 --> 00:13:44,415
That reason is that the conversion
of basic types into advanced types

265
00:13:44,415 --> 00:13:46,807
can be done automatically.

266
00:13:46,807 --> 00:13:49,099
That was't the case in the first
versions of Java,

267
00:13:49,099 --> 00:13:50,834
but that's how it's done now.

268
00:13:50,834 --> 00:13:52,943
And I can therefore work
with dynamic

269
00:13:52,943 --> 00:13:55,052
arrays of "Integers" or of "Doubles"

270
00:13:55,052 --> 00:13:57,163
while being nearly free from
the constraint

271
00:13:57,163 --> 00:13:59,762
of using advanced types.

272
00:13:59,762 --> 00:14:02,181
Now let's see that with a
concrete example.

273
00:14:03,082 --> 00:14:04,669
Here we want to write a
small program

274
00:14:04,669 --> 00:14:06,971
that fills an ArrayList
of integers

275
00:14:06,971 --> 00:14:09,751
with stricly positive numbers.

276
00:14:09,751 --> 00:14:12,941
We suppose that the values will
be requested from the user

277
00:14:12,962 --> 00:14:15,755
and we also want to adhere to
a number of conventions.

278
00:14:15,755 --> 00:14:20,361
If the user enters the value 0, that
will be the convention

279
00:14:20,361 --> 00:14:23,430
that we want to restart filling the
array from the beginning.

280
00:14:23,430 --> 00:14:26,905
If the user enters a negative
number,

281
00:14:26,905 --> 00:14:30,678
that will be the convention that
we want to remove

282
00:14:30,678 --> 00:14:33,272
the last element introduced
in the array.

283
00:14:33,772 --> 00:14:36,727
The program's execution could
look like this.

284
00:14:36,727 --> 00:14:38,734
We ask the user

285
00:14:38,734 --> 00:14:40,954
to enter three strictly
positive values,

286
00:14:40,954 --> 00:14:43,123
and we'll ask him each of these
values alternately.

287
00:14:43,123 --> 00:14:46,628
Here we ask him to enter
the value of index 0

288
00:14:46,628 --> 00:14:48,410
and we suppose that he
entered 5.

289
00:14:48,410 --> 00:14:50,342
This value being strictly positive,

290
00:14:50,342 --> 00:14:52,783
we'll store it in the array.

291
00:14:53,373 --> 00:14:56,409
We then ask him the second
value, the one of index 1.

292
00:14:56,409 --> 00:14:58,687
This value is strictly positive,

293
00:14:58,687 --> 00:15:00,915
we put it in the array, once
again.

294
00:15:02,345 --> 00:15:04,455
We then ask him to enter
the last value,

295
00:15:04,455 --> 00:15:07,458
the value of index 2. But it turns
out that the user enters a 0,

296
00:15:07,458 --> 00:15:11,825
which corresponds to the convention
to restart from the beginning.

297
00:15:11,825 --> 00:15:13,784
Which means that at this point,

298
00:15:13,784 --> 00:15:16,040
we want the array to be empty again.

299
00:15:16,040 --> 00:15:18,402
So as the array is emptied again,
the next value

300
00:15:18,402 --> 00:15:21,744
that we'll ask from the user will
be the value of index 0 again.

301
00:15:21,744 --> 00:15:27,631
Here the user enters a 7, we'll
therefore have this array.

302
00:15:27,631 --> 00:15:32,118
He then enters a 2, we get
this array.

303
00:15:32,678 --> 00:15:36,141
He then enters, for the last
value again,

304
00:15:37,621 --> 00:15:40,614
a negative value, which
corresponds for us

305
00:15:40,614 --> 00:15:44,049
to the second convention, the one
that says to remove the last element.

306
00:15:44,049 --> 00:15:46,341
The last entered element is the 2,

307
00:15:46,341 --> 00:15:50,800
so we want the array to now
look like this,

308
00:15:50,800 --> 00:15:53,225
and that's why, at the next step,

309
00:15:53,225 --> 00:15:57,029
we'll ask the user to enter the
second value again,

310
00:15:57,029 --> 00:16:00,326
as the array now contains only
one value.

311
00:16:00,616 --> 00:16:03,070
At that moment the user enters a 4,

312
00:16:03,070 --> 00:16:04,964
that we'll store in the array,

313
00:16:06,164 --> 00:16:08,939
he then enters a 12 as last
value,

314
00:16:08,939 --> 00:16:11,211
and we'll end up with this array.

315
00:16:12,941 --> 00:16:15,551
As we indeed have the three
desired values,

316
00:16:15,551 --> 00:16:19,831
we constructed our array as we
intended to,

317
00:16:19,831 --> 00:16:24,180
and we'll finally end up with an
array that contains 7, 4 and 12,

318
00:16:24,180 --> 00:16:26,333
which are all strictly positive
values.

319
00:16:27,213 --> 00:16:31,265
Here we see that during the entire
program's execution,

320
00:16:31,265 --> 00:16:34,706
our array's size increases and decreases
following our needs.

321
00:16:34,706 --> 00:16:36,600
So that's typically a case

322
00:16:36,600 --> 00:16:39,866
where the use of an ArrayList
is particularly adapted.

323
00:16:40,486 --> 00:16:42,345
Now let's see how all this
looks like

324
00:16:42,345 --> 00:16:44,770
in the form of a Java program.

325
00:16:46,550 --> 00:16:48,559
The computations showed
in the previous example

326
00:16:48,559 --> 00:16:50,211
can be implemented with

327
00:16:50,211 --> 00:16:52,193
a small Java program that
looks like this.

328
00:16:52,303 --> 00:16:55,835
We begin by declaring an ArrayList of integers.

329
00:16:55,835 --> 00:16:59,216
As we can't create an ArrayList
of "int" type,

330
00:16:59,216 --> 00:17:02,519
of any elementary type, we use the
"Integer" type.

331
00:17:02,519 --> 00:17:05,049
Our ArrayList is named "vect"

332
00:17:05,049 --> 00:17:08,160
and is initialized as an empty
ArrayList.

333
00:17:08,173 --> 00:17:11,258
So ultimately the "vect" variable
will contain

334
00:17:11,258 --> 00:17:14,382
the reference to an empty ArrayList of integers.

335
00:17:15,742 --> 00:17:17,591
We then ask the user

336
00:17:17,591 --> 00:17:20,005
how many values he wants
to enter in the array.

337
00:17:20,005 --> 00:17:23,354
We input the size that the user
wants for the array

338
00:17:23,354 --> 00:17:25,239
with a keyboard interaction.

339
00:17:25,869 --> 00:17:27,595
We then ask the user

340
00:17:27,595 --> 00:17:30,391
to input the different values
to fill the array.

341
00:17:30,391 --> 00:17:32,524
To achieve that, we use a loop,

342
00:17:32,524 --> 00:17:34,720
as he is potentially going to
enter many values.

343
00:17:35,250 --> 00:17:36,693
The loop is such that

344
00:17:36,693 --> 00:17:39,776
while the actual array size hasn't
reached the desired size, 

345
00:17:40,026 --> 00:17:42,036
we continue to loop.

346
00:17:43,166 --> 00:17:44,711
During each loop
iteration,

347
00:17:44,711 --> 00:17:48,194
we ask the user to input one of
the values in the array.

348
00:17:48,194 --> 00:17:49,845
But what value precisely?

349
00:17:50,115 --> 00:17:52,346
Here we want to indicate to the user

350
00:17:52,346 --> 00:17:54,471
the index of the value to input.

351
00:17:54,471 --> 00:17:58,051
Let's suppose that the array's
filling state is the following:

352
00:17:59,981 --> 00:18:01,285
so at this moment

353
00:18:01,915 --> 00:18:05,659
vect.size() has the value 2

354
00:18:06,989 --> 00:18:08,773
and the last element

355
00:18:09,743 --> 00:18:10,889
has index 1,

356
00:18:12,909 --> 00:18:16,679
which is vect.size() - 1.

357
00:18:17,579 --> 00:18:22,627
That means that the next value of the
array that we want to input

358
00:18:22,627 --> 00:18:26,007
does indeed have "vect.size()"
as index,

359
00:18:26,007 --> 00:18:28,028
and that's what we can see here.

360
00:18:28,028 --> 00:18:32,487
We'll ask the user to input
the value

361
00:18:32,487 --> 00:18:37,377
that's at the position vect.size(), that
will occupy the position vect.size().

362
00:18:38,303 --> 00:18:42,036
The value to put in the array
is again input

363
00:18:42,036 --> 00:18:43,489
with a keyboard interaction.

364
00:18:43,489 --> 00:18:46,488
And that's when we begin testing
the different cases

365
00:18:46,488 --> 00:18:49,071
to adhere to the different
conventions presented

366
00:18:49,071 --> 00:18:51,141
in the previous example.

367
00:18:51,901 --> 00:18:54,039
One of the conventions that we wanted
to implement

368
00:18:54,039 --> 00:18:58,066
is that if the value introduced by the
user is negative,

369
00:18:58,066 --> 00:19:00,617
that would mean that we want
to remove

370
00:19:00,617 --> 00:19:03,550
the last element introduced in
the array.

371
00:19:03,550 --> 00:19:06,849
So concretely, we'll use the
"remove" method

372
00:19:06,849 --> 00:19:08,867
to do this suppression.

373
00:19:09,957 --> 00:19:14,088
And at that moment we'll remove
the last element of the array,

374
00:19:14,088 --> 00:19:16,557
the element of index vect.size() - 1,

375
00:19:16,557 --> 00:19:18,571
as we saw here.

376
00:19:19,431 --> 00:19:21,342
However, we have to take a
precaution.

377
00:19:21,342 --> 00:19:24,095
We can process with this
suppression

378
00:19:24,095 --> 00:19:26,539
only if the ArrayList
isn't empty.

379
00:19:26,539 --> 00:19:28,726
Therefore, we must combine this
first test

380
00:19:28,726 --> 00:19:30,157
with a second test

381
00:19:30,607 --> 00:19:33,555
that will test if the ArrayList,

382
00:19:33,555 --> 00:19:38,208
is empty or not. So we'll proceed
with the suppression

383
00:19:38,208 --> 00:19:42,842
only if the value is negative and if
the array isn't empty.

384
00:19:43,342 --> 00:19:46,417
Whether it is empty or not is tested
with the isEmpty function.

385
00:19:46,417 --> 00:19:50,584
The fact it isn't empty is expressed
with this negation.

386
00:19:51,994 --> 00:19:54,581
If the condition expressed here
isn't verified,

387
00:19:54,581 --> 00:19:56,603
we must then proceed with
other tests.

388
00:19:56,603 --> 00:19:58,728
We saw that we wanted to have the
convention

389
00:19:58,728 --> 00:20:01,202
that if the user enters the
value '0',

390
00:20:01,422 --> 00:20:03,511
that means that we want to
empty the array.

391
00:20:03,511 --> 00:20:06,854
We therefore proceed with an
alternative test here.

392
00:20:06,854 --> 00:20:09,656
To completely empty an ArrayList,

393
00:20:09,656 --> 00:20:12,618
you use the "clear" function.

394
00:20:12,898 --> 00:20:14,200
So here, simply,

395
00:20:14,550 --> 00:20:18,071
if the value entered by the
user is null,

396
00:20:18,311 --> 00:20:21,119
then we completely empty
the array.

397
00:20:22,399 --> 00:20:24,752
Otherwise, if we reach this
stage of the execution,

398
00:20:24,752 --> 00:20:26,770
that means that either the
entered value

399
00:20:26,770 --> 00:20:28,841
is strictly positive, or the
vector is null.

400
00:20:29,101 --> 00:20:30,867
It therefore isn't strictly
guaranteed

401
00:20:30,867 --> 00:20:32,682
that the entered value
is positive.

402
00:20:32,682 --> 00:20:35,558
You must therefore test it again;
that's what we do here.

403
00:20:36,058 --> 00:20:38,341
If this is the case, if the condition
is verified,

404
00:20:38,341 --> 00:20:41,499
we can then add the value to
our ArrayList

405
00:20:41,499 --> 00:20:44,655
and that is done with the
"add" function.

406
00:20:45,355 --> 00:20:47,481
So, we are going to iterate over
these computations

407
00:20:47,481 --> 00:20:50,086
while the ArrayList

408
00:20:50,086 --> 00:20:52,918
hasn't reached the size
wanted by the user.

409
00:20:53,668 --> 00:20:55,708
Note an important thing.

410
00:20:55,708 --> 00:20:58,626
We constructed our array, we
declared it

411
00:20:58,626 --> 00:21:01,137
by using the advanced type
'Integer'.

412
00:21:01,137 --> 00:21:03,572
This means that in our array,

413
00:21:03,572 --> 00:21:06,745
we don't directly have
integer values

414
00:21:06,745 --> 00:21:08,287
like this,

415
00:21:08,617 --> 00:21:10,294
or like I have shown
very schematically

416
00:21:10,294 --> 00:21:11,862
in the example.

417
00:21:11,862 --> 00:21:14,519
But to be exact, we have
references to integers

418
00:21:14,519 --> 00:21:17,717
in the array.

419
00:21:17,717 --> 00:21:20,489
So here the situation would
be as follows:

420
00:21:20,489 --> 00:21:23,168
at the position '0' we would
have a reference

421
00:21:23,168 --> 00:21:27,941
to a memory address that contains
'12', and not directly the value '12'.

422
00:21:28,791 --> 00:21:33,077
In this case, how did we
enter

423
00:21:33,077 --> 00:21:35,639
a value of 'int' type in the array

424
00:21:35,639 --> 00:21:37,214
like we have done here?

425
00:21:38,684 --> 00:21:41,105
Indeed, as our array has been
declared

426
00:21:41,105 --> 00:21:42,998
as containing 'Integer',

427
00:21:42,998 --> 00:21:45,977
we expect to be able to add
to this array

428
00:21:45,977 --> 00:21:47,998
only values of the same type,

429
00:21:47,998 --> 00:21:52,027
and therefore not directly an integer,
but a reference to an integer,

430
00:21:52,027 --> 00:21:55,741
which we don't know how to construct
or initialize for the moment.

431
00:21:55,741 --> 00:21:58,507
However, we were able to directly
enter an 'int'.

432
00:21:59,037 --> 00:22:02,581
This is allowed thanks to the
automatic conversion

433
00:22:02,581 --> 00:22:05,483
that is done between the
basic types

434
00:22:06,193 --> 00:22:08,082
and the corresponding advanced
types.

435
00:22:08,082 --> 00:22:11,492
So in reality, when we execute
this instruction line,

436
00:22:11,492 --> 00:22:15,436
what we put in the array isn't
directly the value "val"

437
00:22:15,436 --> 00:22:18,556
entered by the user, which is
of 'int' type,

438
00:22:18,976 --> 00:22:20,939
but we put in the array

439
00:22:20,939 --> 00:22:24,383
an "Integer", which is a reference to
the value "val".

440
00:22:24,383 --> 00:22:27,933
All this is done in a completely
automatic and transparent way.

441
00:22:27,933 --> 00:22:30,870
We didn't have to worry about
conversions.

442
00:22:31,500 --> 00:22:33,448
So thanks to this automatic
conversion,

443
00:22:33,448 --> 00:22:37,187
it becomes completely natural to
also work

444
00:22:37,517 --> 00:22:42,183
with ArrayLists of integers, of
doubles, or of a basic type.

445
00:22:42,183 --> 00:22:45,255
The only precaution that we
must take

446
00:22:45,255 --> 00:22:48,023
is to declare the array

447
00:22:48,023 --> 00:22:52,172
with the corresponding advanced
type.

448
00:22:53,562 --> 00:22:56,102
This automatic conversion between
a basic type

449
00:22:56,102 --> 00:22:58,141
and a corresponding advanced
type

450
00:22:58,141 --> 00:23:02,160
is what we call "autoboxing",
in technical terms.

451
00:23:04,570 --> 00:23:06,930
We saw that an ArrayList
can only contain

452
00:23:06,930 --> 00:23:08,780
elements of advanced types.

453
00:23:08,780 --> 00:23:12,108
To conclude, let's examine the incidence
that this has on the comparison

454
00:23:12,108 --> 00:23:14,077
of the elements of such an array.

455
00:23:14,077 --> 00:23:15,707
At the first instruction line,

456
00:23:15,707 --> 00:23:18,855
I'll have the automatic conversion
of a value of basic type

457
00:23:18,855 --> 00:23:20,858
to a value of 'Integer' type.

458
00:23:20,858 --> 00:23:24,613
But I am in reality adding to my
ArrayList isn't

459
00:23:24,613 --> 00:23:26,870
directly the value 2000,

460
00:23:26,870 --> 00:23:29,254
but a reference to this value.

461
00:23:29,254 --> 00:23:31,588
So I end up with a memory
situation

462
00:23:31,588 --> 00:23:33,211
that is the following.

463
00:23:34,901 --> 00:23:38,815
Here the value 2000 was not directly stored
in our ArrayList,

464
00:23:38,815 --> 00:23:40,319
but its address.

465
00:23:41,679 --> 00:23:44,093
So when I execute the second
instruction line,

466
00:23:44,093 --> 00:23:46,268
it's exactly the same
situation

467
00:23:47,358 --> 00:23:48,788
that happens,

468
00:23:48,788 --> 00:23:51,287
except that at that moment
I have 2 references.

469
00:23:51,547 --> 00:23:54,778
It turns out that these references
have a similar content,

470
00:23:59,218 --> 00:24:01,530
but they were created by two
distinct "add".

471
00:24:01,530 --> 00:24:05,978
And at that moment, they are two
different, distinct, memory addresses.

472
00:24:05,978 --> 00:24:11,127
So here, if I want to compare the content
of the first entry of the array

473
00:24:11,527 --> 00:24:14,955
with the second, with something
like this,

474
00:24:15,285 --> 00:24:18,181
the result of this instruction
line's execution

475
00:24:18,181 --> 00:24:21,522
will in reality be false.

476
00:24:22,122 --> 00:24:23,935
Why? Because I indeed have

477
00:24:23,935 --> 00:24:25,718
2 distinct memory addresses,

478
00:24:25,718 --> 00:24:27,517
and it isn't the same memory
location,

479
00:24:27,517 --> 00:24:29,849
and the comparison will return
false.

480
00:24:29,849 --> 00:24:32,780
If we are more interested in
comparing the contents,

481
00:24:32,780 --> 00:24:35,929
then, as we did with the Strings, 
we mustn't resort to

482
00:24:35,929 --> 00:24:38,666
an equality test with '==',

483
00:24:38,666 --> 00:24:42,154
but rather to an equality test
with 'equals'.

484
00:24:42,534 --> 00:24:45,887
So we access the first element
of the array, which is an 'Integer',

485
00:24:45,887 --> 00:24:50,282
and we apply the 'equals' method on
this element to compare

486
00:24:51,422 --> 00:24:52,962
it with the second element
of the array.

487
00:24:52,962 --> 00:24:56,265
And here, the result of this instruction
line's execution

488
00:24:56,265 --> 00:24:59,598
will indeed be 'true' because the
values are identical.

489
00:24:59,598 --> 00:25:03,017
The values to which the references
point are identical.
