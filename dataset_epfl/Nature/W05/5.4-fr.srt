1
00:00:02,862 --> 00:00:03,499
Bienvenue !

2
00:00:03,674 --> 00:00:06,749
Nature, dans le code.
Nous sommes dans le chapitre 5, leçon 4.

3
00:00:06,924 --> 00:00:08,625
Dans cette leçon, nous avons
besoin de mettre en œuvre

4
00:00:08,825 --> 00:00:11,287
la fonction obtenu par Mating Partner.

5
00:00:11,525 --> 00:00:14,487
Maintenant, dans le monde réel,
si l'on regarde

6
00:00:14,687 --> 00:00:18,437
l'art humain, la musique, les livres,
le théâtre et ainsi de suite,

7
00:00:18,637 --> 00:00:22,099
il semble que ce ne sont pas toujours
un processus simple.

8
00:00:22,299 --> 00:00:24,099
Mais, en JavaScript, il est.

9
00:00:24,299 --> 00:00:26,087
Donc, nous allons aller de l'avant
et le mettre en œuvre.

10
00:00:26,287 --> 00:00:27,687
C'est donc là que nous nous sommes arrêtés.

11
00:00:27,887 --> 00:00:29,912
Les choses fonctionnent en principe, mais

12
00:00:30,112 --> 00:00:32,299
nous appelons deux fonctions ici,

13
00:00:32,499 --> 00:00:34,587
choisissez un Mating Partner et Get Offspring

14
00:00:34,787 --> 00:00:36,412
que nous n'avons pas encore implémentés.

15
00:00:36,674 --> 00:00:39,062
Donc, ici, dans ce cour, notre objectif est d'implémenter

16
00:00:39,237 --> 00:00:40,937
ce choix de Mating Partner

17
00:00:41,137 --> 00:00:45,262
D'accord, donc l'idée est que nous
passons ces deux coordonnées

18
00:00:45,462 --> 00:00:48,537
si vous voulez, la grille,
les indices ii et i,

19
00:00:48,737 --> 00:00:51,187
et nous voulons choisir un Mating Partner

20
00:00:51,387 --> 00:00:55,449
compte tenu de ces coordonnées
et la distance max.

21
00:00:55,874 --> 00:00:58,273
Donc, nous allons avoir une fonction
quelque part ici,

22
00:00:58,498 --> 00:01:05,061
fonction pick_mating_partner.

23
00:01:05,999 --> 00:01:09,248
Bon, cela a deux paramètres,

24
00:01:09,448 --> 00:01:11,636
à savoir i et ii.

25
00:01:12,786 --> 00:01:15,886
Et, je voudrais revenir ici

26
00:01:17,136 --> 00:01:18,173
un Mating Partner.

27
00:01:18,948 --> 00:01:20,185
Compte tenu de ces valeurs

28
00:01:20,385 --> 00:01:21,960
et compte tenu de la distance d'accouplement

29
00:01:22,247 --> 00:01:24,185
que nous définissons dans le vars global

30
00:01:24,760 --> 00:01:26,785
Alors, comment pouvons-nous faire cela?

31
00:01:26,985 --> 00:01:31,122
Donc, nous allons zoomer
sur une grille 3X3 ici.

32
00:01:32,422 --> 00:01:38,997
D'accord.

33
00:01:39,622 --> 00:01:41,997
Et c'est, notre individu focal ici

34
00:01:42,197 --> 00:01:45,197
vivant aux coordonnées i et ii.

35
00:01:45,747 --> 00:01:47,947
Et nous pouvons, par exemple,
supposons que

36
00:01:48,147 --> 00:01:51,222
Ces coordonnées peuvent
être 5 et 4.

37
00:01:51,885 --> 00:01:53,947
Ok, alors pourquoi 3X3 maille?

38
00:01:54,147 --> 00:01:56,085
Eh bien, tout simplement parce que,
pour le moment

39
00:01:56,285 --> 00:01:59,385
Nous supposons maintenant que la distance
maximum d'accouplement est de 1 ici.

40
00:01:59,585 --> 00:02:03,685
Donc, ce serait la plage
d'accouplement acceptable, si vous voulez.

41
00:02:05,047 --> 00:02:09,685
Alors, comment pouvons-nous maintenant mapper
Ces éléments, ces cellules,

42
00:02:09,885 --> 00:02:12,172
à ce système de coordonnées?

43
00:02:12,372 --> 00:02:14,385
Eh bien, il est relativement simple.

44
00:02:14,585 --> 00:02:18,585
Si on diminue "i" de 1,
nous monterons

45
00:02:18,785 --> 00:02:21,597
pour l'augmenter de 1,
nous descendons.

46
00:02:21,797 --> 00:02:24,335
Ainsi, par exemple,
Ici, ce serait

47
00:02:24,535 --> 00:02:28,772
i-1, ii serait toujours le même.

48
00:02:29,447 --> 00:02:31,722
En bas ici ce serait

49
00:02:31,922 --> 00:02:35,822
i + 1, ii serait toujours le même.

50
00:02:37,646 --> 00:02:40,009
Inversement, si nous voulons
a droite ici,

51
00:02:40,209 --> 00:02:41,722
Ou à gauche,
nous allons garder

52
00:02:41,922 --> 00:02:46,272
i constant, mais nous diminuons

53
00:02:46,472 --> 00:02:49,084
ii par 1 ici, et nous augmentons

54
00:02:49,284 --> 00:02:51,759
ii par 1 ici.

55
00:02:53,059 --> 00:02:56,584
Et d'ailleurs, il n'y a rien d'inhérent

56
00:02:56,784 --> 00:02:59,897
à la dimension du tableau,
la première ou la seconde

57
00:03:00,097 --> 00:03:03,759
correspond à l'espace horizontal et à l'espace vertical.

58
00:03:04,509 --> 00:03:08,347
Je préfère penser, vous savez,
de cette façon,

59
00:03:08,547 --> 00:03:12,547
avec i allant. avec la première coordonnée
étant vertical,

60
00:03:12,747 --> 00:03:16,009
et la seconde dimension étant horizontale.

61
00:03:16,209 --> 00:03:20,184
Mais, vous savez, vous pouvez
penser à ce que vous voulez

62
00:03:20,471 --> 00:03:24,359
si vous trouvez qu'il est plus facile de retourner
ce modèle mentalement 90 degrés.

63
00:03:24,559 --> 00:03:26,084
ce sera exactement la même chose.

64
00:03:26,284 --> 00:03:30,034
D'accord, donc les valeurs concrètes
ici seraient 4 et 4

65
00:03:30,234 --> 00:03:33,234
et ici, par exemple, serait 6 et 4.

66
00:03:33,434 --> 00:03:37,221
Inversement, ici
5 et 4 + 1, donc 5

67
00:03:37,421 --> 00:03:40,484
5 et 4-1, donc 3.

68
00:03:41,496 --> 00:03:45,759
Et puis les cases de coin
sont également faciles à implémenter.

69
00:03:46,021 --> 00:03:49,359
Donc, ce serait i-1, d'accord?

70
00:03:49,559 --> 00:03:50,584
En remontant.

71
00:03:51,009 --> 00:03:54,696
et ii-1, en allant vers la gauche.

72
00:03:55,396 --> 00:03:58,271
Corrélativement ici, ce serait i-1 qui monte

73
00:03:58,471 --> 00:04:01,034
mais ii + 1 allant vers la droite.

74
00:04:01,234 --> 00:04:05,834
Ici, il serait i + 1 va vers le bas,

75
00:04:06,034 --> 00:04:08,934
et ii + 1, en allant vers la droite.

76
00:04:09,134 --> 00:04:11,484
Et i + 1, en descendant

77
00:04:11,684 --> 00:04:15,146
et ii-1, en allant vers la gauche.

78
00:04:15,346 --> 00:04:18,346
 

79
00:04:18,546 --> 00:04:20,746
Donc, les valeurs ici seraient 4 et 3,

80
00:04:21,096 --> 00:04:22,909
4 et 5

81
00:04:23,109 --> 00:04:25,234
6 et 5

82
00:04:26,347 --> 00:04:29,297
et 6 et 3.

83
00:04:29,497 --> 00:04:31,109
Donc, ce sont les valeurs acceptables ici

84
00:04:31,309 --> 00:04:33,534
dans la situation particulière.

85
00:04:33,734 --> 00:04:37,734
Et si nous pensons aux coordonnées

86
00:04:38,084 --> 00:04:41,659
du Mating Partner, de notre personne focale (i, ii)

87
00:04:42,234 --> 00:04:45,209
comme j et jj.

88
00:04:45,409 --> 00:04:46,534
alors il est relativement facile de voir
que les conditions suivantes ici

89
00:04:47,122 --> 00:04:54,422
doivent être vraies.

90
00:04:55,434 --> 00:04:56,009
Ainsi, j doit être égal ou supérieur à i-1.

91
00:04:56,209 --> 00:04:59,522
Pourquoi ?

92
00:04:59,722 --> 00:05:02,722
Eh bien, il doit être au moins i-1,
parce que sinon,

93
00:05:02,922 --> 00:05:04,709
Si elle serait plus petite,
Nous allions sortir des limites ici

94
00:05:05,397 --> 00:05:10,884
allant vers le haut.

95
00:05:11,084 --> 00:05:13,034
Corrélativement, de l'autre côté,
j doit être égale ou inférieure

96
00:05:13,259 --> 00:05:17,534
à i + 1, pourquoi?

97
00:05:17,734 --> 00:05:20,634
Eh bien, si elle était plus grande,
nous allions sortir du rebond ici.

98
00:05:21,709 --> 00:05:24,447
Donc, ce sont en quelque sorte
les limites minimum et maximales

99
00:05:24,984 --> 00:05:28,409
pour i ou j, plutôt.

100
00:05:28,647 --> 00:05:33,659
Et la même chose est exactement vraie
de penser à propos jj.

101
00:05:33,859 --> 00:05:36,859
Donc, jj doit être supérieur ou égal à ii-1.

102
00:05:37,059 --> 00:05:39,297
Donc, cela est maintenant la valeur minimale
allant vers la gauche

103
00:05:39,497 --> 00:05:42,497
Il ne peut pas être plus petit que cela,

104
00:05:42,697 --> 00:05:45,109
Sinon, nous allons, vous savez,
sorti de la limite sur la gauche.

105
00:05:45,309 --> 00:05:50,184
Et la même chose est vrai ici sur la droite.

106
00:05:50,384 --> 00:05:53,134
jj doit être inférieur ou égal à ii + 1

107
00:05:54,097 --> 00:05:57,047
Sinon, nous serions hors limites
ici sur le côté droit.

108
00:05:57,272 --> 00:05:59,934
Donc, pour être clair,
ce sont maintenant les valeurs principales

109
00:06:01,222 --> 00:06:03,334
et ce sont les valeurs maximales.

110
00:06:03,534 --> 00:06:05,272
L'autre chose que je tiens à mentionner

111
00:06:05,984 --> 00:06:09,497
est que nous pouvons
le rendre plus générique

112
00:06:09,697 --> 00:06:13,084
Il était plus facile de voir que
la raison pour laquelle nous avons -1 ici

113
00:06:14,097 --> 00:06:17,322
et +1 ici, est parce que le maximum
Distance Mating est 1.

114
00:06:17,522 --> 00:06:20,984
La distance maximale d'accouplement
génériquement,

115
00:06:21,172 --> 00:06:24,222
est tout simplement d,
et ainsi nous pouvons remplacer

116
00:06:26,047 --> 00:06:30,922
ce 1 ici avec d, si nous voulons
le rendre plus générique.

117
00:06:31,122 --> 00:06:34,822
Et maintenant, nous pouvons mettre en d
tout ce que nous aimerions.

118
00:06:35,022 --> 00:06:38,472
Ainsi, par exemple,
imaginer d étant égal à 2.

119
00:06:38,709 --> 00:06:41,322
Donc, cela signifie que maintenant d,
la valeur minimale ici

120
00:06:41,522 --> 00:06:43,672
serait i-2 qui monte,

121
00:06:43,872 --> 00:06:45,847
et i + 2 descendant,

122
00:06:46,059 --> 00:06:48,197
ou ii-2 allant vers la gauche

123
00:06:48,897 --> 00:06:51,722
et ii + 2 allant vers la droite.

124
00:06:51,922 --> 00:06:54,097
Donc, ce sont des limites acceptables.

125
00:06:54,297 --> 00:06:57,834
Ceux-ci, bien sûr, doivent être
des valeurs entières

126
00:06:58,034 --> 00:07:00,497
parce qu'ils sont des indices
de ce tableau à deux dimensions.

127
00:07:00,934 --> 00:07:04,322
Et nous pouvons maintenant
implémenter cela en JavaScript.

128
00:07:04,547 --> 00:07:09,047
D'accord, donc avec cette connaissance en main,
nous pouvons maintenant implémenter cela.

129
00:07:09,247 --> 00:07:14,334
Donc, nous pouvons configurer
ces variables, j et jj,

130
00:07:14,934 --> 00:07:16,647
et ceux-ci seraient les coordonnées Mating Partner.

131
00:07:17,272 --> 00:07:19,847
Donc, commençons par j.

132
00:07:20,809 --> 00:07:24,259
Donc, je sais maintenant qu'il y a
une plage acceptable

133
00:07:24,459 --> 00:07:28,034
et je voudrais simplement choisir
un nombre aléatoire

134
00:07:28,359 --> 00:07:30,509
de cette plage acceptable et concrètement
un nombre entier aléatoire

135
00:07:31,384 --> 00:07:33,709
parce que ceux-ci vont être
des indices du tableau.

136
00:07:33,909 --> 00:07:34,484
Donc, ce que je vais faire est que
je vais externaliser

137
00:07:34,697 --> 00:07:38,272
cela aussi.

138
00:07:38,484 --> 00:07:41,322
Je vais simplement dire,
donnez-moi un entier aléatoire ici

139
00:07:42,097 --> 00:07:45,184
donc je vais appeler
la fonction get_random_int,

140
00:07:45,384 --> 00:07:49,284
et je vais passer deux arguments ici

141
00:07:49,734 --> 00:07:55,997
À savoir, la valeur minimale
et la valeur maximale possible.

142
00:07:56,197 --> 00:07:58,534
Donc, comme nous savons maintenant que le minimum
Valeur est simplement i-d,

143
00:07:58,734 --> 00:08:03,659
ou plutôt, ici, dans notre citation,

144
00:08:04,947 --> 00:08:09,609
 

145
00:08:09,809 --> 00:08:10,934
max_mating_distance, parce que
c'est ce que nous avons appelé notre variable.

146
00:08:11,134 --> 00:08:15,434
Et la deuxième valeur, la valeur maximale

147
00:08:15,634 --> 00:08:16,197
ici de cet entier aléatoire

148
00:08:16,397 --> 00:08:19,734
serait tout simplement i plus
la distance maximale d'accouplement.

149
00:08:20,872 --> 00:08:26,309
D'accord ?

150
00:08:28,372 --> 00:08:30,884
max_mating_distance.

151
00:08:32,172 --> 00:08:35,272
Et avec exactement la même logique, nous pouvons
maintenant simplement copier cette ligne

152
00:08:35,472 --> 00:08:38,834
et dire, jj

153
00:08:39,034 --> 00:08:45,497
va appeler la même fonction,
mais bien sûr, ici,

154
00:08:46,797 --> 00:08:49,134
les valeurs minimales et maximales correctes

155
00:08:49,334 --> 00:08:52,859
sont ii-max_mating_distance
et ii+max_mating_distance.

156
00:08:53,034 --> 00:09:00,509
Donc, ce que je dois implémenter maintenant

157
00:09:00,822 --> 00:09:01,334
est tout simplement cette fonction
de get_random_int.

158
00:09:01,534 --> 00:09:05,296
Donc, je vais le faire ici.
function_get_random_int

159
00:09:05,558 --> 00:09:07,633
D'accord ?

160
00:09:08,558 --> 00:09:12,221
Et les deux paramètres,
je vais simplement les nommer "min" et "max"

161
00:09:12,421 --> 00:09:15,208
parce que ce sont les valeurs min et max.

162
00:09:16,046 --> 00:09:20,358
Je suis donc entrain donné ici
deux valeurs, deux nombres entiers.

163
00:09:20,558 --> 00:09:24,009
L'une est une valeur minimale,
et l'autre une valeur maximale,

164
00:09:24,209 --> 00:09:27,209
Et ce que je dois faire, est,
je dois revenir ici

165
00:09:27,584 --> 00:09:29,121
un nombre aléatoire qui est dans
la plage acceptable

166
00:09:29,321 --> 00:09:31,046
de cette valeur minimale et
cette valeur maximale.

167
00:09:31,246 --> 00:09:33,196
Alors, comment pourrais-je faire cela?

168
00:09:33,396 --> 00:09:37,446
Nous avons toutes les connaissances
JavaScript

169
00:09:38,171 --> 00:09:41,083
nécessaires pour implémenter cette méthode.

170
00:09:41,283 --> 00:09:42,633
Nous commençons toujours par Math.random
si nous voulons un nombre aléatoire.

171
00:09:42,833 --> 00:09:45,458
Math.random présente
cependant deux problèmes,

172
00:09:45,658 --> 00:09:47,471
ou plutôt trois, pour nous.

173
00:09:47,833 --> 00:09:52,758
Tout d'abord, il retourne
un nombre à virgule flottant.

174
00:09:52,958 --> 00:09:53,996
Nous ne voulons ça, nous voulons un entier /

175
00:09:54,196 --> 00:09:57,308
La seconde est que, sa plage est 1, non?

176
00:09:57,621 --> 00:09:59,521
Il va de 0 à 1.

177
00:09:59,721 --> 00:10:01,371
Nos plages doivent être
généralement beaucoup plus grande.

178
00:10:02,346 --> 00:10:05,871
Disons que nous avons une valeur minimale 3

179
00:10:06,071 --> 00:10:08,808
et une valeur maximale de 6.

180
00:10:09,008 --> 00:10:11,296
La plage doit être beaucoup plus grande, non?

181
00:10:11,496 --> 00:10:14,683
Il faut aller de 3 à 6.

182
00:10:14,883 --> 00:10:16,871
C'est une plage de 3.

183
00:10:17,071 --> 00:10:21,421
Ou bien, vous savez,
si vous regardez réellement l'entier,

184
00:10:22,258 --> 00:10:23,708
il est en fait une série de 4,
pour ainsi dire,

185
00:10:23,921 --> 00:10:27,083
car il dispose de 4 valeurs, 3, 4, 5 et 6.

186
00:10:27,283 --> 00:10:30,633
Et puis le dernier numéro

187
00:10:30,833 --> 00:10:33,833
est que Math, Random commence toujours à 0.

188
00:10:34,033 --> 00:10:35,921
Il dispose d'une plage de 1,
mais il est toujours fixé à 0.

189
00:10:36,121 --> 00:10:39,308
Nos plages commencent à des valeurs
très différentes.

190
00:10:39,483 --> 00:10:41,433
Quelles que soient les valeurs min, en fait.

191
00:10:41,633 --> 00:10:44,183
Bon, alors comment pouvons-nous
prendre maintenant ce Math, Random

192
00:10:44,408 --> 00:10:45,683
et corriger ces trois problèmes?

193
00:10:45,883 --> 00:10:48,958
Eh bien, fixons d'abord la plage

194
00:10:49,158 --> 00:10:52,158
parce qu'il est relativement facile.

195
00:10:52,358 --> 00:10:56,183
Nous venons de le multiplier par
la plage que nous avons besoin.

196
00:10:56,383 --> 00:10:57,483
 

197
00:10:58,258 --> 00:11:01,483
Dans notre cas, il faut multiplier avec

198
00:11:01,696 --> 00:11:03,008
{Max-min} + 1.

199
00:11:04,508 --> 00:11:10,258
Pourquoi ?

200
00:11:10,458 --> 00:11:12,546
Eh bien encore une fois,
prenez cet exemple de la valeur min de 3

201
00:11:12,746 --> 00:11:16,033
et une valeur max de 6.

202
00:11:16,233 --> 00:11:21,770
Donc, la plage ici est de 3,
dans le monde en virgule flottante

203
00:11:21,983 --> 00:11:25,871
ou vraiment quatre,
nous avons quatre valeurs.

204
00:11:27,496 --> 00:11:29,658
Je suis dans le monde des entiers
3, 4, 5 et 6.

205
00:11:29,858 --> 00:11:33,621
Ainsi, max moins min
couvre la plage correctement

206
00:11:33,821 --> 00:11:35,708
Mais nous devons ajouter 1
pour tenir compte de cette quatrième valeur.

207
00:11:35,908 --> 00:11:38,258
Et maintenant, nous devons corriger plage

208
00:11:38,458 --> 00:11:43,071
Mais il est encore en virgule flottante,
donc maintenant nous avons besoin de d'arrondir cela.

209
00:11:43,320 --> 00:11:46,271
Ok, Math.Floor

210
00:11:46,746 --> 00:11:49,096
que nous avons utilisé auparavant,
qui prend simplement

211
00:11:49,320 --> 00:11:50,708
une virgule flottante,
une valeur, et le réduit

212
00:11:50,908 --> 00:11:53,833
ou il le diminue à l'entier le plus proche.

213
00:11:54,020 --> 00:11:55,021
Là encore, dans le cas d'un minimum de 3

214
00:11:55,221 --> 00:11:57,883
et un maximum de 6,

215
00:11:58,083 --> 00:12:02,871
ce serait 6 moins 3 de sorte que ce soit 3

216
00:12:04,033 --> 00:12:07,096
plus 1 est 4

217
00:12:07,296 --> 00:12:10,296
Donc, nous multiplions
Math, a des moments aléatoires 4

218
00:12:10,496 --> 00:12:11,983
de sorte que nous avons
une plage de 0 à 3,999999999

219
00:12:12,470 --> 00:12:15,958
Nous arrondissons ça,
ce qui signifie que nous obtenons maintenant

220
00:12:16,158 --> 00:12:20,046
les valeurs de 0, 1, 2 et 3.

221
00:12:20,246 --> 00:12:23,683
Ils sont les valeurs possibles.

222
00:12:23,883 --> 00:12:28,221
Maintenant, il n'y a qu'une seule chose
qui ne va pas sur ce

223
00:12:28,483 --> 00:12:31,171
que nous devons corriger la plage,
il renvoie des valeurs entières

224
00:12:32,196 --> 00:12:34,808
mais il renvoie les mauvaises

225
00:12:35,008 --> 00:12:37,808
parce que nous commençons à 0, mais
en fait, nous devons commencer à min.

226
00:12:38,546 --> 00:12:40,708
Donc, nous ajoutons simplement min.

227
00:12:40,921 --> 00:12:43,508
Donc maintenant les valeurs correctes
qui seront retournées

228
00:12:43,708 --> 00:12:46,883
sont 3, 4, 5 et 6.

229
00:12:47,108 --> 00:12:50,846
Bon, maintenant,
nous allons tout simplement ajouter ici

230
00:12:51,496 --> 00:12:52,833
bien sûr, cette déclaration de retour

231
00:12:53,033 --> 00:12:56,808
cela retourne en fait cette valeur.

232
00:12:57,183 --> 00:12:59,121
Maintenant que nous avons implémenté
cette fonction int get_random

233
00:12:59,321 --> 00:13:01,895
nous sommes pratiquement là.

234
00:13:02,308 --> 00:13:03,583
Donc, nous avons maintenant un j,
et nous avons un jj.

235
00:13:03,783 --> 00:13:05,908
Mais il y a un autre problème ici

236
00:13:06,108 --> 00:13:09,996
et qui a à voir avec les frontières.

237
00:13:10,196 --> 00:13:12,008
Alors, jetons y un coup oeil.

238
00:13:12,208 --> 00:13:14,095
Donc, le problème a à voir avec
les frontières

239
00:13:14,496 --> 00:13:16,608
et rappelez-vous ici, sur cette grille,
nous voyons des frontières

240
00:13:16,808 --> 00:13:18,820
mais nous ne voulons pas les frontières,
n'est ce pas?

241
00:13:19,020 --> 00:13:22,183
Si nous avons un individu ici,

242
00:13:22,383 --> 00:13:25,658
et cet individu se déplace vers la droite

243
00:13:25,870 --> 00:13:29,295
ou plutôt, si nous voulons juste considérer

244
00:13:29,495 --> 00:13:34,295
son voisin de droite,
ainsi il n'y a pas de voisin ici

245
00:13:34,495 --> 00:13:36,670
mais nous avons dit, ok, les frontières
essentiellement n'existe pas.

246
00:13:36,870 --> 00:13:38,864
Si vous allez ici,
vous entrerez ici.

247
00:13:39,064 --> 00:13:42,141
Donc, vraiment cette cellule ici est
le bord droit de cette cellule.

248
00:13:42,341 --> 00:13:44,691
Et si c'est un individu vivant ici,

249
00:13:45,091 --> 00:13:46,329
et le Mating Distance serait un

250
00:13:46,529 --> 00:13:48,741
alors nous savons, que
le Quartier d'accouplement

251
00:13:48,929 --> 00:13:50,341
est ce domaine ici.

252
00:13:50,541 --> 00:13:52,704
Donc, nous pouvons dire que

253
00:13:52,904 --> 00:13:55,854
mais bien sûr, nous avons aussi à
implémenter ça,

254
00:13:56,054 --> 00:13:58,966
et comment allons-nous l'implémenter?

255
00:13:59,166 --> 00:14:01,816
Eh bien, l'astuce vraiment,
ou le problème

256
00:14:02,016 --> 00:14:03,804
est qu'ici, dans un tableau de dix éléments,

257
00:14:04,004 --> 00:14:06,629
ce serait un indice de 9.

258
00:14:06,829 --> 00:14:09,316
Si nous disons maintenant, okay
nous voulons passer à la suivante,

259
00:14:09,516 --> 00:14:10,341
alors nous allons tout simplement ajouter 1

260
00:14:10,541 --> 00:14:13,629
alors nous allons ajouter un index 10

261
00:14:13,816 --> 00:14:16,104
et l'indice 10
dans un tableau de dix éléments

262
00:14:16,616 --> 00:14:18,776
n'existe pas

263
00:14:18,976 --> 00:14:20,851
Comme vous le savez,
les indices commencent à 0,

264
00:14:21,126 --> 00:14:23,701
et ainsi, le plus grand index

265
00:14:23,901 --> 00:14:27,099
pour un tableau avec dix éléments est 9.

266
00:14:27,299 --> 00:14:29,461
Ainsi, ce serait une erreur.

267
00:14:30,586 --> 00:14:34,976
Vice versa, d'autre part,
si nous sommes ici,

268
00:14:35,119 --> 00:14:35,969
à l'index 0, et nous voulons
aller à gauche,

269
00:14:36,156 --> 00:14:39,944
Nous soustrayions -1.

270
00:14:40,094 --> 00:14:43,144
puis, nous serions à l'indice -1,
qui serait également une erreur

271
00:14:43,344 --> 00:14:44,737
en JavaScript.

272
00:14:44,937 --> 00:14:48,225
Nous avons donc en quelque sorte à
cartographier ces mauvais indices

273
00:14:48,425 --> 00:14:50,723
alors nous calculons les indices corrects.

274
00:14:50,923 --> 00:14:57,011
Alors, comment allons-nous faire cela?

275
00:14:57,323 --> 00:14:59,555
La meilleure façon de penser
est de tracer ce tableau

276
00:14:59,755 --> 00:15:03,765
donc, encore une fois,
nous allons supposer dix éléments ici.

277
00:15:03,965 --> 00:15:06,543
donc, 0..1..2..3..
4..5..6..

278
00:15:06,981 --> 00:15:09,360
7..8 et 9

279
00:15:10,222 --> 00:15:12,270
et nous pouvons maintenant dire,
d'accord, cela est essentiellement ici

280
00:15:13,582 --> 00:15:16,386
cette boîte de cellules.

281
00:15:16,586 --> 00:15:17,328
Ok, donc ce sont des cellules ici

282
00:15:17,528 --> 00:15:19,060
ou simplement les éléments du tableau.

283
00:15:19,260 --> 00:15:22,453
Et si nous sommes ici, par exemple,
et nous voulons aller à la gauche

284
00:15:22,653 --> 00:15:23,940
c'est facile, non?

285
00:15:24,140 --> 00:15:26,278
-1, Et nous sommes là.

286
00:15:26,478 --> 00:15:28,303
Nous voulons aller à droite,
+1 et nous sommes là.

287
00:15:28,503 --> 00:15:31,290
Alors, qui est simple.

288
00:15:31,490 --> 00:15:32,566
Mais, qu'en est-il de la question ici?

289
00:15:32,766 --> 00:15:33,761
Donc, ici, nous aimerions aller 1 à droite.

290
00:15:33,961 --> 00:15:37,677
Ok, +1, ouais qui est de 10.

291
00:15:37,877 --> 00:15:39,052
Ce n'est pas bon.

292
00:15:39,489 --> 00:15:44,405
Même problème ici.

293
00:15:44,605 --> 00:15:47,604
De 0, -1 à gauche, nous sommes à -1,

294
00:15:47,804 --> 00:15:50,804
Ce n'est pas bon.

295
00:15:51,004 --> 00:15:54,155
Vraiment ce que nous voulons
est que nous voulons une sorte de courbure

296
00:15:54,355 --> 00:15:57,113
sur ce tableau ici,
de sorte qu'il devient un cercle.

297
00:15:57,313 --> 00:16:03,058
Alors, pensez-y comme ça ici

298
00:16:03,971 --> 00:16:06,908
Donc, nous aimerions maintenant plier
et refixer les extrémités libres

299
00:16:08,071 --> 00:16:10,508
à l'autre, et cela a
été notre frontière précédente ici.

300
00:16:10,708 --> 00:16:13,944
C'est donc l'élément 0, et ainsi de suite.
Voici quelques éléments

301
00:16:14,106 --> 00:16:16,122
et puis finalement ici,
cela est Element 9.

302
00:16:16,394 --> 00:16:20,306
Et maintenant,
il faut juste aller de cette façon.

303
00:16:21,169 --> 00:16:23,506
Donc, si vous allez de zéro ici,

304
00:16:23,706 --> 00:16:26,069
alors vous fait atterrir à neuf.

305
00:16:26,244 --> 00:16:28,492
Et si vous allez de neuf ici,
vous allez simplement atterrir à zéro.

306
00:16:28,667 --> 00:16:30,125
Alors maintenant,
cette frontière n'existe plus

307
00:16:30,325 --> 00:16:31,580
nous pouvons simplement
sauter en avant ici dans ce cercle

308
00:16:31,993 --> 00:16:35,855
à gauche et à droite,
aussi loin que nous voulons

309
00:16:36,043 --> 00:16:38,771
Nous ne serons jamais
confrontés à ce problème.

310
00:16:38,971 --> 00:16:41,565
Alors, comment faisons-nous cela?

311
00:16:41,765 --> 00:16:44,261
Eh bien, nous pouvons, en quelque sorte,
implémenter exactement ce cercle

312
00:16:44,461 --> 00:16:48,535
simplement en imaginant
que votre tableau

313
00:16:48,885 --> 00:16:51,270
continuerait ici

314
00:16:51,470 --> 00:16:55,570
Ok, donc ce serait le même tableau.

315
00:16:55,770 --> 00:16:58,824
Donc, ici sera 0..1 .. 2.. et ainsi de suite.

316
00:16:59,649 --> 00:17:03,788
Il suffit de prendre le tableau
et le mettre ici.

317
00:17:04,201 --> 00:17:06,301
Même chose ici, imaginez le tableau ici

318
00:17:06,801 --> 00:17:10,173
continuerait ou serait attaché à la gauche

319
00:17:10,373 --> 00:17:12,988
Donc, ce serait, dans ce cas, 9 ... 8..7

320
00:17:13,188 --> 00:17:18,092
juste ce tableau ici.

321
00:17:19,129 --> 00:17:22,376
Et maintenant, c'est relativement plus facile
Pour voir ici, nous allons -1,

322
00:17:22,576 --> 00:17:25,810
ici nous avons -2, ici nous avons -3

323
00:17:26,010 --> 00:17:28,283
Vice versa, ici nous avons +1,
ici nous avons +2, +3 ici nous avons,

324
00:17:28,483 --> 00:17:31,419
Donc, le problème est,
mathématiquement parlant,

325
00:17:31,619 --> 00:17:35,251
que de 0 à -1, nous obtenons à -1.

326
00:17:35,451 --> 00:17:40,394
De 0 à -2, nous obtenons à -2.

327
00:17:41,857 --> 00:17:45,283
De 0 à -3 nous obtenons à -3.

328
00:17:45,633 --> 00:17:46,779
Ce ne sont pas des valeurs correctes
en termes de la matrice.

329
00:17:46,979 --> 00:17:49,889
Nous avons besoin de cartographier
ces valeurs, les indices, à ces indices.

330
00:17:51,714 --> 00:17:52,583
D'accord, et alors nous avons
implémenter ce cercle.

331
00:17:52,783 --> 00:17:55,040
Même ici, n'est ce pas?

332
00:17:55,240 --> 00:17:58,010
De 10 plus 1, nous serions à l'indice 10.

333
00:17:58,210 --> 00:18:00,673
Désolé, 9 plus 1.

334
00:18:00,873 --> 00:18:02,991
9 plus 2, nous serions à 11 Index.

335
00:18:03,191 --> 00:18:05,979
9 plus 3, nous serions à l'index 12
et ainsi de suite.

336
00:18:06,179 --> 00:18:08,405
Ce ne sont pas des indices corrects
pour le tableau.

337
00:18:09,280 --> 00:18:10,437
Ce que nous devons faire,
nous avons besoin est de cartographier

338
00:18:11,112 --> 00:18:14,125
ceux des tableaux corrects ici.

339
00:18:14,962 --> 00:18:19,062
0, 1 et 2.

340
00:18:19,262 --> 00:18:22,262
Alors, comment faisons-nous cela?

341
00:18:22,762 --> 00:18:25,869
Eh bien, je pense qu'il est
relativement simple de voir ici.

342
00:18:26,069 --> 00:18:28,197
Ce que nous devons faire est, nous devons
commencer à partir de ce nouvel indice

343
00:18:28,822 --> 00:18:30,658
et d'abord vérifier si elle est incorrecte,
si elle est incorrecte,

344
00:18:31,108 --> 00:18:32,878
eh bien, il est soit négatif

345
00:18:33,078 --> 00:18:35,120
ou supérieure à la valeur
maximale disponible.

346
00:18:36,370 --> 00:18:41,264
Donc, si elle est sur l'extrémité négative,

347
00:18:41,464 --> 00:18:43,087
alors, ce que nous allons faire
est que nous allons prendre

348
00:18:43,287 --> 00:18:47,001
ce nouvel indice que nous avons calculé,

349
00:18:48,039 --> 00:18:50,915
et nous sommes maintenant simplement entrain
d'aller ajouter la longueur du tableau,

350
00:18:51,602 --> 00:18:55,765
dans cet exemple, ici, est 10.

351
00:18:57,890 --> 00:19:01,258
Ainsi, par exemple,
nous prendrions cette valeur -2 ici

352
00:19:01,446 --> 00:19:03,971
et nous voudrions simplement ajouter 10.

353
00:19:04,271 --> 00:19:06,357
Et cela, bien sûr,
nous donnerait la cartographie correcte, 8.

354
00:19:06,582 --> 00:19:09,147
Ici, nous testons cela
et nous nous rendons compte,

355
00:19:09,347 --> 00:19:10,828
d'accord, l'indice est trop élevé,

356
00:19:11,565 --> 00:19:15,054
Ce que nous allons faire est très similaire.

357
00:19:15,254 --> 00:19:16,555
Je vais prendre ce nouvel indice
que nous avons calculé

358
00:19:17,043 --> 00:19:20,412
mais qui est trop élevé.

359
00:19:21,387 --> 00:19:22,765
Et nous allons soustraire ici la longueur

360
00:19:22,965 --> 00:19:27,209
à partir de cette valeur.

361
00:19:27,409 --> 00:19:29,360
Et ainsi, à titre d'exemple ici,
nous prendrons 11.

362
00:19:30,385 --> 00:19:32,892
Alors, évidemment trop élevé.

363
00:19:33,092 --> 00:19:35,872
Nous allons soustraire 10,
ce qui nous donne la cartographie correcte

364
00:19:36,922 --> 00:19:39,044
l'indice correct, 1.

365
00:19:39,244 --> 00:19:40,489
Donc, ceci est la meilleure façon de penser

366
00:19:40,689 --> 00:19:44,742
et nous sommes maintenant prêts
à l'implémenter en JavaScript.

367
00:19:44,942 --> 00:19:47,629
Bon, maintenant que nous savons
comment résoudre cela,

368
00:19:47,829 --> 00:19:48,944
implémentons cela, d'accord?

369
00:19:49,144 --> 00:19:51,395
Donc, nous savons maintenant que nous
ne pouvons pas travailler avec les valeurs de j et jj,

370
00:19:51,595 --> 00:19:56,177
en tant que tels, parce qu'ils
pourraient être hors des limites.

371
00:19:56,377 --> 00:19:58,872
Donc, ce que je vais faire

372
00:19:59,072 --> 00:20:02,354
est quelque chose de très simple.

373
00:20:02,554 --> 00:20:07,979
Je vais simplement passer
ces deux valeurs, j et jj,

374
00:20:08,254 --> 00:20:09,504
par une fonction qui vérifie

375
00:20:11,291 --> 00:20:15,417
si elles sont en effet dans les limites,

376
00:20:15,592 --> 00:20:17,208
et si elles ne sont pas,
qu'ils seront remplacés par l'indice correct.

377
00:20:17,408 --> 00:20:20,090
Donc, ce que je vais faire ici,

378
00:20:20,915 --> 00:20:24,465
simplement, je vais dire j est égal à
l'indice get_bounded.

379
00:20:24,665 --> 00:20:27,236
Donc, cela est une fonction
que nous allons définir

380
00:20:27,436 --> 00:20:30,316
et je vais passer j, d'accord?

381
00:20:30,516 --> 00:20:32,850
Donc, ce que cela fait,
st simplement passer la valeur j

382
00:20:33,050 --> 00:20:35,472
que j'ai eu ici,

383
00:20:35,672 --> 00:20:37,513
à cette fonction,
qui vérifie si tout va bien

384
00:20:37,951 --> 00:20:41,046
et si elle est pas bonn, il va réparer

385
00:20:41,584 --> 00:20:47,163
puis tout ce qu'il retourne,
je peux être sûr

386
00:20:47,363 --> 00:20:49,213
que cela est maintenant une valeur correcte.

387
00:20:49,988 --> 00:20:52,301
Donc, je vais faire exactement
la même chose avec j.

388
00:20:52,489 --> 00:20:56,965
Donc, je vais dire,
jj est égal à get_bounded_index

389
00:20:57,228 --> 00:20:58,778
et je vais passer jj ici.

390
00:20:58,978 --> 00:21:04,414
Donc, encore une fois,
tout ce qui vient de cette fonction,

391
00:21:04,614 --> 00:21:10,418
après qu'il a traité avec jj
est une bonne valeur (inaudible) pour jj.

392
00:21:13,293 --> 00:21:16,055
Donc, je vais la stocker ici

393
00:21:16,360 --> 00:21:19,010
Et puis, quand c'est bon, alors je peux
retournez enfin ce Mating Partner

394
00:21:19,773 --> 00:21:21,648
qui se trouve sur la grille [j] [jj].

395
00:21:21,885 --> 00:21:22,946
Bon, ce que nous devons faire

396
00:21:24,409 --> 00:21:32,296
est que nous devons implémenter cette fonction

397
00:21:33,359 --> 00:21:36,160
get_bounded_index.

398
00:21:36,360 --> 00:21:39,160
Faisons-le ici.

399
00:21:39,423 --> 00:21:41,511
Ainsi, la fonction get_bounded_index.

400
00:21:43,224 --> 00:21:47,085
et donc, je vais appeler

401
00:21:47,810 --> 00:21:49,599
ce paramètre ici, simplement, index.

402
00:21:50,287 --> 00:21:53,399
Telle est la valeur que je vais obtenir.

403
00:21:53,599 --> 00:21:55,237
Alors maintenant, je dois veiller à ce que
cet indice soit correct.

404
00:21:55,437 --> 00:21:58,774
Alors, que devons-nous faire?

405
00:21:58,974 --> 00:22:02,041
Eh bien, je dois d'abord vérifier si l'index

406
00:22:02,241 --> 00:22:06,430
est correcte lui-même.

407
00:22:06,630 --> 00:22:08,805
Il peut être faux de deux manières,
il peut être soit inférieur à zéro

408
00:22:09,005 --> 00:22:11,735
ou il pourrait être plus grand
que la longueur de la grille.

409
00:22:11,985 --> 00:22:13,422
Dans ce cas,
il faudrait que je fixe la valeur.

410
00:22:13,597 --> 00:22:14,647
Si aucune de ces deux
conditions sont vraies

411
00:22:14,884 --> 00:22:18,038
alors l'indice est déjà tout à fait correct.

412
00:22:18,238 --> 00:22:21,288
Et je ne peux pas le retourner.

413
00:22:23,063 --> 00:22:26,188
Donc, ce que je vais faire

414
00:22:26,388 --> 00:22:28,097
est que je vais simplement
stocker temporairement l'indice ici

415
00:22:28,297 --> 00:22:30,532
dans cette variables bounded_index

416
00:22:31,082 --> 00:22:34,345
Bon, et cet index borné
est finalement

417
00:22:34,520 --> 00:22:37,070
ce que je vais retourner.

418
00:22:37,270 --> 00:22:39,752
Ok, bounded_index.

419
00:22:39,952 --> 00:22:42,165
Maintenant, ici, en ce moment,
ce serait une fonction relativement stupide

420
00:22:42,365 --> 00:22:45,107
elle obtiendrait simplement l'index,
Elle y stockerait la variable

421
00:22:45,470 --> 00:22:47,948
et immédiatement retournerait cette variable.

422
00:22:48,148 --> 00:22:50,648
Donc, elle ne serait réellement
pas faire quoi que ce soit.

423
00:22:50,848 --> 00:22:51,936
Donc, ce sera le cas par défaut

424
00:22:52,136 --> 00:22:55,573
si l'indice est en effet bon.

425
00:22:56,011 --> 00:22:58,911
Ce que je vais implémenter maintenant
est le scénario

426
00:22:59,111 --> 00:23:01,518
où il n'est pas bon.

427
00:23:01,718 --> 00:23:03,114
Donc, il peut être incorrecte
dans deux cas possibles.

428
00:23:03,801 --> 00:23:06,834
Ainsi, il pourrait être soit que l'indice

429
00:23:07,034 --> 00:23:10,034
est inférieur à zéro, d'accord?

430
00:23:10,534 --> 00:23:13,109
Plus petit que zéro.

431
00:23:13,509 --> 00:23:16,309
Donc, comme nous l'avons vu,
ce que nous devons faire dans ce cas,

432
00:23:16,509 --> 00:23:19,809
est que nous avons simplement
besoin de prendre l'indice

433
00:23:20,097 --> 00:23:26,109
D'accord, sur les slides,
nous allons appeler ce nouvel indice

434
00:23:26,384 --> 00:23:29,147
et nous avons besoin d'ajouter
la longueur de la grille.

435
00:23:33,909 --> 00:23:36,408
qui est stocké dans
la variable globale grid_length.

436
00:23:36,608 --> 00:23:38,081
D'accord, donc qui est
notre indice borné corrigé.

437
00:23:38,556 --> 00:23:44,356
Je vais donc le stocker
dans l'index borné.

438
00:23:46,881 --> 00:23:50,069
L'autre option est que

439
00:23:50,269 --> 00:23:51,994
l'indice est trop grand.

440
00:23:52,194 --> 00:23:54,356
Donc, je vais simplement dire
si l'index est plus grand

441
00:23:54,544 --> 00:23:56,306
ou égale à grid_length.

442
00:23:56,506 --> 00:23:59,444
Ne pas oublier l'égalité

443
00:23:59,944 --> 00:24:02,644
parce que si elle est égale à
la longueur de la grille

444
00:24:02,844 --> 00:24:05,406
elle est trop grande

445
00:24:05,606 --> 00:24:06,956
parce que nous rappelons à nouveau,
que les indices

446
00:24:07,156 --> 00:24:09,177
du tableau commencer à zéro,
de sorte que la valeur max

447
00:24:09,377 --> 00:24:10,977
n'est pas la longueur du tableau

448
00:24:11,252 --> 00:24:14,690
mais une longueur de moins.

449
00:24:14,890 --> 00:24:18,165
Par conséquent,
si elle est en fait égale à la longueur,

450
00:24:18,365 --> 00:24:23,302
il est déjà trop grande.

451
00:24:24,965 --> 00:24:27,140
Bon, alors dans ce cas,
nous avons vu que la bonne façon

452
00:24:29,690 --> 00:24:31,752
de résoudre ce problème ici serait
tout simplement, de dire,

453
00:24:31,940 --> 00:24:34,290
prendre l'index, et maintenant
soustraire grid_length de lui.

454
00:24:34,490 --> 00:24:37,840
Minus, grid_lenth.

455
00:24:38,040 --> 00:24:39,077
D'accord, ici,
maintenant je sais

456
00:24:39,277 --> 00:24:42,052
que cet index borné est correct.

457
00:24:42,265 --> 00:24:45,290
Soit rien n'a été fait,
si aucun de ces "if" était vrai

458
00:24:45,815 --> 00:24:49,065
alors il est bon.

459
00:24:49,265 --> 00:24:51,065
Si l'indice est plus petit,
il est maintenant corrigé.

460
00:24:51,265 --> 00:24:53,640
Si il est trop grande,
il est maintenant corrigé.

461
00:24:53,840 --> 00:24:54,715
Remarquez également
que je n'utilise pas «if-else".

462
00:24:54,915 --> 00:24:57,740
Le "else" ici ne serait pas correct

463
00:24:57,940 --> 00:25:01,390
parce que si je dis que
si l'indice est négatif,

464
00:25:01,590 --> 00:25:03,702
"sinon"

465
00:25:03,902 --> 00:25:06,190
alors cela inclurait
même les indices corrects.

466
00:25:06,390 --> 00:25:09,686
Voilà pourquoi, j'ai simplement ajouté un second «if».

467
00:25:11,023 --> 00:25:14,536
Donc, je vérifie d'abord
si cette condition est vraie,

468
00:25:14,736 --> 00:25:17,148
puis je vérifie,
si cette condition est vraie.

469
00:25:17,348 --> 00:25:20,086
Je sais qu'ils sont exclusifs,
donc, tous bon ici.

470
00:25:20,548 --> 00:25:21,998
Très bien, alors, je termine ce cours.

471
00:25:22,198 --> 00:25:25,636
Nous avons maintenant
correctement implémenté

472
00:25:25,836 --> 00:25:29,223
la fonctionnalité Mating Partner

473
00:25:29,423 --> 00:25:31,873
en disant simplement

474
00:25:32,073 --> 00:25:33,511
nous devons définir ici le bon rebond

475
00:25:33,711 --> 00:25:37,598
de notre sous-grille

476
00:25:37,798 --> 00:25:39,686
qui est la zone Mating

477
00:25:39,886 --> 00:25:42,723
la zone Mating acceptable.

478
00:25:43,836 --> 00:25:45,561
Ensuite, nous avons besoin d'obtenir les nombres
entiers aléatoires correspondants.

479
00:25:45,786 --> 00:25:48,273
pour cette sous-grille

480
00:25:48,473 --> 00:25:52,511
Et donc nous implémentons
Avec cette fonction "get_random_int".

481
00:25:53,161 --> 00:25:58,561
Et puis, nous avons corrigé le fait

482
00:25:58,761 --> 00:26:00,336
que ces indices peuvent être hors limite

483
00:26:00,536 --> 00:26:02,273
et nous avons fait cela en utilisant
cette fonction "get_bounded_index".

484
00:26:02,473 --> 00:26:05,973
Donc, cela semble beaucoup de code
ou du moins beaucoup de logique ici

485
00:26:06,173 --> 00:26:08,661
et cela est vrai, mais rappelez-vous,

486
00:26:08,861 --> 00:26:10,998
vous pouvez maintenant réutiliser ce code

487
00:26:11,261 --> 00:26:14,648
dans toute simulation spatiale
que vous allez implémenter.

488
00:26:14,848 --> 00:26:16,948
indépendamment de la question
à portée de main.

489
00:26:17,148 --> 00:26:20,723
Ici nous avons une question évolutive.

490
00:26:20,923 --> 00:26:23,736
Nous nous soucions de modèles spatiaux,
nous soucions de (inaudible) et ainsi de suite

491
00:26:23,936 --> 00:26:25,686
mais vous pouvez utiliser ce même code

492
00:26:25,886 --> 00:26:27,473
pour implémenter un processus dans l'espace.

493
00:26:27,673 --> 00:26:32,798
C'est donc une connaissance
très puissante ici.

494
00:26:32,998 --> 00:26:34,986
Bon, dans la prochaine session,

495
00:26:35,223 --> 00:26:36,848
nous devrons prendre soin

496
00:26:37,048 --> 00:26:38,273
de la fonction finale
que nous avons pas encore implémenté,

