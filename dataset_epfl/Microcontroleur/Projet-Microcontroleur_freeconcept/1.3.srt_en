1
00:00:00,000 --> 00:00:05,370
Now let's talk about logical systems

2
00:00:05,370 --> 00:00:10,835
that make it possible to build specialized
machines, and in particular

3
00:00:10,835 --> 00:00:15,489
microcontrollers. The basic elements are

4
00:00:15,489 --> 00:00:20,558
doors that can be assembled to form

5
00:00:20,558 --> 00:00:25,716
intermediate blocks, which will
be assembled themselves

6
00:00:25,716 --> 00:00:30,660
to make machines. Then, the first
element that we already have,

7
00:00:30,660 --> 00:00:35,690
found, is the logical inverter that actually has

8
00:00:35,690 --> 00:00:40,805
two states. The entry can be zero and

9
00:00:40,805 --> 00:00:45,990
one.The output is simply the reverse,

10
00:00:45,990 --> 00:00:50,820
if it's a zero, we have one;
If it is one, it is a zero.

11
00:00:50,820 --> 00:00:56,790
The next thing that everyone
knows is the AND gate,

12
00:00:56,790 --> 00:01:02,432
with four possibilities, I note A, B, I

13
00:01:02,432 --> 00:01:08,473
could go on, if there were more entries;
I have an output S.

14
00:01:08,473 --> 00:01:15,072
The possible combinations, they are noted
according to the binary numbering,

15
00:01:15,072 --> 00:01:16,280
usually.

16
00:01:16,280 --> 00:01:24,015
And then, the exit is at one, if
the two entries are at one.

17
00:01:24,015 --> 00:01:29,380
So, here is the truth table of the

18
00:01:29,380 --> 00:01:34,376
AND function, which can
be realized with

19
00:01:34,376 --> 00:01:39,574
transistors, which are called
the, uh, AND gate,

20
00:01:39,574 --> 00:01:44,880
uh, and traditionally, uh,
we write A times

21
00:01:44,880 --> 00:01:50,073
B, for this AND gate . The OR
gate is also well known;

22
00:01:50,073 --> 00:01:55,318
I will let you make the table
of truth. We use the plus sign,

23
00:01:55,318 --> 00:02:00,612
and the last basic element is

24
00:02:00,612 --> 00:02:05,410
the exclusive OR gate,

25
00:02:05,410 --> 00:02:10,138
in English, XOR, which says

26
00:02:10,138 --> 00:02:15,172
one or the other, but

27
00:02:15,172 --> 00:02:20,512
not both. There are others

28
00:02:20,512 --> 00:02:26,080
doors, since we see that there
could be other tables of truth.

29
00:02:26,080 --> 00:02:30,531
But, this is where the logic
systems show that

30
00:02:30,531 --> 00:02:35,712
all these gates can be generated,

31
00:02:35,712 --> 00:02:41,420
only from the inverter and the AND gate.

32
00:02:41,420 --> 00:02:47,450
But we must still have in mind, the existence of these

33
00:02:47,450 --> 00:02:51,662
four functions, which we will find

34
00:02:51,662 --> 00:02:55,694
in programming but with
notations naturally

35
00:02:55,694 --> 00:03:00,632
not inspired by the age when you
could type with the Typewriter, an

36
00:03:00,632 --> 00:03:05,710
O over a plus. A C, we have

37
00:03:05,710 --> 00:03:11,302
the tilde to say that it is
the reverse logic.

38
00:03:11,302 --> 00:03:16,385
One has the logical AND, it is normal.
One has the vertical bar

39
00:03:16,385 --> 00:03:20,911
which means the OR, and then
the small hat that means

40
00:03:20,911 --> 00:03:23,210
exclusive OR.

41
00:03:23,210 --> 00:03:29,620
So a somewhat more complex
element would be a referral.

42
00:03:29,620 --> 00:03:32,329
So,we know well,

43
00:03:32,329 --> 00:03:36,180
the electrical switches, eh, which
make it possible to bring

44
00:03:36,180 --> 00:03:41,670
the current from two different sources,
with a mechanical switch that moves.

45
00:03:41,670 --> 00:03:45,954
Well, we can, uh, we need the same
function, in the background,

46
00:03:45,954 --> 00:03:50,180
at logic circuits. You have an input
A, an input B; we

47
00:03:50,180 --> 00:03:55,110
would like to send to the
output S, ie A, if I

48
00:03:55,110 --> 00:04:00,689
is zero, or ET if I is equal to

49
00:04:00,689 --> 00:04:06,147
one. And in this, this new figure that I

50
00:04:06,147 --> 00:04:11,140
I enlarged from a page of an
integrated circuit catalog, well,

51
00:04:11,140 --> 00:04:17,620
uh, you see that it's used to
write the behavior,

52
00:04:17,620 --> 00:04:22,830
uh, of the interface, uh, the
processor will receive a signal that

53
00:04:22,830 --> 00:04:28,158
comes from this or that source,
depending on a condition, on a

54
00:04:28,158 --> 00:04:33,720
logical condition, and this signal
will be reused further.

55
00:04:33,720 --> 00:04:36,077
Uh, it is language,

56
00:04:36,077 --> 00:04:40,290
basically, to understand the
logical scheme.

57
00:04:40,290 --> 00:04:44,395
So, how can I, convert
the verbal description

58
00:04:44,395 --> 00:04:48,500
that I did just now in the form
of an equation?

59
00:04:48,500 --> 00:04:54,940
Well I will write S is equal to,

60
00:04:54,940 --> 00:05:01,170
if I is zero, it is l bar
that is active,

61
00:05:01,170 --> 00:05:07,378
times one, condition AND plus,
if I is a one, we will

62
00:05:07,378 --> 00:05:13,390
take the signal B times B.

63
00:05:13,390 --> 00:05:18,392
And there, we will find an AND gate
in a door, is an OR gate.

64
00:05:18,392 --> 00:05:23,520
It is the drawing that is here, I
was transposed into I bar.

65
00:05:23,520 --> 00:05:26,432
If we do not want

66
00:05:26,432 --> 00:05:32,408
to draw the inverter, we can put
a small circle directly with I.

67
00:05:32,408 --> 00:05:34,194
Here we shall have l bar.

68
00:05:34,194 --> 00:05:38,894
Here we see another example of notation.

69
00:05:38,894 --> 00:05:44,985
Multiplexers are switches with
more inputs, and if you

70
00:05:44,985 --> 00:05:51,504
imagine a gigabit memory, well, you
need a switch from a megabite

71
00:05:51,504 --> 00:05:56,781
position to choose the memory
word that interests you.

72
00:05:56,781 --> 00:05:59,175
Naturally, it will be constructed in

73
00:05:59,175 --> 00:06:01,650
an electronic way a little
more clever, and,

74
00:06:01,650 --> 00:06:03,442
and faster than with the logical systems,

75
00:06:03,442 --> 00:06:06,997
ah, that, as we have just evoked.

76
00:06:06,997 --> 00:06:11,865
Dimims, demultiplexers go in
the opposite direction;

77
00:06:11,865 --> 00:06:16,390
It is switches in peak, EF FF.

78
00:06:16,390 --> 00:06:20,863
You still have decoders, uh, the
decoder is the segment that

79
00:06:20,863 --> 00:06:25,794
allow to convert one, a number, a
group of bits in the poster

80
00:06:25,794 --> 00:06:31,701
of a segment oath, is a well-known example,
and all these elements are

81
00:06:31,701 --> 00:06:39,070
called combinatorial elements; you
will find them in the next lesson.

82
00:06:39,070 --> 00:06:41,506
Now let's talk about

83
00:06:41,506 --> 00:06:49,502
the sequential elements, and I'll show you
two inverters, one behind the other.

84
00:06:49,502 --> 00:06:51,872
If I have a zero on the input of this

85
00:06:51,872 --> 00:06:56,350
inverter, we will find a
one at its output.

86
00:06:56,350 --> 00:07:00,080
The one will be reversed again,
we will have a zero.

87
00:07:00,080 --> 00:07:06,420
If I have, for example, a one, well,
inverted, it will become a zero,

88
00:07:06,420 --> 00:07:08,121
and we will find one.

89
00:07:08,121 --> 00:07:13,454
And since I have the same input
and output each time,

90
00:07:13,454 --> 00:07:19,930
well, I can loop this item,
and it will be stable.

91
00:07:19,930 --> 00:07:26,845
By engaging it, I do not know
what, what value it will take.

92
00:07:26,845 --> 00:07:31,702
It is the simplest memory element
that can be realized in

93
00:07:31,702 --> 00:07:38,370
electronic form, which  can be drawn
with inverters, like this, that

94
00:07:38,370 --> 00:07:45,310
can be drawn again, by
making appear a certain symmetry.

95
00:07:45,310 --> 00:07:51,318
Here the symmetry is better, and
they prepare us, basically, to say,

96
00:07:51,318 --> 00:07:56,880
but this memory element, I would
like to be able to make it modify.

97
00:07:56,880 --> 00:08:01,610
If I have one, here, well, I'd like to have
a zero, for example, or vice versa.

98
00:08:01,610 --> 00:08:07,020
So, if you now consider this OR gate,

99
00:08:07,020 --> 00:08:10,151
if you have a zero on these inputs,

100
00:08:10,151 --> 00:08:14,540
the OR gate with this small
inversion, in front,

101
00:08:14,540 --> 00:08:19,030
is exactly the equivalent of the
inverter we saw here.

102
00:08:19,030 --> 00:08:22,101
But the interest of door I,
where is that if you

103
00:08:22,101 --> 00:08:27,330
now insert, you force a
logical one state,

104
00:08:27,330 --> 00:08:32,360
on that input, through the OR
gate, you will find one.

105
00:08:32,360 --> 00:08:36,610
You are here, with one, but
a zero on this side.

106
00:08:36,610 --> 00:08:41,210
Zero zero, on an OR gate, it makes a zero.

107
00:08:41,210 --> 00:08:47,390
The zero comes here, and we find
a one, which means that

108
00:08:47,390 --> 00:08:53,582
when the signal set has
disappeared, well, you

109
00:08:53,582 --> 00:08:59,420
will always have the snake biting its tail,
always the door that remains stable.

110
00:08:59,420 --> 00:09:03,440
So this is the most famous toggle

111
00:09:03,440 --> 00:09:08,536
of the beginning of computers,
logical systems.

112
00:09:08,536 --> 00:09:12,491
The RS flip-flop, no longer
interested in how it

113
00:09:12,491 --> 00:09:16,450
is wired, and with AND gates,
OR gates, inverters.

114
00:09:16,450 --> 00:09:22,079
There is a toggle function with
two outputs, one output

115
00:09:22,079 --> 00:09:27,590
Q and then the inverse output Q Bar,

116
00:09:27,590 --> 00:09:32,798
a reset input, a reset
input, called reset

117
00:09:32,798 --> 00:09:37,844
or clear, and this  flip-flop, its

118
00:09:37,844 --> 00:09:43,060
behavior can be represented in
the form of a state diagram.

119
00:09:43,060 --> 00:09:48,076
There are two equilibria possible,
Q equal zero, Q equal

120
00:09:48,076 --> 00:09:53,140
one. There is an input S here, which if

121
00:09:53,140 --> 00:09:58,122
it is zero, well, it will not
influence  the state, but

122
00:09:58,122 --> 00:10:03,077
if S is equal to one, we will switch,
we will go into the state

123
00:10:03,077 --> 00:10:06,996
Q equal to one, Or we go, uh,
remain, whether what

124
00:10:06,996 --> 00:10:10,636
we have, S equal zero, or that we have S

125
00:10:10,636 --> 00:10:14,390
equal one. And then, if we want
to make a field of

126
00:10:14,390 --> 00:10:21,650
state, well, it will be necessary  to act on
the input R which by default, it

127
00:10:21,650 --> 00:10:28,145
is at zero, and again, well we will tarry
on the other side, with a State

128
00:10:28,145 --> 00:10:32,580
R which is indifferent equals
zero or equal to one.

129
00:10:32,580 --> 00:10:37,140
So what we are interested in,
and that is knowing,

130
00:10:37,140 --> 00:10:40,440
that with the state S equal one,
R equal one, we can

131
00:10:40,440 --> 00:10:45,321
switch, and then now, if we
asked the question,

132
00:10:45,321 --> 00:10:50,360
If it acts simultaneously on S and on R?

133
00:10:50,360 --> 00:10:52,852
Well, we should not do it.

134
00:10:52,852 --> 00:10:58,942
As with a child toggle, you
swing it from one side or the other.

135
00:10:58,942 --> 00:11:02,063
If you act on both sides at once, you

136
00:11:02,063 --> 00:11:05,835
break it, and you are told
that you should not do it.

137
00:11:05,835 --> 00:11:07,930
This is for an explanation.

138
00:11:07,930 --> 00:11:13,242
Then,one more aspect of this rocker
is that it will be realized

139
00:11:13,242 --> 00:11:18,134
with electronics, and then,
the electronics always has

140
00:11:18,134 --> 00:11:24,435
a certain delay time. So, at the
moment when we are at the

141
00:11:24,435 --> 00:11:30,494
output S, statically you

142
00:11:30,494 --> 00:11:36,801
have the output that will go to
state one, and stay there

143
00:11:36,801 --> 00:11:42,240
until, uh, there is, uh, another,
another reaction on the other side.

144
00:11:42,240 --> 00:11:42,975
So,

145
00:11:42,975 --> 00:11:47,180
seen at the oscilloscope,
if you have a signal,

146
00:11:47,180 --> 00:11:51,760
input,

147
00:11:51,760 --> 00:11:57,450
which is as perfect as that; Often,
there are small roundings.

148
00:11:57,450 --> 00:12:03,230
Well, the output will evolve
with some delay,

149
00:12:03,230 --> 00:12:08,455
and if you look at very high
frequency,and you will

150
00:12:08,455 --> 00:12:14,177
always see a rounding, due to
parasitic capacities that exist

151
00:12:14,177 --> 00:12:19,860
everywhere, and then that,
that we try to minimize,

152
00:12:19,860 --> 00:12:22,996
where we must be careful
only when working at

153
00:12:22,996 --> 00:12:27,000
very high frequency, which Is not
our, ah, preoccupation.

154
00:12:27,000 --> 00:12:32,756
We have just seen a first so-called
stable flip-flop, the flip-flop RS.

155
00:12:32,756 --> 00:12:33,674
In

156
00:12:33,674 --> 00:12:39,282
logical system, there are several types
of flip-flops, we will be satisfied

157
00:12:39,282 --> 00:12:44,255
with studying only one, D flip-flop,
with which we can do

158
00:12:44,255 --> 00:12:49,524
many things, in particular shift
registers and counters.

159
00:12:49,524 --> 00:12:52,210
What is a D flip-flop?

160
00:12:52,210 --> 00:12:58,744
Well, it's a RS flip-flop, in which we
added to have a signal called clock, which

161
00:12:58,744 --> 00:13:03,924
logic to have a signal
called clock, and that

162
00:13:03,924 --> 00:13:08,990
has a new characteristic.
This signal is not

163
00:13:08,990 --> 00:13:13,910
static as we saw for set and reset.

164
00:13:13,910 --> 00:13:18,737
It is a signal that is dynamic,
which will be

165
00:13:18,737 --> 00:13:23,789
sensitive to a transition. It
is when the signal

166
00:13:23,789 --> 00:13:28,806
switches from state one to
zero that input D will be

167
00:13:28,806 --> 00:13:35,090
sampled and copied to the output.

168
00:13:35,090 --> 00:13:38,294
Thus, the time diagram shows this

169
00:13:38,294 --> 00:13:41,828
functionality, at the time of
the rising edge of

170
00:13:41,828 --> 00:13:46,015
the clock, the input D is sampled;

171
00:13:46,015 --> 00:13:49,196
It must be a little stable before,

172
00:13:49,196 --> 00:13:51,380
at a little stable afterwards.

173
00:13:51,380 --> 00:13:56,290
But it's microseconds or
nanoseconds, even now.

174
00:13:56,290 --> 00:14:00,290
In the meantime, the value
may be arbitrary.

175
00:14:00,290 --> 00:14:04,131
This is the next time that

176
00:14:04,131 --> 00:14:08,524
the new value will be sampled
and transferred.

177
00:14:08,524 --> 00:14:14,444
So here we had a zero, that zero
was transferred to the output.

178
00:14:14,444 --> 00:14:19,463
Here, we had a one,
it is transferred to the output.

179
00:14:19,463 --> 00:14:24,195
Here we had one, it was
transferred to the exit.

180
00:14:24,195 --> 00:14:29,564
So we see that there are very
important concepts,

181
00:14:29,564 --> 00:14:34,445
the concept of static elements that is
going to be dominant. The clock

182
00:14:34,445 --> 00:14:39,462
The dynamic clock that acts at a
transition, and then the signals

183
00:14:39,462 --> 00:14:44,900
which are sampled,which must
just exist, be valid

184
00:14:44,900 --> 00:14:49,776
at the moment of the transfer.
Several of these flip-flops

185
00:14:49,776 --> 00:14:54,470
side by side, well, we have
what we calls a parallel register.

186
00:14:54,470 --> 00:14:59,486
If you have, for example, training
one, a zero one on inputs,

187
00:14:59,486 --> 00:15:04,540
at the time of clock, you will
find this information

188
00:15:04,540 --> 00:15:09,370
a zero one on the outputs and
the information can change

189
00:15:09,370 --> 00:15:13,428
on the inputs, it will have no
effects on the outputs.

190
00:15:13,428 --> 00:15:17,940
So, it is really a memory element
that we will find everywhere.

191
00:15:17,940 --> 00:15:23,320
We will not draw it with flip-flops,
we will draw a

192
00:15:23,320 --> 00:15:28,700
rectangle, an eight-bit input
beam, but it could be, uh,

193
00:15:28,700 --> 00:15:33,645
different, a line beam output and this

194
00:15:33,645 --> 00:15:38,086
famous clock that will
make the transfer of

195
00:15:38,086 --> 00:15:43,202
the Input to the output.
We can also plug in

196
00:15:43,202 --> 00:15:48,565
these flip-flops one behind the
other, and what will

197
00:15:48,565 --> 00:15:53,920
happen is that at the first clock that

198
00:15:53,920 --> 00:16:01,499
repeats everywhere, well, the input
will be copied to the output.

199
00:16:01,499 --> 00:16:06,891
The input of the next flip-flop, we
do not know, since, uh, I

200
00:16:06,891 --> 00:16:12,400
did not tell you that all the flip-flops
had been reset initially.

201
00:16:12,400 --> 00:16:18,690
This will be copied as is on the
output, and likewise on Q three.

202
00:16:18,690 --> 00:16:23,560
Then, the  information that
has been assigned,

203
00:16:23,560 --> 00:16:28,310
it will spread gradually from one

204
00:16:28,310 --> 00:16:33,650
flip-flop to another, and then
we had programmed

205
00:16:33,650 --> 00:16:38,955
a one, which will also spread from
a flip- Other, and we will find out,

206
00:16:38,955 --> 00:16:44,270
in fact, the sequence that we entered,

207
00:16:44,270 --> 00:16:47,058
uh, three impulses in the age, earlier.

208
00:16:47,058 --> 00:16:52,285
So it's an element, that, uh, that
we will find a lot, to transmit

209
00:16:52,285 --> 00:16:58,580
the information in particular, since it is
enough to have only two lines,

210
00:16:58,580 --> 00:17:03,840
to transfer mos,of any length absolutely .

211
00:17:03,840 --> 00:17:08,150
This is another interesting achievement
with the so-called stable rocker.

212
00:17:08,150 --> 00:17:09,695
We have a clock,

213
00:17:09,695 --> 00:17:14,622
as usual; The output Q is
connected to the input.

214
00:17:14,622 --> 00:17:16,910
What does it mean?

215
00:17:16,910 --> 00:17:22,479
If I have a zero on this flip-flop,
the output Q bar is reversed,

216
00:17:22,479 --> 00:17:28,038
this value is found on the input.
So, at the next

217
00:17:28,038 --> 00:17:33,893
clock stroke, there is going to be
a transfer on the output,

218
00:17:33,893 --> 00:17:39,783
And then, we have a flip-flop that
deserves its flip-flop name,

219
00:17:39,783 --> 00:17:47,079
since it will change state at
each transition of the clock.

220
00:17:47,079 --> 00:17:53,094
So we have actually done one, one
divider by two, and if we know how

221
00:17:53,094 --> 00:17:59,330
to divide by two, well, we're going
to do a little divide by two

222
00:17:59,330 --> 00:18:03,640
and connect it to make a binary counter.

223
00:18:03,640 --> 00:18:11,126
Thus, the first flip-flop passes
to one at the first clock stroke.

224
00:18:11,126 --> 00:18:15,260
It goes to zero at the second
clock stroke, and it is

225
00:18:15,260 --> 00:18:18,970
at this point that the next toggle
should be activated.

226
00:18:18,970 --> 00:18:23,850
So, the output, it's an amount,
which activates the flip-flop.

227
00:18:23,850 --> 00:18:27,555
So, on the output, here
Q, one has a falling

228
00:18:27,555 --> 00:18:33,700
descending,but on the reverse
output, we have a rising edge.

229
00:18:33,700 --> 00:18:39,604
Thus, the time diagram here
shows that at each falling edge,

230
00:18:39,604 --> 00:18:45,571
we have action on the next stage,
and we will count in binary.

231
00:18:45,571 --> 00:18:48,628
So we did a binary counter.

232
00:18:48,628 --> 00:18:52,710
These decimal values do
not really interest us.

233
00:18:52,710 --> 00:18:57,904
What is interesting to note is
that at the moment

234
00:18:57,904 --> 00:19:03,190
when one, one, one, and one
sends a clock pulse,

235
00:19:03,190 --> 00:19:06,549
the first flip-flop changes,
acts on the clock,

236
00:19:06,549 --> 00:19:08,829
the next one, Which changes, acts on

237
00:19:08,829 --> 00:19:13,150
the next that changes to read
the zero that appears, here,

238
00:19:13,150 --> 00:19:14,820
then there.

239
00:19:14,820 --> 00:19:20,268
But you see that there is some
delay, a propagation time, which

240
00:19:20,268 --> 00:19:22,824
is not at all desirable, because

241
00:19:22,824 --> 00:19:25,500
it will slow down, in fact, the processor.

242
00:19:25,500 --> 00:19:30,184
This is where the logical systems
intervene to find solutions

243
00:19:30,184 --> 00:19:36,340
a little more elegant, a little
more effective to record a lag.

244
00:19:36,340 --> 00:19:38,377
A little exercise, to

245
00:19:38,377 --> 00:19:39,370
finish.

246
00:19:39,370 --> 00:19:41,610
Two flip-flops have been wired;
you recognize

247
00:19:41,610 --> 00:19:43,975
here a small shifted register element.

248
00:19:43,975 --> 00:19:48,580
You acknowledge here the
feedback of the counter by two.

249
00:19:48,580 --> 00:19:52,072
How is this system going to evolve?

250
00:19:52,072 --> 00:19:57,458
The habit is to note the successive
states, and then, when we start again

251
00:19:57,458 --> 00:20:02,405
at the beginning, well,
we will not rewrite, eh

252
00:20:02,405 --> 00:20:03,575
So here, there are three

253
00:20:03,575 --> 00:20:04,680
successive states.

254
00:20:04,680 --> 00:20:09,562
There are four successive states,
well, let's think about one

255
00:20:09,562 --> 00:20:14,950
little, and answer the question.

256
00:20:19,920 --> 00:20:21,264
Where is the answer?

257
00:20:21,264 --> 00:20:27,095
Well, if we try to analyze it a
little bit, here, the zero of

258
00:20:27,095 --> 00:20:33,060
the first flip-flop, it's a one
on the next flip-flop.

259
00:20:33,060 --> 00:20:41,228
So the Q one will recopy on the flip-flop Q two, and here, already,

260
00:20:41,228 --> 00:20:45,233
we see that it is obviously false.
On the other hand,

261
00:20:45,233 --> 00:20:51,220
the output Q two which was
at zero, is actually copied

262
00:20:51,220 --> 00:20:56,500
in the form of a one, uh,
on the flip-flop Q one.

263
00:20:56,500 --> 00:21:01,920
So that sequence is correct.
Here, the transfer is correct.

264
00:21:01,920 --> 00:21:07,340
Then the zero that is reversed
is in the form of one.

265
00:21:07,340 --> 00:21:10,595
One is inverted, is in the form of

266
00:21:10,595 --> 00:21:11,660
a zero.

267
00:21:11,660 --> 00:21:16,971
The one inverted, will be at the
beginning of the sequence,

268
00:21:16,971 --> 00:21:21,024
as well as the zero, and we
made the loop, we have

269
00:21:21,024 --> 00:21:26,834
a counter by four, according to a sequence
that we will also find, since

270
00:21:26,834 --> 00:21:30,990
we can notice that it There is only one
bit that changes at each transition.

271
00:21:30,990 --> 00:21:35,721
That is, we have a little idea of what
we can do with logical systems,

272
00:21:35,721 --> 00:21:41,218
and now we will have to continue
the complexity to arrive

273
00:21:41,218 --> 00:21:46,920
at a microprocessor
and a microcontroller.

