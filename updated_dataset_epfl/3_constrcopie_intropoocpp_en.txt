In this episode, we will focus on another particular constructor : the copy constructor.
Namely, we will wonder what happens when an object is initialized with a copy of another object of the same class.
C++ gives us a way to do instance copies. For example, we have here a first r1 instance of the "Rectangle" class which has been initialized through a usual constructor, here with two parameters. This results in the following situation in the memory.
This instance has thus been initialized to the values 12.3 and 24.5. We have here another "r2" instance of the very same
"Rectangle" class. r2 is initialized with a copy of r1.
This results in the following situation. r2 is initialized with a copy of the values, that is, 12.3 for the height and 24.5 for the width.
An initial copy occurs upon the creation of r2.
Naturally, "2 and r1 are distinct instances, living their life indepently in the memory. Simply, r2 is initialized, upon its building, with a copy of the values of r1. This is called the copy constructor.
Here is another example where we call the copy constructor.
Is this correct?
Yes! We indeed have a copy here since we are passing parameters by value. Remember, that when we pass parameters by value, the arguments are evaluated and copied into the function parameters.
We thus inded have a copy of r1 which will be copied into "r", a parameter of the "f" function. During the call to f of r1, the copy constructor of the
"Rectangle" class  is called.
The copy constructor is called because of passing parameters by value here; thus resulting in a copy. Obviously, if we pass the parameters by reference, there is no copy at all; the copy constructor is thus not called.
The goal of the copy constructor is to initialize an instance with a copy of another instance of the same class
Its prototype is thus fixed. Since it is a constructor, its name is none other than the class name. And since it initializes with a copy of another instance of the same, it will only receive one single parameter here. This parameter is another instance of the same class.
We will pass this other instance by constant reference in other to avoid passing parameters by value which would create another copy.
In this case, we would enter an infinite loop! making a copy of a copy of a copy...
Therefore, we use the passage by reference.
Also, the copy constructor does not modify the received instance but only modifies the instance it is currently initializing. Thus, it does not modified the received instance : this is a constant reference.
For example, in our rectangle case, we would have here a constructor called "Rectangle" for the "Rectangle" class.
It would receive another instance of the same "Rectangle" class, passed by constant reference. Of course, it would use the initialization section starting with a colon.
Here initializing the height of the instance it is creating with the value of the height of the other instance received as parameter. And similarly, initializing the width of the instance it is creating with the copy of the width of the other instance received as parameter. let us go back to the previous example. We have an r2 instance created with a copy of the r1 instance.
We indeed have a call to the copy constructor. In this case, r1 is the received parameter and r2 the initialized instance.
Here, we thus have "r2.hauteur" receiving "r1.hauteur" and "r2.largeur" receiving "r1.largeur".
By the way, often it is not necessary to write explicitly the copy constructor. Indeed, the C++ compiler provied us with a default one.
There is always a copy constructor furnished by default. We call it the default copy constructor.
This copy constructor carries out
 a so-called shallow copy.
This means that it will copy the parameter attributes of the other received instance one after the other in order to process the current initialization.
For example, in the case of our rectangle, we did not have to write the previous constructor. In this simple case, it is automatically generated by the compiler. It is thus not necessary to write this constructor which copies the "hauteur" attribute of the instance received as parameter into the "hauteur" of the instance we are currently initializing and copies the "largeur" of the received instance into the current instance and so on for every other possible attributes.
This is how the default copy constructor is build
Very often, this shallow copy suffices.
Most of the time, you thus will not need to write the copy constructor explicitly.
In certain cases though (we are anticipating on upcoming examples which we will face much later in this course) it will be necessary to express our very own copy constructor.
We will have to resort to a so-called deep copy.
We are showing it already, anticipating on upcoming concepts.
Here is a golden rule. If you have to touch one member of this triumvirate : the copy constructor, the destructor and the assignment operator
(that is, the equal operator), then you must at least ask yourselves wether you should also redefine the other two.
This golden rule anticipates on the concepts of the destructor and the assignment operator which will be presented later.
We have seen that a default copy constructor is automatically provided.
In certain cases, we could not wish to authorize the copy.
Since C++ 2011, we can explicitly ask to remove the copy constructor.
This can be useful when we are dealing, for example, with classes containing many on object. For example we could have the simulator of a physical word which we do not wish to copy with all its objects.
We wish to prevent copies of this huge object to be made since it contains many, many things.
This can be done with a particular syntax written : " = delete ".
We simply need to write
" = delete " just after the prototype of the copy constructor.
For example,  we have here a class we do not wish to copy.
We will call it "PasCopiable" (TN: means
"NotCopiable). Here are, as usual, all the class defenition. In order to avoid the copy we will start by adding a copy constructor. This is indeed a constructor, for it has the same method name as the name of the class.
Here we received a parameter by constant reference. Its type is the same as the class, thus "PasCopiable".
Now, we only need to add, here, at the end of the prototype " = delete ".
Therefore, we cannot call the copy constructor anymore since it has been destroyed, deleted; it exists no longer.
Now, this square is not copiable; we can simply initialize it with the other available constructors.
Instance copies are not longer possible.
VoilÃ ! This concludes this episode on the copy constructors in C++.
